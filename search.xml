<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[100 numpy exercises 总结篇]]></title>
    <url>%2F2020%2F10%2F02%2F100-numpy-exercises-%E6%80%BB%E7%BB%93%E7%AF%87%2F</url>
    <content type="text"><![CDATA[查看numpy的版本和配置 1234import numpy as npnp.__version__ # 查看版本np.show_config() # 查看配置 np.zeros默认$dtype$是浮点型的0 12np.zeros(10) # 一维np.zeros((3 , 3)) # 多维 np.ndarray.itemsize查看$ndarray$中一个元素的内存 123a = np.random.randn(3 , 4)# 输出：'float64' , 8 , 8 * 12 = 96(ndarray所占的内存)print(a.dtype , a.itemsize , a.itemsize * a.size) reverse一个vector1np.arange(10)[::-1] # 利用切片来转置 寻找ndarray的非0元素的下标使用np.nonzero() 123456789101112a = np.arange(12).reshape(3 , 4)a[1][1] = 0''' array([[ 0, 1, 2, 3], [ 4, 0, 6, 7], [ 8, 9, 10, 11]])'''np.nonzero(a) # 由于是2维的，所以len = 2，返回值是tuple'''(array([0, 0, 0, 1, 1, 1, 2, 2, 2, 2], dtype=int64), array([1, 2, 3, 0, 2, 3, 0, 1, 2, 3], dtype=int64))''' 创建一个单位矩阵np.eye 123456np.eye(3 , 3) # dtype 为浮点型'''array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])''' np.random.random()Return random floats in the half-open interval $[0.0, 1.0)$. 1np.random.random((3 , 3)) 寻找ndarray的最大值和最小值1234a = np.arange(12).reshape(3 , 4)a.max() # 寻找最大值，11a.max(axis = 0) # 输出：array([ 8, 9, 10, 11])a.min() 使一个array的周围都是01234567891011a = np.ones((5 , 5))a[: , [0 , -1]] = 0a[[0 , -1] , :] = 0a'''array([[0., 0., 0., 0., 0.], [0., 1., 1., 1., 0.], [0., 1., 1., 1., 0.], [0., 1., 1., 1., 0.], [0., 0., 0., 0., 0.]])''' np.nan和np.inf的一些运算123456780 * np.nan # nannp.nan == np.nan # Falsenp.inf &gt; np.nan , np.inf &lt; np.nan , np.inf == np.nan # (False , False , False)np.nan - np.nan # nannp.inf - np.inf # nannp.nan in set([1 , 2 , np.nan]) # Truetype(np.nan) # float0.3 == 0.1 * 3 # False np.diag(v , k)v: array_like 按照k和v来判断矩阵的大小(是方阵) 1234567891011121314151617181920212223np.diag(1 + np.arange(4) , k = 1) # 对角线上一格 5 * 5'''array([[0, 1, 0, 0, 0], [0, 0, 2, 0, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 4], [0, 0, 0, 0, 0]])'''np.diag(1 + np.arange(4) , k = -1) # 对角线下一格 5 * 5'''array([[0, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 2, 0, 0, 0], [0, 0, 3, 0, 0], [0, 0, 0, 4, 0]])'''np.diag(1 + np.arange(4) , k = 0) # 在对角线上 4 * 4'''array([[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]])''' 创建一个checkerboard pattern的矩阵方法1：1234567891011121314a = np.ones((8 , 8) , dtype = 'int')a[::2 , ::2] = 0a[1::2 , 1::2] = 0a'''array([[0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0]])''' 方法2：12345678910111213141516np.tile(np.array([[0 , 1] , [1 , 0]]) , (4 , 4))'''[[0 , 1][1 , 0]] 的块在axis = 0 和 axis = 1 上都重复4次''''''array([[0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0]])''' 给定一个array的维度，如何查看第i个元素的下标是多少np.unravel_index 12np.unravel_index(99 , (6 , 7 , 8)) # shape = (6 , 7 , 8)的第99个元素的小标为# (1, 5, 3) 创建一个dtype来描述(RGBA)1dtype1 = np.dtype([('r' , np.ubyte) , ('g' , np.ubyte) , ('b' , np.ubyte) , ('a' , np.ubyte)]) # 创建好类型 123456a = np.array([(1 , 2 , 3 , 4) , (5 , 6 , 7 , 8)] , dtype = dtype1)a'''array([(1, 2, 3, 4), (5, 6, 7, 8)], dtype=[('r', 'u1'), ('g', 'u1'), ('b', 'u1'), ('a', 'u1')])''' 将array中大于3且小于8的数取反用与运算 12a = np.arange(11)a[(a &gt; 3) &amp; (a &lt; 8)] 求两个array的交集np.intersect1d：求交集 1234567a = np.array([1 , 2 , 4 , 3 , 5])b = np.array([4 , 3 , 9 , 8])np.intersect1d(a , b)'''array([3, 4])''' 获取当前的今天和明天的日期12345678910a = np.datetime64('today') # 获取今天的日期a'''numpy.datetime64('2020-10-2')'''b = a + np.timedelta64(1 , 'D')b'''numpy.datetime64('2020-10-3')''' 123456789a = pd.Timestamp(a)a'''Timestamp('2020-10-02 00:00:00')'''a.year # 获取年'''2020''' 获取2016年7月的全部日期（以天为单位）修改dtye使得字符串变为时间 1234567891011np.arange('2016-07' , '2016-08' , dtype = 'datetime64[D]') # 换成Y就是年为单位，换成M就是月为单位'''array(['2016-07-01', '2016-07-02', '2016-07-03', '2016-07-04', '2016-07-05', '2016-07-06', '2016-07-07', '2016-07-08', '2016-07-09', '2016-07-10', '2016-07-11', '2016-07-12', '2016-07-13', '2016-07-14', '2016-07-15', '2016-07-16', '2016-07-17', '2016-07-18', '2016-07-19', '2016-07-20', '2016-07-21', '2016-07-22', '2016-07-23', '2016-07-24', '2016-07-25', '2016-07-26', '2016-07-27', '2016-07-28', '2016-07-29', '2016-07-30', '2016-07-31'], dtype='datetime64[D]')''' 提取正数的整数部分 (4 种方法)有关np.where的用法，参考：https://www.cnblogs.com/massquantity/p/8908859.html 123456a = np.random.uniform(-5 , 10 , 10)a'''array([-1.16420344, 3.95631045, 7.34675534, 8.03188626, 9.04815034, 6.5529346 , -1.46680238, 7.35797919, 3.9921186 , -3.76588798])''' 12345678910111213141516# 方法1：np.where(a &gt; 0 , a - a%1 , a)# 方法2：np.where(a &gt; 0 , a // 1 , a)# 方法3：np.where(a &gt; 0 , np.floor(a) , a)# 方法4：np.where(a &gt; 0 , a.astype(int) , a)'''array([-1.16420344, 3. , 7. , 8. , 9. , 6. , -1.46680238, 7. , 3. , -3.76588798])''' np.truncnp.trunc: 此函数返回输入数组元素的截断值。输入值$x$的截断值$t$是更接近0的整数, 比$x$更接近零。 1234567891011a = np.array([-4.5375666 , 1.54911477, -3.74455161, -2.41802724, 3.17252821, 8.00279135, -4.8008351 , 5.53268438, -2.19521765, 8.72607842])np.trunc(a)'''array([-4., 1., -3., -2., 3., 8., -4., 5., -2., 8.]'''# 对比np.floor，是取更小的元素np.floor(a)'''array([-5., 1., -4., -3., 3., 8., -5., 5., -3., 8.])''' 利用生成器方法来生成一个arraynp.fromiter: Create a new 1-dimensional array from an iterable object. 12345678def func(n): for i in range(n): yield i # 使得方法变成了生成器np.formiter(func(10) , dtype = float)'''array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])''' np.add.reduce(ndarray , axis)比np.sum更快 1234567891011a = array([1 , 2 , 3 , 4])np.add.reduce(a)'''10'''a = np.arange(12).reshape(3 , 4)np.add.reduce(a , axis = 0)'''array([12, 15, 18, 21])''' 使一个array 只读(read-only)12a = np.array([1 , 2 , 3])a.flags.writeable = False #写权限为 False 将直角坐标变为极坐标123456a = np.random.randn(10 , 2) # 直角坐标x = a[: , 0]y = a[: , 1]R = np.sqrt(x ** 2 + y ** 2) # 求长度T = np.arctan2(y , x) # 弧度制 求角度 np.arctan2(y , x) 求出来的范围是$[-pi , pi]$ 而np.arctan(y / x) 的范围是$[-pi/2 , pi/2]$ 将矩阵的每列的最小值置1 (特殊的切片方式)12345678910a = np.random.randn(5 , 5)a[np.argmin(a) , np.arange(5)] = 1a'''array([[ 1.03741769, 1. , 0.04588491, -1.56846048, -0.69702655], [ 0.07827971, 0.66178652, 1. , -0.15189357, -0.93276632], [ 0.48678279, -1.4055491 , 1.5417915 , -0.18737426, 0.40157406], [ 1. , 0.49162913, -1.27824055, -0.04964457, 1. ], [-0.91942993, -0.527093 , -2.30232503, 1. , -0.74834252]])''' 求[0,1]x[1,0]区域内所有坐标np.meshgrid: 生成网格坐标 np.linspace: 生成等差数列 123456789101112a = np.ones((5 , 5) , dtype = [('x' , np.float) , ('y' , np.float)])a['x'] , a['y'] = np.meshgrid(np.linspace(0 , 1 , 5) , np.linspace(0 , 1 , 5))a # 所有坐标'''array([[(0. , 0. ), (0.25, 0. ), (0.5 , 0. ), (0.75, 0. ),(1. , 0. )], [(0. , 0.25), (0.25, 0.25), (0.5 , 0.25), (0.75, 0.25),(1. , 0.25)], [(0. , 0.5 ), (0.25, 0.5 ), (0.5 , 0.5 ), (0.75, 0.5 ),(1. , 0.5 )], [(0. , 0.75), (0.25, 0.75), (0.5 , 0.75), (0.75, 0.75),(1. , 0.75)], [(0. , 1. ), (0.25, 1. ), (0.5 , 1. ), (0.75, 1. ),(1. , 1. )]], dtype=[('x', '&lt;f8'), ('y', '&lt;f8')])''' np.meshgrid12345678910111213# 对于2维矩阵来说，如果x坐标分成n份，y坐标分成m份，那么x的坐标矩阵就是mxn，y的坐标矩阵也是mxnnp.meshgrid(np.linspace(0 , 1 , 5) , np.linspace(0 , 1 , 4))'''[array([[0. , 0.25, 0.5 , 0.75, 1. ], [0. , 0.25, 0.5 , 0.75, 1. ], [0. , 0.25, 0.5 , 0.75, 1. ], [0. , 0.25, 0.5 , 0.75, 1. ]]), array([[0. , 0. , 0. , 0. , 0. ], [0.33333333, 0.33333333, 0.33333333, 0.33333333, 0.33333333], [0.66666667, 0.66666667, 0.66666667, 0.66666667, 0.66666667], [1. , 1. , 1. , 1. , 1. ]])]''' np.subtract.outer123456789101112131415np.subtract.outer(x , y):x: (1 , n)y: (1 , m)res: (n , m)，其中res[i][j] = x[i] - y[j]x = np.array([5 , 6 , 7 , 9])y = np.array([2 , 3 , 4])np.subtract.outer(x , y)'''array([[3, 2, 1], [4, 3, 2], [5, 4, 3], [7, 6, 5]])''' np.add.outer 也是类似 查看numpy的各种类型的最大值和最小值12345for dtype in (np.int16 , np.int32 , np.int64): print(np.iinfo(dtype).max , np.iinfo(dtype).min)print()for dtype in (np.float16 , np.float32 , np.float64): print(np.finfo(dtype).max , np.finfo(dtype).min) np.atleast_2d输入：arys1, arys2, … : array_like 函数作用：View inputs as arrays with at least two dimensions. 12345a = np.arange(12).reshape(6 , 2)b , c = np.atleast_2d(a[: , 0] , a[: , 1])b.shape , a[: , 0].shape'''((1, 6), (6,)) 1234np.atleast_2d(1 , 2 , [1 , 2]) # 都转为2d 的shape'''[array([[1]]), array([[2]]), array([[1, 2]])]''' scipy.spatial.distance.cdist更快地计算两点之间的距离 123456789Parameters----------XA：ndarray , 第一个点的坐标集合，shape:(n , m)，n是点的个数，m是点的坐标数量（比如是2d的就是x和y，如果是3d的就是x、y和z）。XB：ndarray , 第二个点的坐标集合metric：str or callable, optional，可选择计算什么距离----------return: ndarray，shape = (XA.shape[0] , XB.shape[0])，其中res[i][j] = XA[i]和XB[j]的距离可参考：https://blog.csdn.net/kancy110/article/details/75675574 123import scipy.spatiala = np.arange(4 , 3) # 3d 坐标scipy.spatial.distance.cdist(a , a , metric='euclidean') # 计算欧式距离（默认） 原地将float32 转为 int32使用np.ndarray.view numpy.ndarray.view中，提供对内存区域不同的切割方式，来完成数据类型的转换，而无须要对数据进行额外的copy，来节约内存空间。 12345678910111213141516171819a = (np.random.rand(10) * 100).astype(np.float32)b = a.view(np.int32) print(id(a) , id(b)) # 虽然a 和 b 的地址不同，但是共享内存 ，修改b ，a 也会改变'''121892256 122304432'''print(np.shares_memory(a , b)) # 是否共享内存'''True '''b[:] = a # 这样保证了 赋值后 b 的 dtype 不变 如果 用 b = a 的话，b 会完全成为 a print(b , type(b))'''[38 62 27 52 66 84 90 25 9 13] &lt;class 'numpy.ndarray'&gt;'''print(a) # 由于 修改了 b，所以 a 发生了改变 '''[5.32e-44 8.69e-44 3.78e-44 7.29e-44 9.25e-44 1.18e-43 1.26e-43 3.50e-44 1.26e-44 1.82e-44]''' np.ndenumeratenumpy array 的 enumerate 123456789101112a = np.arange(6).reshape(2 , 3)for i , v in np.ndenumerate(a): # 获取index 和相对应的值 print(i , v)'''(0, 0) 0(0, 1) 1(0, 2) 2(1, 0) 3(1, 1) 4(1, 2) 5''' 123456789101112a = np.arange(6).reshape(6)for i , v in np.ndenumerate(a): print(i , v)'''(0,) 0(1,) 1(2,) 2(3,) 3(4,) 4(5,) 5''' np.ndindex用于获取ndarray 的 index 123456789101112a = np.arange(6).reshape(2 , 3)for i in np.ndindex(a.shape): print(i)'''(0, 0)(0, 1)(0, 2)(1, 0)(1, 1)(1, 2)''' 生成一个2D Gaussian-like array这里不是生成一个array，其符合高斯分布，而是其坐标中$y$是$x$的高斯函数 高斯函数：$f(x)=a e^{-\frac{(x-b)^{2}}{2 c^{2}}}$ a表示得到曲线的高度； b(μ)是指曲线在x轴的中心； c(σ)指width(与半峰全宽有关)； 123456x , y = np.meshgrid(np.linspace(-1 , 1 , 10) , np.linspace(-1 , 1 , 10)) # 生成网格坐标mu = 0sigma = 1a = 1r = np.sqrt(x ** 2 + y ** 2)G = a * np.exp(-(r - mu) / (2 * (sigma) ** 2)) # 带入高斯公式 高斯函数和正态分布高斯函数只是一种函数； 而正态分布是一个随机变量$x$，其概率密度符合高斯函数： f(x)=\frac{1}{\sqrt{2 \pi} \sigma} \exp \left(-\frac{(x-\mu)^{2}}{2 \sigma^{2}}\right)那么$x$就符合正态分布 np.put12345678910Parameters----------a : ndarray Target array. 要放入的ndarrayind : array_like Target indices, interpreted as integers. 要放入的位置v : array_like 要放入的数字，如果len(v) &lt; len(ind)，那么就要重复v来填充mode : &#123;'raise', 'wrap', 'clip'&#125;, optional Specifies how out-of-bounds indices will behave. 越界后的处理，默认是'raise'，即报错 12345a = np.arange(12)np.put(a, [1 , 2 , 3 , 4 , 5], [100 , 1000])'''array([ 0, 100, 1000, 100, 1000, 100, 6, 7, -5, 9, 10, -5])''' np.random.choice在指定范围内随机选择几个数 12345np.random.choice(range(10*10) , 3 , replace = False) # replace: 是否可以重复采样'''array([45, 94, 47])''' keepdims 参数就是保留原来ndarray的一些维度 123456789# 比如:a = np.random.randn(5 , 4)a.mean(axis = 1).shape , a.mean(axis = 1 , keepdims = True).shape'''((5,), (5, 1))'''# 如果没有keepdims，那么输出的维度就有问题# 比如:a -= a.mean(axis = 1 , keepdims = True) # 如果不加keepdims，那么广播的时候会出问题 数组按第n列排序12a = np.random.randn(5 , 5)a[a[: , 1].argsort()] # 按第1列排序，得到行索引 np.flat当多维数组用一维坐标访问时用 1234561. Find the nearest value from a given value in an array (★★☆)a = np.random.randn(3 , 3)b = 0a.flat[np.abs(a - b).argmin()] # argmin 得到的是 一维的坐标，访问一维坐标用 np.ndarray.flat np.bincount详细，参考：https://blog.csdn.net/xlinsist/article/details/51346523 123456789a = np.random.randint(0 , 10 , 10)a'''array([0, 1, 1, 3, 1, 0, 7, 4, 0, 4])'''np.bincount(a)'''array([3, 3, 0, 1, 2, 0, 0, 1], dtype=int64)''' 12345678965. How to accumulate elements of a vector (X) to an array (F) based on an index list (I)? (★★★)x = np.array([1 , 2 , 3 , 10 , 5])i = np.array([1 , 3 , 2 , 1 , 4])F = np.bincount(i , x) # i 是 x , x 是 weightsF'''array([ 0., 11., 3., 2., 5.])''' 1234567891011121364. Consider a given vector, how to add 1 to each element indexed by a second vector (be careful with repeated indices)? (★★★)a = np.ones(10)i = np.random.randint(0 , len(a) , 20)print(i)'''[7 0 4 6 2 8 5 6 4 2 5 2 0 0 7 4 1 7 6 8]'''a += np.bincount(i , minlength = len(a))a'''array([4., 2., 4., 1., 4., 3., 4., 4., 3., 1.])''' 1234568. Considering a one-dimensional vector D, how to compute means of subsets of D using a vector S of same size describing subset indices? (★★★)sum_v = np.bincount(S , weights = D)sum_k = np.bincount(S)sum_v / sum_k np.unique返回一个array的唯一的值序列，结果会排序 1234566. Considering a (w,h,3) image of (dtype=ubyte), compute the number of unique colors (★★★)w , h = (16 , 16)img = (np.random.uniform(0. , 255. , (w , h , 3))).astype(np.ubyte)print(np.unique(img)) 在切片时加 None，补充一维12345a[: , : , None].shape , a[: , None , :].shape , a[None , : , :].shape , a[1:2 , : , None].shape'''((3, 4, 1), (3, 1, 4), (1, 3, 4), (1, 4, 1))''' 如何交换array的一行1234567891072. How to swap two rows of an array? (★★★)a = np.arange(12).reshape(3 , 4)a[[0 , 1]] = a[[1 , 0]] # 2d 的时候a'''array([[ 4, 5, 6, 7], [ 0, 1, 2, 3], [ 8, 9, 10, 11]])''' np.ndarray.repeat12345678910111213a'''array([[ 4, 5, 6, 7], [ 0, 1, 2, 3], [ 8, 9, 10, 11]])'''a.repeat(2 , axis = 1) # 每列重复两次'''array([[ 4, 4, 5, 5, 6, 6, 7, 7], [ 0, 0, 1, 1, 2, 2, 3, 3], [ 8, 8, 9, 9, 10, 10, 11, 11]])''' np.roll1234567891011Parameters----------a : array_like Input array.shift : int or tuple of ints The number of places by which elements are shifted. If a tuple, then `axis` must be a tuple of the same size, and each of the given axes is shifted by the corresponding number. If an int while `axis` is a tuple of ints, then the same value is used for all given axes. 负数是反方向移动axis 12345678910111213141516171819202122232425262728a = np.arange(12).reshape(3 , 4)a'''array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])'''np.roll(a , (1 , 2) , axis = (0 , 1)) # 行向下移动1格，列上右移动两格'''array([[10, 11, 8, 9], [ 2, 3, 0, 1], [ 6, 7, 4, 5]])'''np.roll(a , (1 , 2)) # 行和列均先移动一个，再移动2格'''array([[ 9, 10, 11, 0], [ 1, 2, 3, 4], [ 5, 6, 7, 8]])'''np.roll(a , (-2 , 2)) # 相当于没移动'''array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])''' 123456789101112131415161718192073. Consider a set of 10 triplets describing 10 triangles (with shared vertices), find the set of unique line segments composing all the triangles (★★★) 题意：使用10个三元数的集合描述10个三角形，找出组成这些三角形边的集合import numpy as npa = np.random.randint(0 , 100 , (10 , 3))b = np.roll(a.repeat(2 , axis = 1) , -1 , axis = 1)b = b.reshape(len(b) * 3 , 2)b = b.view(dtype = [('p0' , b.dtype) , ('p1' , b.dtype)]) # 使用view 来将原数组切分成二元组c = np.unique(b)c'''array([( 6, 57), (10, 22), (11, 21), (11, 41), (21, 42), (21, 87), (22, 30), (30, 10), (40, 11), (41, 40), (42, 65), (45, 93), (51, 88), (52, 75), (53, 82), (57, 84), (58, 45), (62, 66), (65, 21), (66, 97), (70, 52), (75, 70), (82, 93), (84, 6), (86, 51), (87, 11), (88, 86), (93, 53), (93, 58), (97, 62)], dtype=[('p0', '&lt;i4'), ('p1', '&lt;i4')])''' np.repeat12345678910Parameters----------a : array_like Input array.repeats : int or array of ints The number of repetitions for each element. `repeats` is broadcasted to fit the shape of the given axis.axis : int, optional The axis along which to repeat values. By default, use the flattened input array, and return a flat output array. 12345678np.repeat(np.arange(5) , [1 , 2 , 1 , 2 , 0])'''array([0, 1, 1, 2, 3, 3])'''np.repeat(np.arange(5) , 2)'''array([0, 0, 1, 1, 2, 2, 3, 3, 4, 4])''' 12345678910111274. Given an array C that is a bincount, how to produce an array A such that np.bincount(A) == C? (★★★)c = np.bincount([1,1,2,3,4,4,6])print(c)'''[0 2 1 1 2 0 1]'''a = np.repeat(np.arange(len(c)) , repeats = c)a'''array([1, 1, 2, 3, 4, 4, 6])''' np.cumsumReturn the cumulative sum of the elements along a given axis. 即前缀和 12345a = np.arange(5)np.cumsum(a , dtype = 'float64')'''array([ 0., 1., 3., 6., 10.])''' 1234567891011121375. How to compute averages using a sliding window over an array? (★★★)def Sliding_Window(a , n): ret = np.cumsum(a , dtype = 'float64') # 先算前缀和 ret[n:] -= ret[:-n] # 这里 ret[i] - ret[i - n] 得到每一块的和 ret[n-1:] /= n return ret[n-1:]a = np.arange(20)print(Sliding_Window(a , 3))'''[ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18.]''' stride_tricks.as_strided有关stride_tricks.as_strided 的用法，参考:https://zhuanlan.zhihu.com/p/64933417 12345678910111213141516171819202176. Consider a one-dimensional array Z, build a two-dimensional array whose first row is (Z[0],Z[1],Z[2]) and each subsequent row is shifted by 1 (last row should be (Z[-3],Z[-2],Z[-1]) (★★★)from numpy.lib import stride_tricksdef rolling(a , n): shape = (a.size - n + 1 , n) stride = (a.itemsize , a.itemsize) b = stride_tricks.as_strided(a , shape , stride) return brolling(np.arange(10) , 3)'''array([[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]])''' negate a boolean，将布尔数组取反使用 np.logical_not 123Z = np.random.randint(0,2,100)print(Z)np.logical_not(Z, out=Z) # out = Z 保证了 改变原来的数组 change the sign of a float inplace使用np.negative 1234Z = np.random.uniform(-1.0,1.0,10)print(Z)np.negative(Z, out=Z)Z 计算点到直线的距离可以利用向量积来求，由于向量积是两个向量所围成的平行四边形的面积，所以可以利用面积/底边来求高，这个高即是点到直线的距离 np.cross 是求向量的向量积，有关向量积的内容参考：https://www.bilibili.com/video/av6341515 123456778. Consider 2 sets of points P0,P1 describing lines (2d) and a point p, how to compute distance from p to each line i (P0[i],P1[i])? (★★★)p0 = np.random.uniform(-10 , 10 , (10 , 2)) # 直线的一端点p1 = np.random.uniform(-10 , 10 , (10 , 2)) # 直线的另一端点p = np.random.uniform(-10 , 10 , (1 , 2)) # 点np.abs(np.cross(p0 - p , p1 - p, axis = 1)) / np.linalg.norm(p0 - p1 , axis = 1) # 距离 = 面积 / 底边 计算矩阵的秩先对矩阵进行奇异值分解（SVD)，然后利用 非0奇异值的个数 = 矩阵的秩这一性质来求 有关奇异值分解(SVD)，参考: https://www.cnblogs.com/endlesscoding/p/10033527.html 和 https://blog.csdn.net/weixin_43991178/article/details/104906655 123456Z = np.random.uniform(0,1,(10,8))U, S, V = np.linalg.svd(Z) # Singular Value Decompositionprint(S)rank = np.sum(S &gt; 1e-10) # 非0 奇异值的个数 = 秩print(rank)print(U.shape , V.shape) np.tensordotnp.tensordot，参考： https://blog.csdn.net/weixin_28710515/article/details/90230842 1234567891086. Consider a set of p matrices wich shape (n,n) and a set of p vectors with shape (n,1). How to compute the sum of of the p matrix products at once? (result has shape (n,1)) (★★★)题意：p个(n,n)矩阵和p个(n,1)向量相乘，得到的p个(n,1)向量相加p , n = 10 , 20v1 = np.random.randint(1 , 10 , (p , n , n))v2 = np.random.randint(1 , 10 , (p , n , 1))# v1[: , i , :]对应的是v1 矩阵的行集合# v2[: , : , i]对应的是v2 的列集合np.tensordot(v1 , v2 , axes = [[0 , 2] , [0 , 1]]) # 对应的v1 的行和 v2 的列向乘 np.argpartitionnp.argpartition: 第一个参数 a 如果是a的话，是升序排列，如果是-a的话，就是降序排列 第二个参数kth，表示要选择的前k个元素，那么就把这前k个元素的索引排到前面，并不会排序，而只会筛选出这前几位元素，返回值是数组的索引。 123456789101112a = np.random.randint(0 , 10 , (2 , 20))a'''array([[7, 9, 1, 9, 1, 8, 6, 5, 5, 1, 8, 5, 3, 2, 2, 8, 2, 1, 7, 5], [6, 6, 7, 0, 7, 8, 0, 2, 2, 9, 1, 3, 1, 5, 2, 1, 0, 3, 0, 0]])'''b = np.argpartition(-a , kth = 5 , axis = 1)print(b)'''[[ 3 1 5 15 10 0 18 11 6 19 8 7 12 13 14 4 16 17 2 9] [ 5 9 2 1 4 0 6 7 8 3 10 11 12 13 14 15 16 17 18 19]]''' 12345678989. How to get the n largest values of an array (★★★)# 先将数组降序排列，然后选出前n 个元素a = np.arange(1000)np.random.shuffle(a)a[np.argpartition(-a , kth = 10 , axis = 0)][:10]'''array([997, 998, 995, 996, 999, 994, 992, 993, 991, 990])''' 记录数组和结构数组记录数组和结构数组的定义和区别，参考：https://blog.csdn.net/qq_27825451/article/details/102457045 123456789101112131415161718192021222324252691. How to create a record array from a regular array? (★★★)# 将普通数组转为记录数组Z = np.array([("Hello", 2.5, 3), ("World", 3.6, 2)])# 每一行是一种类型R = np.core.records.fromarrays(Z.T, names='col1, col2, col3', formats = 'S8, f8, i8')print(R)print(Z)print(Z.T)print(R.col1) # 记录数组的特殊索引'''[(b'Hello', 2.5, 3) (b'World', 3.6, 2)][['Hello' '2.5' '3'] ['World' '3.6' '2']][['Hello' 'World'] ['2.5' '3.6'] ['3' '2']][b'Hello' b'World']''' np.unpackbits将8位长整型元素数组展开成二进制形式 123456789101112131415161795. Convert a vector of ints into a matrix binary representation (★★★)I = np.array([0, 1, 2, 4, 8, 16, 32, 64, 128], dtype=np.uint8)print(np.unpackbits(I[:, np.newaxis], axis=1)) # 将一个8位长整形元素展开成二进制形式'''[[0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 1] [0 0 0 0 0 0 1 0] [0 0 0 0 0 1 0 0] [0 0 0 0 1 0 0 0] [0 0 0 1 0 0 0 0] [0 0 1 0 0 0 0 0] [0 1 0 0 0 0 0 0] [1 0 0 0 0 0 0 0]]''' 如何判断一个1d的array的所有元素都相等12345a = np.array([1] * 5)np.all(a[1:] == a[:-1]) # a[1:] == a[:-1] 相等于第1个元素和第2个元素向比较，第2个元素和第3个元素向比较，.....，知道第n-1个元素和第n个元素比较，如果都是True，那么说明所有元素都是相等的，如果有任何一个是False，那么就说明不是所有元素都是相等的。'''True''' 12345678910111213141516171819202122232425262728293094. Considering a 10x3 matrix, extract rows with unequal values (e.g. [2,2,3]) (★★★)题意：筛选出不是所有元素都相等的行a = np.random.randint(0 , 4 , (10 , 3))a'''array([[2, 0, 0], [0, 2, 3], [0, 3, 2], [2, 3, 3], [2, 0, 3], [3, 1, 0], [1, 2, 3], [0, 3, 0], [2, 3, 0], [1, 1, 1]])'''a[~np.all(a[: , 1:] == a[: , :-1] , axis = 1)]'''array([[2, 0, 0], [0, 2, 3], [0, 3, 2], [2, 3, 3], [2, 0, 3], [3, 1, 0], [1, 2, 3], [0, 3, 0], [2, 3, 0]])''' np.indicesnp.indices函数的作用是返回一个代表网格中所有序号的矩阵（给定shape）。 详细，参考：https://blog.csdn.net/isunLt/article/details/107620828 12345678910111213141590. Given an arbitrary number of vectors, build the cartesian product (every combinations of every item) (★★★)题意：求笛卡尔积求笛卡尔积，比如有三个array，分别是：[1 , 2 , 3] , [5 , 6] , [7 , 8] , 那么我们可以用下标来表示每一个笛卡尔积，那么就是从(0 , 0 , 0)一直到(2 , 1 , 1)，这就类似于网格坐标，所以我们可以先求网格坐标。def cartesian(arrays): arrays = [np.asarray(x) for x in arrays] shape = (x.shape[0] for x in arrays) # 在本样例中 (3 , 2 , 2) ix = np.indices(shape) ix = ix.reshape(3 , -1).T # 求出网格 for i , arr in enumerate(arrays): ix[: , i] = arrays[i][ix[: , i]] # 将网格坐标替换成相应的值 return ixprint(cartesian([[1 , 2 , 3] , [4 , 5] , [6 , 7]])) 如何实现等距采样等距采样就是每隔相等的距离采一次样。 可以采用一维线性插值法来获取不同的距离所对应的样本的值，一维线性插值法的函数：np.interp，详细，参考：https://blog.csdn.net/hfutdog/article/details/87386901 1234567891011121314151617181998. Considering a path described by two vectors (X,Y), how to sample it using equidistant samples (★★★)?题意：给定一条路径的(x , y)，让你等距采样出(x , y)点import matplotlib.pyplot as pltphi = np.arange(0,10*np.pi,0.1)a =1x = a*phi*np.cos(phi)y = a*phi*np.sin(phi)print(x.shape)dr = (np.diff(x)**2 + np.diff(y)**2)**.5 # np.diff 计算 后一个元素减去前一个元素，这一步计算的是相邻两个点的距离r = np.zeros_like(x)r[1:] = np.cumsum(dr)print(r)r_int = np.linspace(0, r.max(), 80) # 创建等差数列x_int = np.interp(r_int, r, x) #插值 一维线性插值，y_int = np.interp(r_int, r, y) #插值plt.subplot(133)plt.plot(x , y , x_int,y_int) np.diff后一个元素减去前一个元素 1234np.diff(np.array([1 , 2 , 3 , 4]))'''array([1, 1, 1])''' np.inner返回两个向量的内积 12345np.inner(np.array([1 , 2 , 3]) , np.array([1 , 2 , 3]))'''14''' ndarray 的 slice 切片操作1234567a = np.arange(25).reshape(5 , 5)a[[slice(0 , 3) , slice(0 , 3)]]'''array([[ 0, 1, 2], [ 5, 6, 7], [10, 11, 12]])''' x.setitem(i, y) &lt;==&gt; x[i]=y12345678910111213141516171819202122232425262728293031323334353637383985. Create a 2D array subclass such that Z[i,j] == Z[j,i] (★★★)题意：让我们创造出来的array不仅一开始的属性是对称矩阵，而且修改后也能是对称矩阵。class Symetric(np.ndarray):# x.__setitem__(i, y) &lt;==&gt; x[i]=y# 继承自ndarray 的 __setitem__，不重写的话是 x.__setitem__((i,j), y) &lt;==&gt; x[(i,j)]=y# 重写后： x.__setitem__(i, y) &lt;==&gt; x[(i,j)] = x[(j,i)] = y def __setitem__(self, index, value): i,j = index super(Symetric, self).__setitem__((i,j), value) super(Symetric, self).__setitem__((j,i), value)def symetric(Z): # np.asarray(Z + Z.T - np.diag(Z.diagonal())) 这样保证了一开始的时候是对称矩阵，但是不能使得修改某几个元素后的矩阵是对称矩阵，所以我们需要创造一个子类，使得这个子类具有这样的属性 return np.asarray(Z + Z.T - np.diag(Z.diagonal())).view(Symetric)a = np.random.randint(0,10,(5,5))print(a)'''[[2 7 2 0 6] [4 9 9 2 6] [0 3 1 1 6] [6 1 8 0 9] [8 4 2 2 7]]'''S = symetric(a)S[2,3] = 42print(S)'''[[ 2 11 2 6 14] [11 9 12 3 10] [ 2 12 1 42 8] [ 6 3 42 0 11] [14 10 8 11 7]]''' ndarray 子类实体的创建参考：https://blog.csdn.net/SAKURASANN/article/details/102750468 63. Create an array class that has a name attribute (★★☆)123456789101112131415# python中cls代表的是类的本身，相对应的self则是类的一个实例对象。class NamedArray(np.ndarray): # __new__ 用于创建一个实体 def __new__(cls, array, name="no name"): #print(array) obj = np.asarray(array).view(cls) # 得到一个ndarray 的子类的一个实体 #obj = super().__new__(cls , array) obj.name = name return obj# def __array_finalize__(self, obj):# if obj is None: return# self.info = getattr(obj, 'name', "no name")Z = NamedArray(np.arange(10), "lzclzc")print (Z.name , type(Z) , Z) __new__参考： https://blog.csdn.net/sj2050/article/details/81172022 http://c.biancheng.net/view/5484.html]]></content>
      <categories>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于图的图像分割]]></title>
    <url>%2F2020%2F09%2F09%2F%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[算法流程 设图有$n$个点，$m$条边，首先每个像素点都为一个区域，初始化区域集合$S = \{C_1 , C_2 , …. , C_n\}$。 对于$m$条边，按权值升序排列。 for q in range(m)，重复4的操作 对于边$(v_i , v_j)$，如果$v_i$和$v_j$不在同一颗树上，那么比较这条边和这两颗树的最大边$MInt$，如果$w(v_i , v_j) &lt; MInt$，那么合并这两棵树，否则，continue 基本概念$MInt$为一棵树的最大边 $\begin{array}{l}\operatorname{MInt}\left(C_{1}, C_{2}\right) =\min \left(\operatorname{Int}\left(C_{1}\right)+\tau\left(C_{1}\right), \operatorname{Int}\left(C_{2}\right)+\tau\left(C_{2}\right)\right)\end{array}$ $\tau(C)=k /|C|$ 为什么要有$\tau(C)$?当初始情况下，每个点都为一个区域，那么$MInt$都是0，如果没有$\tau(C)$，则两个像素点必须相同才能合并，所以我们要先设一个阈值，当我们的树逐渐增大时，这样阈值逐渐减小，而使得我们的自适应阈值逐渐起主导位置。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selective_Search]]></title>
    <url>%2F2020%2F09%2F09%2FSelective-Search%2F</url>
    <content type="text"><![CDATA[选择性搜索法出现之前的算法 穷举法或滑窗法，即在图片上的各个位置使用不同尺度不同大小的窗口来遍历物体的每一个位置，这样做框太多，复杂度高，而且不可能每个尺度都兼顾到，所以框不太标准。 选择性搜索的优点 可以适应多尺度：算法采用图像分割然后合并的方式将相似度大的区域作为一个整体区域 多样化：算法采用颜色、纹理、大小等多种策略来将分割好的区域合并 速度快：框较少 算法流程 先采用《基于图的图像分割算法》将原图分割，并将每一个像素点分好类，得到区域集合$R = \{r_1 , r_2 , r_3 …. r_n\}$ 初始化相似集合$S = ϕ$，然后对于每一个区域$i$和$j$，计算其相似度$s(r_i , r_j)$（只有两个区域有交集时才计算相似度），更新$S = S ∪ s(r_i,r_j)$ 当$S != ϕ$时，从$S$中选择相似度最大的区域对$s(r_i , r_j) = max(S)$，将$r_i$和$r_j$合并成区域$r_t$，即$r_t = merge(r_i , r_j)$，然后$S$中去掉与$r_i$有关的相似度$s(r_i , r_ )$和与$r_j$有关的相似度$s(r_ , r_j)$，计算$r_t$有关的相似度集合$S_t$，最后$S = S ∪ S_t$，$R = R ∪ r_t$，重复第3步 $R$中对应的区域即为所求的候选区域 相似度计算的策略颜色相似度对每个区域的3个颜色通道分别计算$25bins$的直方图，这样每个区域都生成了75维的向量$C = \{c_i^1 , c_i^2 , …., c_i^n\}$，然后$C /= size$，其中$size$为本区域的像素点的个数。 区域颜色相似度的计算：s_{\text {colour}}\left(r_{i}, r_{j}\right)=\sum_{k=1}^{n} \min \left(c_{i}^{k}, c_{j}^{k}\right). 区域合并后的颜色直方图：C_{t}=\frac{\operatorname{size}\left(r_{i}\right) \times C_{i}+\operatorname{size}\left(r_{j}\right) \times C_{j}}{\operatorname{size}\left(r_{i}\right)+\operatorname{size}\left(\mathrm{r}_{\mathrm{j}}\right)} 纹理相似度对每个区域的3个颜色通道的每个像素点计算其8个不同方向的$\sigma=1$的高斯导数，也可以用$LBP$特征，然后计算每个颜色通道的每个方向的$10bins$的直方图，获得240(10x8x3)的向量，纹理相似度计算以及直方图的更新与颜色相似度类似 优先合并小的区域s_{\text {size}}\left(r_{i}, r_{j}\right)=1-\frac{\operatorname{size}\left(r_{i}\right)+\operatorname{size}\left(\mathrm{r}_{j}\right)}{\operatorname{size}(image)}合适度f i l l\left(r_{i}, r_{j}\right)=1-\frac{\operatorname{size}\left(B B_{i j}\right)-\operatorname{size}\left(r_{i}\right)-\operatorname{size}\left(r_{i}\right)}{\operatorname{size}(image)}区域的合适度主要是为了衡量两个区域是否”吻合”，合并后的区域$BoundingBox$越小，其吻合度越高。 相似度的最终公式\begin{aligned} s\left(r_{i}, r_{j}\right)=& a_{1} s_{\text {colour}}\left(r_{i}, r_{j}\right)+a_{2} s_{\text {texture}}\left(r_{i}, r_{j}\right)+\\ & a_{3} s_{\text {size}}\left(r_{i}, r_{j}\right)+a_{4} s_{\text {fill}}\left(r_{i}, r_{j}\right) \end{aligned}其中$a_{i} \in\{0,1\}$]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卷积、激活函数和初始化]]></title>
    <url>%2F2020%2F08%2F28%2F%E5%8D%B7%E7%A7%AF%E3%80%81%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. 卷积层 1.3 公式$Y = W^TX+b$，其中$W$为卷积核参数 1.2 输出特征图大小设$N$为输入图像的大小，$P$为填充大小，$F$为卷积核大小，$stride$为步长，则： 输出特征图大小 = $（N + 2P - F）/ stride + 1$（这里默认图像和卷积核为正方形，上下左右填充和步长相同） 1.3 卷积核参数的个数设卷积核为$[N , C , H , W]$，那么参数个数为：$N\times(C\times H\times W + 1)$，一个卷积核有一个 $bias$。 2. 池化层池化是一种下采样，它压缩了输入的特征图，一方面减少了特征，导致了参数减少，进而简化了卷积网络计算时的复杂度；另一方面保持了特征的某种不变性（旋转、平移、伸缩等）。 2.1 池化层的作用 池化层保持了特征的某种不变性（旋转、平移、伸缩等），使得模型更关注是否存在某些特征而不是特征具体的位置。比如最大池化。 保留了主要特征，减少了特征，从而导致了参数减少，进而简化了卷积网络计算时的复杂度 在一定程度上能防止过拟合的发生 2.2 池化层分类最大池化层和平均池化层 3. 激活函数在卷积层或全连接层后的非线性函数叫激活函数。激活函数的输入是标量。 3.1 $Sigmoid$函数数学公式：$\sigma(x)=1 /\left(1+e^{-x}\right)$ 求导公式：$\frac{d \sigma(x)}{d x}=(1-\sigma(x)) \sigma(x)$ 特点：把输入值“挤压”到0到1范围内 图像： 缺点： Sigmoid函数饱和时会使梯度消失：当输入过大或过小时会饱和，使得梯度几乎为0，在反向传播时会阻碍梯度传递。因此，为了防止饱和，必须对于权重矩阵初始化特别留意。 Sigmoid函数的输出不是零中心的：这会导致Sigmoid激活函数层的下一层的输入均为正数，我们假设激活函数为sigmoid，则对于公式$f\left(\sum_{i} w_{i} x_{i}+b\right)$, 其导数为 \frac{\partial L}{\partial w}=\sigma\left(\sum_{i} w_{i} x_{i}+b\right)\left(1-\sigma\left(\sum_{i} w_{i} x_{i}+b\right)\right) x \times \frac{\partial L}{\partial f}，那么会导致导数（是向量）的正负依赖于$\frac{\partial L}{\partial f}$，而$\frac{\partial L}{\partial f}$是标量，所以所有$w_{i}$的正负都是一样的，所以会导致梯度下降权重更新时出现z字型的下降，即使得更新速度减慢。如图所示。 指数型计算量比较大。 3.2 $tanh$函数数学公式：$\tanh (x)=2 \sigma(2 x)-1$ 特点：将实数值压缩到[-1,1]之间。 图像： 缺点： 存在饱和问题 3.3 $relu$函数数学公式：$f(x)=\max (0, x)$ 特点： 一个关于0的阈值 图像： 优点： 只有负半轴会饱和 节省计算资源，不含指数运算，只对一个矩阵进行阈值计算 更符合生物学观念 加速随机梯度下降的收敛，Krizhevsky论文指出比sigmoid和tanh函数快6倍之多，据称这是由它的线性，非饱和的公式导致的。 缺点： 仍有一半会饱和 非零中心 relu单元比较脆弱并且可能“死掉”。当一个节点的梯度变为0时，那么从这个节点向后的节点的梯度均变为0，这使得参数没法更新。 3.3.1 造成梯度消失的原因 初始化的权值太差 学习率太大，导致梯度很大，那么权重的变化就很大，有可能使得输入为负数。 3.4 Leaky relu和PReLULeaky relu数学公式： $f(x)=\max (0.01 x, x)$ PReLU数学公式： $f(x)=\max (\alpha x, x)$ 特点： 解决“ReLU死亡”问题，x&lt;0时给出一个很小的梯度值，比如0.01。 图像： 3.5 指数线性单元（Exponential Linear Units，ELU）数学公式： $f(x)=\left\{\begin{array}{ll}x &amp; \text { if } x&gt;0 \\\alpha(\exp (x)-1) &amp; \text { otherwise }\end{array}\right.$ 特点： 介于ReLU和Leaky ReLU之间 图像： 4. 数据预处理4.1 去均值4.1.1 image mean将训练集中所有图片的同一位置的像素求均值。 1img = img - np.mean(train , axis = 0) # train 的shape为(n , 3 , w , h) 4.1.2 pixel mean分别计算训练集的$RGB$三个通道的像素均值。 1234567mean_rgb = np.array([0 , 0 , 0])count = 0for img in img_list: # [3 , w , h] for i in range(3): mean_rgb[i] += img[i , : , :].mean() count += 1mean_rgb /= count 4.1.3 图像去均值的目的 消除图像的共性，突显个体差异 为了进行数据特征标准化，即像机器学习中的特征预处理那样对输入特征向量各维去均值再除以标准差，但由于自然图像各点像素值的范围都在0-255之间，方差大致一样，只要做去均值处理即可。 构造0中心的数据，加快下降速度 标准化使得数据之间的差值缩小，而参数$w$的梯度和$x$有关，如果$x$之间相差太大，那么所求出的梯度也会相差很大，而不同梯度所对应的好的学习率不同，这样导致同一学习率不能使用不同的梯度。 4.2 标准化多一步除标准差。 4.3 测试集和训练集进行相同的预处理即测试集中的均值和标准差是通过训练集求得的。 因为深度学习算法是建立在训练集和测试集服从同一或者类似分布的假设之上的，所以预处理训练集和测试集要保持一致。 算法要求训练时不能有测试集的信息，所以不能是先预处理再分训练集和测试集。 5. 权重初始化5.1 全0初始化这种做法是错误的，这样会导致同一层的参数的梯度相同，进而进行相同的参数更新。 5.2 小随机数初始化1W = 0.01 * np.random.randn(fan_in,fan_out) 实验表明小随机数初始化在简单的网络中效果比较好，但是网络结构比较深的情况不一定会得到好的结果。比如一个10层的全连接网络，如图所示。 123456789101112131415161718192021222324252627import numpy as npimport matplotlibmatplotlib.use('TkAgg')import matplotlib.pyplot as plt%matplotlib notebook# 假设一些高斯分布单元D = np.random.randn(1000, 500)hidden_layer_sizes = [500]*10 # 隐藏层尺寸都是500，10层nonlinearities = ['tanh']*len(hidden_layer_sizes) # 非线性函数都是用tanh函数act = &#123;'relu': lambda x: np.maximum(0, x), 'tanh': lambda x: np.tanh(x)&#125;Hs = &#123;&#125;for i in range(len(hidden_layer_sizes)): X = D if i == 0 else Hs[i-1] # 当前隐藏层的输入 fan_in = X.shape[1] fan_out = hidden_layer_sizes[i] W = np.random.randn(fan_in, fan_out) * 0.01 # 权重初始化 H = np.dot(X, W) # 得到当前层输出 H = act[nonlinearities[i]](H) # 激活函数 Hs[i] = H # 保存当前层的结果并作为下层的输入# 绘制直方图fig , ax1 = plt.subplots(1 , 10 , figsize = (12 , 5))for i,H in Hs.items(): ax1[i].hist(H.ravel(), bins = 30, range=(-1,1))plt.subplots_adjust(wspace = 1) 可以看出，只有第一层表现好，后几层的均值和方差都接近于0，那么梯度就接近于0。 如果我们参数扩大，如下图，那么由于参数很大而且使用$tanh$函数，那么很容易达到饱和。 1W = np.random.randn(fan_in, fan_out) * 1 5.3 Xavier初始化1W = np.random.randn(fan_in, fan_out) / np.sqrt(fan_in) 这种初始化使得输入和输出有相同的分布。 我们设输出 $Y =\sum_{i}^{n} w_{i} x_{i}$，则： \begin{aligned} \operatorname{Var}(Y) &=\operatorname{Var}\left(\sum_{i}^{n} w_{i} x_{i}\right) \\ &=\sum_{i}^{n} \operatorname{Var}\left(w_{i} x_{i}\right) \\ &=\sum_{i}^{n} E(w_{i}^2x_{i}^2) - E(w_{i}x_{i})^2 \\ &= \sum_{i}^{n} E(w_{i}^2)E(x_{i}^2)-E(w_{i}x_{i})E(w_{i}x_{i}) \\ &= \sum_{i}^{n} (Var(w_{i})+E(w_{i})^2)(Var(x_{i})+E(x_{i})^2)-E(w_{i})^2E(x_{i})^2 \\ &=\sum_{i}^{n}\left[E\left(w_{i}\right)\right]^{2} \operatorname{Var}\left(x_{i}\right)+E\left[\left(x_{i}\right)\right]^{2} \operatorname{Var}\left(w_{i}\right)+\operatorname{Var}\left(x_{i}\right) \operatorname{Var}\left(w_{i}\right) \\ &=\sum_{i}^{n} \operatorname{Var}\left(x_{i}\right) \operatorname{Var}\left(w_{i}\right) \\ &=n \operatorname{Var}(w) \operatorname{Var}(x) \end{aligned}第六步我们假设输入和权重的均值都是0。所以当$\operatorname{Var}(\sqrt{1 / n} \cdot w)=1 / n \operatorname{Var}(w)=1 / n$时，$\operatorname{Var}(Y) = \operatorname{Var}(x)$ 结果： 但是，当我们使用$relu$时，如图，又出现了问题： 5.4 He初始化$relu$后的输出会有大约一半变为0，那么方差就会减半，所以我们用He初始化。 1W = np.random.randn(fan_in, fan_out) / np.sqrt(fan_in/2) 我们使得输出$Y$的方差变为2倍来抵消。 6. 批量归一化因为底层网络在训练的时候更新了参数，那么引起了输出数据分布的改变，那么我们在卷积层或全连接层后加$BN$层，就可以使得输出数据归一化。 6.1 算法前向推导公式 首先通过小批量训练集计算均值： $\mu_{\mathcal{B}} \leftarrow \frac{1}{m} \sum_{i=1}^{m} x_{i}$ 计算小批量训练集的标准差：$\sigma_{\mathcal{B}}^{2} \leftarrow \frac{1}{m} \sum_{i=1}^{m}\left(x_{i}-\mu_{\mathcal{B}}\right)^{2}$ 将本批次训练集归一化：$\widehat{x}_{i} \leftarrow \frac{x_{i}-\mu_{\mathcal{B}}}{\sqrt{\sigma_{\mathcal{B}}^{2}+\epsilon}}$ 计算输出：$y_{i} \leftarrow \gamma \widehat{x}_{i}+\beta$，其中$\gamma$和$\beta$分别为可学习的参数，让我们的网络可以学习恢复出原始网络所要学习的特征分布。批量归一化会把输入限制在非线性函数的线性区域，有时候我们并不想没有一点饱和，所以希望能控制饱和程度，所以引入了参数。 6.2 维度 在卷积层后使用$BN$时，我们以一张特征图为单位计算均值和方差，主要是为了节省参数。 6.3 BN在测试集测试集上的均值和方差： \begin{aligned} \mathrm{E}[x] & \leftarrow \mathrm{E}_{\mathcal{B}}\left[\mu_{\mathcal{B}}\right] \\ \operatorname{Var}[x] & \leftarrow \frac{m}{m-1} \mathrm{E}_{\mathcal{B}}\left[\sigma_{\mathcal{B}}^{2}\right] \end{aligned}7. 检查合理性 使用小参数进行初始化，使正则损失为0，确保得到的损失值与期望一致。例如，对于一个输入CIFAR-10的Softmax分类器，一般期望它的初始损失值是2.302，这是因为初始时预计每个类别的概率是0.1（因为有10个类别），然后Softmax损失值正确分类的负对数概率-ln(0.1) = 2.302。 提高正则化强度，损失值会变大 对小数据子集过拟合。在整个数据集进行训练之前，尝试在一个很小的数据集上进行训练（比如20个数据），然后确保能到达0的损失值（正则损失为0）。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>激活函数</tag>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2020%2F08%2F18%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[基本代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;int n;vector&lt;int&gt; parent;int Find(int x)&#123; // 并查集的查找父亲节点函数 int origin = x; while(x != parent[x])&#123; x = parent[x]; &#125; parent[origin] = x; // 查找的过程中顺便路径压缩 return x;&#125;void to_union(int x1 , int x2)&#123; // 将两个节点合并 int p1 = Find(x1); int p2 = Find(x2); parent[p2] = p1;&#125;bool isSame(int x1 , int x2)&#123; // 判断两个节点的父亲节点是不是相同 return Find(x1) == Find(x2);&#125;int main()&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); cin&gt;&gt;n; for(unsigned int i = 0 ; i&lt;n ; ++i)&#123; parent.push_back(i); // 初始化每个节点的父亲节点是自己 &#125; int u , v; int m; cin&gt;&gt;m; for(int i = 0 ; i&lt;m ; ++i)&#123; cin&gt;&gt;u&gt;&gt;v; to_union(u , v); &#125; for(int i = 0 ; i&lt;n ; ++i)&#123; Find(i); // 每个节点都路径压缩 &#125; for(int i = 0 ; i&lt;n ; ++i)&#123; cout&lt;&lt;parent[i]&lt;&lt;' '; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[910.最小差值II]]></title>
    <url>%2F2020%2F07%2F24%2F910-%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BCII%2F</url>
    <content type="text"><![CDATA[基本思路 我们先把数组排个序，题目要求求最小差值，那么就必须是大数-$k$，小数+$k$，这样才能尽可能地减小差值。 那么哪些是所谓的’大数’呢？我们可以设置一个分割点$i$，即$i$为序列中最后一个需要+$k$的下标，在$i$之前的数是小数，在$i$之后的数是大数。那么整个序列的最大值就是$max(A.back()-k , A[i] + k)$，最小值就是$min(A[0]+k , A[i+1]-k)$ 为什么分割点之前的数都是小数呢？首先我们令$i$是序列中最后一个需要+$k$的下标，使得$A[i]$要+$k$，其次$A[0]$一定要+$k$，$A.back()$一定要-$k$，我们设$j &lt; i$，由于$A[j]+k &lt; A[i]+k$，$A[j]-k$要么$&gt; A[0]+k$，此时对结果没有影响，要么$A[j]-k &lt; A[0]+k$，此时使得结果变大了，不可取，所以我们干脆使得$A[j]+k$，这样对结果没有影响，所以对于$j &lt; i$，$A[j]$必须+$k$。 为什么分割点之后的数都是大数呢？我们令$i$是序列中最后一个需要+$k$的下标，使得$A[i]$要+$k$，所以之后的都是大数了。 分割点不存在怎么办？不可能，分割点最小是0，此时的差值是$A.back()-A[0] - 2*k$。 代码12345678910111213class Solution &#123;public: int smallestRangeII(vector&lt;int&gt;&amp; A, int k) &#123; sort(A.begin() , A.end()); int res = A.back() - A[0]; for(int i = 0 ; i&lt;A.size() - 1 ; ++i)&#123; int Min = min(A[0] + k , A[i+1] - k); int Max = max(A.back() - k , A[i] + k); res = min(res , Max - Min); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[719.找出第k小的距离对]]></title>
    <url>%2F2020%2F07%2F21%2F719-%E6%89%BE%E5%87%BA%E7%AC%ACk%E5%B0%8F%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[基本思路 其实很常规，求第$k$个最小距离，我们已知了最小距离是0（不一定原数组里最小距离为0），最大距离为原数组最后一个元素 - 第一个元素（先排好序）。那么我们就可以用二分法来每次猜一个数，计算小于等于这个数的对数有多少（设为$sum$），然后和$k$比较。 关键是计算$sum$，我们先把原数组拍好序，然后生成$n*n$的矩阵表$v$，其中$v[j][i]$表示第$i$个数 - 第$j$个数，其中$i &gt; j$，如图所示： 我们有个序列1 2 3 4 5 6 7，我们用这个序列生成上面的二维表，上面的表其实覆盖了所有的差值，从图中可以看出，这个表同一行是递增的、同一列是递减的（因为前一个数比后一个数大），比如我们想求差小于等于3的个数，那么图中红线以下就是解。 所以思路是：我们遍历每一列（外循环），内循环遍历行，当前的数小于等于目标数时，进入下一列，当前的数大于目标数时，进入下一行。 疑问：为什么要求小于等于目标值而不是小于呢？如果是要求小于目标值的话，会丢失解，比如差值序列中有相同的数，那么他们的序号相同，且是最小序号，那么就会出现$left = mid + 1$，即直接把范围想右移动了，这样就丢失了目标解。所以我们在求第$k$个的时候，如果有相同的元素，那么我们要求相同元素的最大下标，然后用$right$缩小范围。 代码123456789101112131415161718192021222324class Solution &#123;public: int smallestDistancePair(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin() , nums.end()); int left = 0; int right = nums.back() - nums[0]; while(left &lt; right)&#123; int mid = (left + right) / 2; int j = 0; int sum = 0; for(int i = 1 ; i&lt;nums.size() ; ++i)&#123; for(j ; j &lt; nums.size() ; ++j)&#123; if(nums[i] - nums[j] &lt;= mid)&#123; break; &#125; &#125; sum += i - j; &#125; if(sum &gt;= k) right = mid; else left = mid + 1; &#125; return left; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题10.03.搜索旋转数组]]></title>
    <url>%2F2020%2F07%2F20%2F%E9%9D%A2%E8%AF%95%E9%A2%9810-03-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[基本思路 这道题是数组旋转，而不会有局部旋转，所以旋转后的数组一定会形成两段，且前一段中每个元素的值一定大于等于后一段每个元素的值，且两段都是各自升序排列。如果是一段的话，那就是原数组了。 既然是两段，那么这两段一定会有长度上的区别，我们设$left$为数组左端，$right$为数组右端。如图所示： 如果$mid$大于$left$，那么第一段长度大于第二段，从$left$到$mid$是一段升序的排列，我们可以通过$target$的值和$v[left]和v[mid]$比较来得出下一步的范围。 如果$mid$小于$left$，那么第一段长度小于第二顿，从$mid$到$right$是一段降序的排列，我们可以通过$target$的值和$v[left]和v[mid]$比较来得出下一步的范围。 当$v[mid] == v[left]$时是特殊情况如图所示： 当$v[mid] == v[left]$时，如果$target != v[mid]$，那么下一步的位置没法直接判断出来，需要$left++$ 来逐一缩小范围。 代码1234567891011121314151617181920212223242526272829class Solution &#123;public: int search(vector&lt;int&gt;&amp; arr, int target) &#123; int left = 0 , right = arr.size() - 1; while(left &lt; right)&#123; if(arr[left] == target) return left; int mid = (left + right) / 2; if(arr[left] &lt; arr[mid])&#123; if(arr[left] &lt;= target &amp;&amp; target &lt;= arr[mid])&#123; right = mid; //target == arr[mid]也是向左缩小范围，因为题目要求值相同的输出最小位置 &#125; else left = mid + 1; &#125; else if(arr[left] &gt; arr[mid])&#123; if(arr[left] &lt;= target || arr[mid] &gt;= target)&#123; right = mid; &#125; else left = mid; &#125; else if(arr[left] == arr[mid])&#123; //特殊情况 if(arr[left] == target)&#123; right = left; &#125; else left++; &#125; &#125; return (arr[left] == target) ? left : -1; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题17.08.马戏团人塔]]></title>
    <url>%2F2020%2F07%2F19%2F%E9%9D%A2%E8%AF%95%E9%A2%9817-08-%E9%A9%AC%E6%88%8F%E5%9B%A2%E4%BA%BA%E5%A1%94%2F</url>
    <content type="text"><![CDATA[基本思路 问题要的是一个序列，序列中每个元素中有两个数，前一个元素的第一个和第二个数都比后一个元素的两者大。 我们可以这样，先把元素按第一个数降序排列，然后如果有相同的数，那么按第二个数升序排列，然后按第二个数来求最大下降子序列的长度。 为什么第一个数相同时，按第二个数升序排列？这是因为如果按第二个数降序排列，而求的是最大下降子序列的长度，那么有可能会产生有两个元素第一个数相同，但是都被选中的结果。而升序排列就避免了这种情况。 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: struct peo&#123; int h , w; &#125;; static bool cmp(peo a , peo b)&#123; // 排序 if(a.h != b.h) return a.h &gt; b.h; else return a.w &lt; b.w; &#125; int bestSeqAtIndex(vector&lt;int&gt;&amp; height, vector&lt;int&gt;&amp; weight) &#123; vector&lt;peo&gt; v(height.size()); for(int i = 0 ; i&lt;height.size() ; ++i)&#123; v[i].h = height[i]; v[i].w = weight[i]; &#125; sort(v.begin() , v.end() , cmp); vector&lt;int&gt; d(v.size() + 1 , 0); d[1] = v[0].w; int len = 1; for(int i = 1 ; i&lt;v.size() ; ++i)&#123; // 求最大下降子序列的长度 if(d[len] &gt; v[i].w) d[++len] = v[i].w; else &#123; int left = 1 , right = len; while(left &lt;= right)&#123; int mid = (left + right) / 2; if(d[mid] &lt; v[i].w)&#123; right = mid - 1; &#125; else left = mid + 1; &#125; if(d[left - 1] != v[i].w)&#123; d[left] = v[i].w; //d[left]是序列中小于target的最大数 &#125; &#125; &#125; return len; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[300.最长上升子序列]]></title>
    <url>%2F2020%2F07%2F19%2F300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[基本思路 我们可以使用贪心来看，要想我们的序列尽可能地长，我们需要我们的序列上升得尽可能地慢。我们定义一个序列$d$，$d[i]$表示当前长度为$i+1$的上升子序列的末尾元素最小为$d[i]$，只有子序列末尾元素尽可能的小，后面才会有更多的数能插入到尽可能靠前的位置，从而形成尽可能长的序列。 当我们遇到一个数$nums[i]$，我们和序列$d$的最后一个元素进行比较，如果比这个元素小，那么就直接插入到序列$d$的末尾，否则，我们需要找到序列中比$nums[i]$大的最小元素，这里有个问题就是，如果序列$d$中有和$nums[i]$值一样的元素，那么此时不需要插入，这里需要特判一下。 代码123456789101112131415161718192021222324252627class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int n = nums.size(); vector&lt;int&gt; d(n+1 , 0); d[1] = nums[0]; int len = 1; for(int i = 1 ; i&lt;n ; ++i)&#123; if(nums[i] &gt; d[len]) d[++len] = nums[i]; else &#123; int left = 1 , right = len; while(left &lt;= right)&#123; int mid = (left + right) / 2; if(d[mid] &gt; nums[i])&#123; right = mid - 1; &#125; else left = mid + 1; &#125; if(d[left - 1] &lt; nums[i])&#123; // 特判一下 d[left] = nums[i]; &#125; &#125; &#125; return len; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[493.翻转对]]></title>
    <url>%2F2020%2F07%2F19%2F493-%E7%BF%BB%E8%BD%AC%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[解法1：树状数组+二分查找 基本思路题目要找的是前面的数比后面的数的两倍大的数，那么我们可以从后向前遍历，将以前遍历过的数存起来，得到序列$sum$，然后在遍历过的数中找到比当前数的1/2倍小的数的个数，这样最终就可以得到解。 难点1：如何计算个数？一开始想到的肯定是前缀和了，第$i$个前缀和表示小于等于第$i$个数的总个数，我们在序列$sum$中找到比当前数的1/2倍小的最大的数的下标$i$，然后求第$i$个前缀和就可以了。但是有个问题：前缀和的更新不方便。 这道题涉及到若干次查找和更新，所以我们可以考虑用树状数组来存遍历过的数的个数。所以我们定义树状数组$sum$来求前缀和，函数$getSum(i)$就可以求出第$i$个前缀和了。 难点2：如何找到比当前数的1/2倍小的最大的数的下标？首先，我们将原序列从小到大排序得到序列$v$，然后用二分查找来找到比当前数的1/2倍小的最大的数的下标，且下标从1开始，这样做的原因是树状数组的下标是从1开始的，所以这样可以对应，然后求和。 难点3：如何更新树状数组？首先更新树状数组需要知道第$i$个数是哪个数。由于第$i$个前缀和表示小于等于第$i$个数的个数，所以，我们需要用$map$来将拍好序的数字的位置确定下来，$map[j] = i$表示数字$j$是第$i$个数，这样，值小的数字的位置小，而且$map$中存的位置是这个数的最大位置，因为二分查找的时候找到的也是相同值的最大位置，这样可以对应。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: void update(vector&lt;int&gt; &amp;sum , int val , int index)&#123; while(index &lt; sum.size())&#123; sum[index] += val; //每次存入都是要+1 index += (index &amp; -index); &#125; &#125; int getSum(vector&lt;int&gt; &amp;sum , int index)&#123; int res = 0; while(index &gt; 0)&#123; res += sum[index]; index -= (index &amp; -index); &#125; return res; &#125; int left_bound(const vector&lt;int&gt; &amp;v , double target)&#123; int l = 0 , r = v.size(); while(l &lt; r)&#123; int mid = (l + r) / 2; if(v[mid] &lt; target)&#123; l = mid + 1; &#125; else r = mid; &#125; return l; &#125; int reversePairs(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; v(nums); sort(v.begin() , v.end()); int n = nums.size(); vector&lt;int&gt; sum(n+1 , 0); // 树状数组 map&lt;int , int&gt; m; for(int i = 0 ; i&lt;n ; ++i)&#123; m[v[i]] = i + 1; &#125; int res = 0; for(int i = n-1 ; i&gt;=0 ; --i)&#123; int index = left_bound(v , nums[i] / 2.0); res += getSum(sum , index); update(sum , 1 , m[nums[i]]); &#125; return res; &#125; &#125;; 解法2：归并排序基本思路在归并排序中，我们先把序列分成小块，然后逐块合并排序，在本题中，相邻两块除了要排序以外，我们需要计算前一块中的数$nums[i]$和后一块中的$num[j]$可以形成多少个翻转对。 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: void merge(vector&lt;int&gt; &amp;nums , int l , int mid , int r)&#123; //将两块排序后合并 vector&lt;int&gt; L(nums.begin()+l , nums.begin()+mid+1); vector&lt;int&gt; R(nums.begin()+mid+1 , nums.begin()+r+1); int i = 0 , j = 0; int n1 = mid - l + 1; int n2 = r - mid; for (int k = l; k &lt;= r; k++) &#123; if (j &gt;= n2 || (i &lt; n1 &amp;&amp; L[i] &lt; R[j])) nums[k] = L[i++]; else nums[k] = R[j++]; &#125; &#125; int mergeSort(vector&lt;int&gt; &amp; nums , int l , int r)&#123; if(l &lt; r)&#123; int mid = (l + r) / 2; int res = mergeSort(nums , l , mid) + mergeSort(nums , mid + 1 , r); int j = mid + 1; for(int i = l ; i&lt;=mid ; ++i)&#123; // 相邻两块求翻转对 for(j ; j&lt;=r ; ++j)&#123; if(nums[i] &lt;= nums[j] * 2LL)&#123; break; &#125; &#125; res += (j - mid - 1); &#125; merge(nums , l , mid , r); return res; &#125; else return 0; //当l == r时，即每块不可再分了 &#125; int reversePairs(vector&lt;int&gt;&amp; nums) &#123; return mergeSort(nums , 0 , nums.size() - 1); &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组简介]]></title>
    <url>%2F2020%2F07%2F19%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[树状数组的基本用法 现在有一个数组，我们要对其元素进行$m$次修改和$n$次区间查询。 如果我们用常规数组，那么修改很方便，是$O(m)$，但是区间查询的时候是$O(nq)$，其中$q$是查询的长度； 如果我们用前缀和，那么查询很方便，是$O(n)$，但是修改很麻烦。 所以，对于这种问题，我们用树状数组，其修改和查询的复杂度均为$O(logN)$。 lowbit函数lowbit函数就是要求给定的一个十进制数的二进制中最后的一个1所对应的十进制，比如lowbit(110) = 2，lowbit(101) = 1，lowbit(1100) = 4。 我们知道：求一个负数的补码可以先找到其对应的正数的补码的最后一个1，然后将这个1之前的数均取反，这样就得到了负数的补码。 所以我们将负数的补码和正数的补码做与运算，这样就只保留了最后一位的1，其他均是0了。 123int lowbit(int x)&#123; return x &amp; (-x);&#125; 树状数组的思想我们先看图： 图中绿色的块与下标一一对应，我们设数组$v$，其中数组$v$如图所示，即表示的是部分区间的和，可以发现，这个区间的长度是$lowbit(x)$。 要这个部分区间的和干什么呢？我们可以用它来代替前缀和。比如要求前缀和$sum(6)$，那么我们可以这样求：$sum(6) = v[6] + v[4]$，其中$4 = 6 - lowbit(6)$；在比如$sum(11) = v[11] + v[10] + v[8]$。这样，我们就得到了查询前缀和的代码： 12345678int getSum(int x , const vector&lt;int&gt; &amp;v)&#123; int res = 0; while(x &gt; 0)&#123; // 树状数组的下标从1开始 res += v[x]; x -= lowbit(x); &#125; return res;&#125; 可以看出，这样求前缀和是很快的。 除了代替前缀和，用$v$还有什么好处吗？从图中可以看出，当数组中一个元素变化时，$v$所需要的修改的地方比前缀和要少。比如修改了第一个位置，那么我们需要变的地方是$v[2]、v[4]、v[8]…..$，即我们只需要修改其祖先的点的值就可以了，我们还可以发现：$2 = 1 + lowbit(1), 4 = 2 + lowbit(2), 8 = 4 + lowbit(4)$，这样，我们就可以得到更新的代码： 1234567void update(int x , int val , vector&lt;int&gt; &amp; v)&#123; int n = v.size(); while(x &lt; n)&#123; v[x] += val; x += lowbit(x); &#125;&#125; 可以看出，更新的复杂度小了。 完整代码我们先输入n个数，然后进行m次查询，输入是’F’，则是查询，输入是’U’，则是修改。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;int lowbit(int x)&#123; return x &amp; (-x);&#125;int getSum(int x , const vector&lt;int&gt; &amp;v)&#123; int res = 0; while(x &gt; 0)&#123; res += v[x]; x -= lowbit(x); &#125; return res;&#125;void update(int x , int val , vector&lt;int&gt; &amp;v)&#123; int n = v.size(); while(x &lt; n)&#123; v[x] += val; x += lowbit(x); &#125;&#125;int main()&#123; freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); int n; cin&gt;&gt;n; vector&lt;int&gt; v(n+1 , 0); for(int i = 1 ; i&lt;=n ; ++i)&#123; int a; cin&gt;&gt;a; update(i , a , v); //for(auto i: v) cout&lt;&lt;i&lt;&lt;' '; //cout&lt;&lt;endl; &#125; for(auto i: v) cout&lt;&lt;i&lt;&lt;' '; cout&lt;&lt;endl; int m; cin&gt;&gt;m; for(int i = 0 ; i&lt;m ; ++i)&#123; char c; cin&gt;&gt;c; if(c == 'F')&#123; int a; cin&gt;&gt;a; cout&lt;&lt;getSum(a , v)&lt;&lt;endl; &#125; else &#123; int a , b; cin&gt;&gt;a&gt;&gt;b; update(a , b - v[a] , v); for(auto i: v) cout&lt;&lt;i&lt;&lt;' '; cout&lt;&lt;endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[378.有序矩阵中第K小的元素]]></title>
    <url>%2F2020%2F07%2F19%2F378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[378. 有序矩阵中第K小的元素 这道题也是求第$k$小的元素，只不过是整数，由于这是一个未排好的序列，所以用索引二分法不可行，只能按值来二分。由题中矩阵的性质来看，整个序列的范围是$[matrix[0][0],matrix[n-1][n-1]]$，是左闭右闭的，我们初始化$l=matrix[0][0]$，$r=matrix[n-1][n-1]$。 按值二分，那么我们每次的$mid$都是一个猜测出来的数，我们要求的就是序列中小于等于$mid$的数量，那么如果此数量&lt; $k$，我们令$l=mid+1$，如果此数量 &gt;= $k$，我们令$r=mid$。当$l == r$时，我们结束循环，返回$l 或 r$。 疑问1：解释一下每次$l$和$r$取值的原因当数量小于$k$时，那么此时的$mid$是不符合题意的，应当被剔除，所以$l = mid+1$后范围变成了[mid+1,r]，这是毫无疑问的； 当数量大于等于$k$，我们此时做了统一的处理就是$r = mid$，发现无论是大于还是等于，这个$mid$都做出了保留，这是因为我们求的是小于等于$mid$的数量，而且序列中有取值相同的元素，这些元素虽然位置不同，但是求出的数量是相同的，所以当数量大于$k$时，这个$mid$有可能是目标解，所以我们不能去除掉，所以得到$[l,mid]$。 疑问2：最终返回的是$l$(或$r$)，一定能保证返回的值在序列中？答案是一定的，虽然$l、r、mid$都是猜测值，但是我们发现代码是在循环结束后返回了唯一值，而在循环内没有返回值，这是因为： 可能找不到数量等于$k$的$mid$(因为有值相同的元素) 虽然找到了数量等于$k$的$mid$，但是毕竟$mid$是猜测值，我们没有办法保证$mid$一定在序列中 所以我们在循环中是没办法返回答案的。 虽然我们没法确保$mid$是序列中的值，而且可能找不到数量等于$k$的$mid$，但是我们在循环中每一步都保证目标解都在范围内，所以我们等到$l == r$时，此时范围内只有一个解了，这个解一定就是目标解了。 代码至于如何求数量，可以去看官方题解。 1234567891011121314151617181920212223242526272829class Solution &#123;public: int getSum(const vector&lt;vector&lt;int&gt;&gt; &amp;matrix , int k , int mid)&#123; int n = matrix.size(); int i = n-1 , j = 0; int res = 0; while(i &gt;=0 &amp;&amp; j &lt; n)&#123; if(matrix[i][j] &lt;= mid)&#123; res += i+1; ++j; &#125; else --i; &#125; return res; &#125; int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; int n = matrix.size(); int l = matrix[0][0] , r = matrix[n-1][n-1]; while(l &lt; r)&#123; int mid = (l + r) / 2; int sum = getSum(matrix , k , mid); if(sum &gt;= k)&#123; r = mid; &#125; else l = mid + 1; &#125; return r; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[786.第_K_个最小的素数分数]]></title>
    <url>%2F2020%2F07%2F19%2F786-%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0%2F</url>
    <content type="text"><![CDATA[786. 第 K 个最小的素数分数 题目求的是第$k$个最小分数，而这些分数的范围都是$(0,1)$，所以我们可以用二分法来求，初始化$left = 0.0 , right = 1.0$。求第$k$个最小分数，也就是有一个数，小于它的数有$k$个，这$k$个数里的最大的那个数就是第$k$个最小分数了。 所以对于每次求得的$mid$，我们求得小于$mid$的分数的数量，如果等于$k$，则我们找到了答案，如果大于$k$，则$r = mid$，如果小于$k$，则$l = mid$。 疑问1：此二分查找的终止条件是什么？终止条件是对于某一次$mid$，小于其的分数的数量等于$k$，就终止了。由于每次$mid$都是分数，所以对于序列中的任意两个相邻分数$x和y$，两者之间总能找到一个$mid$。 疑问2：为什么$l$和$r$都赋值为$mid$？因为现在的二分是按值二分，而不是按照索引二分，而且$mid、l、r$都是浮点数，我们二分的范围其实是$(l,r)$，所以每次缩小后的范围是$(mid,r)$或$(l,mid)$，这样并没有丢失目标解，因为现在$mid$是不符合题意的，所以这样是合理的。 疑问3：为什么$while$条件是$l &lt; r$ ?因为二分的范围是$(l,r)$，而且$l和r$都是浮点数，所以当$l &lt; r$时，$(l,r)$不是空集，当$l == r$时，$(l,r)$是空集，则结束循环。而且不会出现$l == r$的情况。 代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; kthSmallestPrimeFraction(vector&lt;int&gt;&amp; A, int k) &#123; int n = A.size(); double l = 0.0; double r = 1.0; while(l &lt; r)&#123; double mid = (l + r) / 2.0; int sum = 0; vector&lt;int&gt; res = &#123;0 , 1&#125;; int j = 0; for(int i = 0 ; i&lt;n ; ++i)&#123; while(j &lt; n &amp;&amp; A[i] &gt;= mid * A[j])&#123; ++j; &#125; sum += n - j; //对于每个mid，求出A[i]为分子且小于mid的分数的数量 if(j &lt; n &amp;&amp; res[0] * A[j] &lt; res[1] * A[i])&#123; res = &#123;A[i] , A[j]&#125;; // 更新为最大分数 &#125; &#125; if(sum == k)&#123; return res; &#125; else if(sum &lt; k)&#123; l = mid; &#125; else r = mid; &#125; return &#123;&#125;; //不可能出现的情况 &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2020%2F07%2F19%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[基本代码 写法11234567891011121314int B_search(const vector&lt;int&gt; &amp;v , int target)&#123; int l = 0 , r = v.size(); while(l &lt; r)&#123; int mid = (l + r) / 2; if(v[mid] &gt; target)&#123; r = mid; &#125; else if(v[mid] &lt; target)&#123; l = mid + 1; &#125; else return mid; &#125; return -1;&#125; 写法21234567891011121314int B_search(const vector&lt;int&gt; &amp;v , int target)&#123; int l = 0 , r = v.size() - 1; while(l &lt;= r)&#123; int mid = (l + r) / 2; if(v[mid] &gt; target)&#123; r = mid - 1; &#125; else if(v[mid] &lt; target)&#123; l = mid + 1; &#125; else return mid; &#125; return -1;&#125; 查找 &lt;= target 的最大位置 当target在序列中时，返回序列中最后出现target的位置 当target不在序列中，但是在序列的范围内时，返回比target的最大位置 当target比序列中任何元素都小时，返回-1 当target比序列中任何元素都大师，返回最后一个元素的位置 写法11234567891011int right_bound(const vector&lt;int&gt; &amp;v , int target)&#123; int l = 0 , r = v.size(); while(l &lt; r)&#123; int mid = (l + r) / 2; if(v[mid] &gt; target)&#123; r = mid; &#125; else l = mid + 1; &#125; return l - 1; // l 实际上指向的是大于target的最小位置&#125; 写法21234567891011int right_bound(const vector&lt;int&gt; &amp;v , int target)&#123; int l = 0 , r = v.size() - 1; while(l &lt;= r)&#123; int mid = (l + r) / 2; if(v[mid] &gt; target)&#123; r = mid - 1; &#125; else l = mid + 1; &#125; return l - 1;&#125; 查找 &lt; target 的个数其实也可以用来求&lt; target的最小位置 写法11234567891011int left_bound(const vector&lt;int&gt; &amp;v , int target)&#123; int l = 0 , r = v.size(); while(l &lt; r)&#123; int mid = (l + r) / 2; if(v[mid] &lt; target)&#123; l = mid + 1; &#125; else r = mid; &#125; return r; // 如果要返回&lt; target的最小位置，则是 return r-1;&#125; 写法21234567891011int left_bound(const vector&lt;int&gt; &amp;v , int target)&#123; int l = 0 , r = v.size() - 1; while(l &lt;= r)&#123; int mid = (l + r) / 2; if(v[mid] &lt; target)&#123; l = mid + 1; &#125; else r = mid - 1; &#125; return l; // 如果要返回&lt; target的最小位置，则是 return r;&#125; 查找 &lt; target 的最大位置，==target的最小位置 当target在序列中时，返回序列中第一次出现target的位置 当target不在序列中，但是在序列的范围内时，返回比target的最大位置 当target比序列中任何元素都小时，返回-1 当target比序列中任何元素都大时，返回最后一个元素的位置 写法11234567891011121314int left_bound(const vector&lt;int&gt; &amp;v , int target)&#123; int l = 0 , r = v.size(); while(l &lt; r)&#123; int mid = (l + r) / 2; if(v[mid] &lt; target)&#123; l = mid + 1; &#125; else r = mid; &#125; if(v[l] == target)&#123; return l; &#125; else return l-1;&#125; 写法21234567891011121314int left_bound(const vector&lt;int&gt; &amp;v , int target)&#123; int l = 0 , r = v.size() - 1; while(l &lt;= r)&#123; int mid = (l + r) / 2; if(v[mid] &lt; target)&#123; l = mid + 1; &#125; else r = mid - 1; &#125; if(v[l] == target)&#123; return l; &#125; else return r;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串-leetcode]]></title>
    <url>%2F2020%2F06%2F05%2F%E5%AD%97%E7%AC%A6%E4%B8%B2-leetcode%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[前缀树]]></title>
    <url>%2F2020%2F06%2F05%2F%E5%89%8D%E7%BC%80%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前缀树介绍 解析 https://blog.csdn.net/weixin_39778570/article/details/81990417?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-2 简单功能实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;typedef struct node&#123; bool terminal = 0; map&lt;char , node*&gt; child;&#125;node , *tree;void Insert(tree &amp;t , string s)&#123; //建树 int len = s.size(); for(int i = 0 ; i&lt;len ; ++i)&#123; if(!((t-&gt;child).count(s[i])))&#123; //cout&lt;&lt;s[i]&lt;&lt;endl; tree t1 = new node; (t-&gt;child)[s[i]] = t1; &#125; t = (t-&gt;child)[s[i]]; &#125; t-&gt;terminal = 1; //表示字符串在这一节点的结束&#125;bool Search(tree t , string s)&#123; int len = s.size(); for(int i = 0 ; i&lt;len ; ++i)&#123; if(!(t-&gt;child).count(s[i]))&#123; return false; &#125; t = t-&gt;child[s[i]]; &#125; return t-&gt;terminal;&#125;int main()&#123; tree t = new node; int n; cin&gt;&gt;n; tree t1 = t; for(int i = 0 ; i&lt;n ; ++i)&#123; string s; cin&gt;&gt;s; t = t1; Insert(t , s); &#125; t = t1; cin&gt;&gt;n; for(int i = 0 ; i&lt;n ; ++i)&#123; string s; cin&gt;&gt;s; cout&lt;&lt;Search(t , s)&lt;&lt;endl; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2F2020%2F06%2F05%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[KMP算法可以用来干什么 KMP算法是一种字符串模式匹配算法，可以用来求模式串在主串中的位置，时间复杂度是$O(m+n)$。 算法代码1(找第一个位置)123456789101112131415161718192021222324252627vector&lt;int&gt; getNext(const string &amp;s)&#123; //求查找表，可用于查找前后缀交集的最大 vector&lt;int&gt; next(s.size() + 1 , 0); next[0] = -1; int j = 0 , k = -1; while(j != s.size())&#123; if(k == -1 || s[k] == s[j])&#123; next[++j] = ++k; &#125; else k = next[k]; &#125; return next;&#125;int KMP(const string &amp;s , const string &amp;t)&#123; vector&lt;int&gt; next = getNext(t); int len_s = s.size(); int len_t = t.size(); int i = 0 , j = 0; while(i &lt; len_s &amp;&amp; j &lt; len_t)&#123; if(j == -1 || s[i] == t[j])&#123; ++i , ++j; &#125; else j = next[j]; &#125; if(j == len_t) return (i - j); else return -1;&#125; 算法原理我们设$i$为主串$s$的下标，$j$为模式串$t$的下标，朴素的查找方法是每次我们匹配长度为$t.size()$的串，如果不成功的话，$++i$，而且$j = 0$，即我们每次失败的时候模式串都是从头开始匹配，这样很明显造成了重复无意义的匹配，我们的思想就是尽可能第减少匹配的次数。 算法是如何减少匹配次数的我们可以发现，我们考虑$s[i] != t[j]$，前提是$s[i-j…i-1] == t[0…j-1]$，那么我们可以寻找$t[0…j-1]$中前缀和后缀的最大交集，我们设长度为$k$，即： t[0...k-1] == t[j-k...j-1]如果匹配失败，我们就可以把$j$移动到$k$处，而不是$0$处，因为移动到其他位置是没有意义的，这样就节省了时间了。 如何计算$k$的位置我们设$next[j]$表示如果$j$处匹配失败，那么$j$应该移动到的位置，即寻找的是$t[0…j-1]$中前缀和后缀的最大交集。 如果$t[j] == t[k]$，那么很明显$next[j+1] = next[j] + 1$ 如果$t[j] != t[k]$，那么很明显最大的交集的长度一定小于$next[j] + 1$，那么，我们怎么寻找呢，我们看图： 图中蓝色部分就是长度为$next[j]$的子串，我们下一步就是判断蓝色的串 + 黄色的块是不是符合$next[j+1]$，于是我们比较$t[k]$和$t[j]$，如果相等，那么$next[j+1] = next[k] + 1$，如果不等，那么我们继续比较蓝色串中的蓝色串。 为什么一定要找蓝色的串呢？还是那句话：找图中$next[k]$之前的位置是没有意义的，因为其他位置前后缀不一样。 为什么$next[0] = -1$如果模式串和主串的第一位就不一样，但是$next[0] == 0$的话，那么$k$会一直是$0$，程序陷入死循环，而$next[0] = -1$相当于特判一下，将$i$和$j$都向前移动一位。 算法代码2(查找所有位置)1234567891011121314151617181920212223242526272829303132vector&lt;int&gt; getNext(const string &amp;s)&#123; vector&lt;int&gt; next(s.size() + 1 , 0); next[0] = -1; int j = 0 , k = -1; while(j != s.size())&#123; if(k == -1 || s[k] == s[j])&#123; next[++j] = ++k; &#125; else k = next[k]; &#125; return next;&#125;vector&lt;int&gt; KMP(const string &amp;s , const string &amp;t)&#123; vector&lt;int&gt; next = getNext(t); vector&lt;int&gt; res; int len_s = s.size(); int len_t = t.size(); int i = 0 , j = 0; while(i &lt; len_s)&#123; if(j == -1 || s[i] == t[j])&#123; ++i , ++j; &#125; else j = next[j]; if(j &gt;= len_t)&#123; //不一样的地方 res.push_back(i - j); j = next[j]; &#125; &#125; return res;&#125; 图解参考https://blog.csdn.net/yyzsir/article/details/89462339]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO库]]></title>
    <url>%2F2020%2F05%2F25%2FIO%E5%BA%93%2F</url>
    <content type="text"><![CDATA[IO类 IO库类型与头文件 头文件 类型 宽字符类型 功能 iostream istream wistream 从流读数据 iostream ostream wostream 从流写入数据 iostream iostream wiostream 读写流 fstream ifstream wifstream 从文件中读取数据 fstream ofstream wofstream 从文件中写入数据 fstream fstream wfstream 读写文件 sstream istringstream w~ 从string读取数据 sstream ostringstream w~ 从string写入数据 sstream stringstream w~ 读写string ifstream和istringstream都继承自istrea，所以可以像使用istream对象来使用ifstream和stringstream对象。 IO对象不能拷贝和赋值由于不能拷贝和赋值，所以不能直接当做函数形参和返回值，因为两者都有拷贝，而是用&amp;来传参和返回。 例如：123456istream &amp;read(istream &amp;is , Sales_data &amp;item)&#123; //由于IO类属于不能拷贝的类型，所以用&amp;来传递 double price = 0; is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; item.revenue = price * item.units_sold; return is; //返回值也必须是&amp;类型，不然相当于拷贝&#125; IO库条件状态流的条件状态位有3位，用3位表示四种状态 标志 状态 功能 值(二进制) strm::badbit 用来指出流已崩溃 001 strm::failbit 用来指出一个IO操作失败了 100 strm::eofbit 指出流达到了文件末尾 010 strm::goodbit 指出流未处于错误状态 000 IO库定义了4个$iostate$类型的constexpr值，其实是二进制格式的，所以可以用位运算来设置标志位。即上面这四个值是固定的。 1cout&lt;&lt;cin.goodbit&lt;&lt;' '&lt;&lt;cin.badbit&lt;&lt;' '&lt;&lt;cin.failbit&lt;&lt;' '&lt;&lt;cin.eofbit; //0 1 4 2 函数 函数 功能 s.eof() 如果流s的eofbit置位，则是true s.fail() 如果流s的failbit置位，则是true s.bad() 如果流s的badbit置位，则是true s.good() 如果流s处于有效状态，则是true s.clear() 将流s的所有条件状态为复位。viod类型 s.clear(flags) 给定flags状态位，将流s相应的条件状态位复位。viod类型 s.setstate(flags) 给定flags状态位，将流s相应的条件状态位置位。viod类型 s.rdstate() 返回s的条件状态，返回类型为strm::iostate 查询和管理流状态流的状态可以用二进制来表示，比如000表示babbit、failbit、eofbit都没有置位；110表示failbit和eofbit置位。 1234567cout&lt;&lt;cin.rdstate()&lt;&lt;endl; //比如是000cin.setstate(cin.rdstate() | cin.badbit | cin.failbit); //将cin的badbit和failbit置位cout&lt;&lt;cin.rdstate(); //101 即5cin.clear(cin.rdstate() &amp; ~cin.badbit &amp; ~cin.failbit); // 与操作，复位cout&lt;&lt;cin.rdstate(); //恢复到000 文件输入输出12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;struct PersonInfo &#123; string name; vector&lt;string&gt; phones;&#125;;int main(int argc , char *argv[])&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); string line , word; vector&lt;PersonInfo&gt; people; ifstream s("C:\\Users\\lzc\\Desktop\\C++\\input.txt"); //打开文件 while(getline(s , line))&#123; //按行读取 cout&lt;&lt;line&lt;&lt;endl; PersonInfo info; istringstream record(line); //拷贝line，从string中读取数据 record &gt;&gt; info.name; //从record中读取 //cout&lt;&lt;"name:"&lt;&lt;info.name&lt;&lt;endl; while(record &gt;&gt; word)&#123; info.phones.push_back(word); //cout&lt;&lt;"word::"&lt;&lt;word&lt;&lt;' '&lt;&lt;1; &#125; //cout&lt;&lt;endl; people.push_back(info); &#125; s.close(); ofstream out("clustering.txt"); //默认清除当前文件内容，然后打开 //ofstream out("clustering.txt" , ofstream::app); //定位到文件末尾，就不会清除内容了 for(const auto &amp;entry : people)&#123; ostringstream formatted , badNums; for(const auto &amp;nums : entry.phones)&#123; formatted &lt;&lt; " " &lt;&lt; nums; //写入formatted对象中 &#125; out &lt;&lt; entry.name&lt;&lt;' '&lt;&lt;formatted.str()&lt;&lt;endl; //写入文件 &#125;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类]]></title>
    <url>%2F2020%2F05%2F11%2F%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[类的基础知识点 Sales_data类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#include&lt;iterator&gt;using namespace std;class Sales_data&#123; friend istream &amp;read(istream &amp;is , Sales_data &amp;item); //友元函数，可以访问类的private成员 friend ostream &amp;print(ostream &amp;os , const Sales_data &amp;item);public: string isbn() const &#123;return bookNo;&#125;; //指向常量的指针，这个const表示this指针所指向的对象是const，即不能改变 const Sales_data *const，体现在了第一个const上 Sales_data&amp; combine(const Sales_data&amp;); //构造函数 Sales_data() = default; //强制要求编译器生成默认构造函数，不然合成的默认构造函数只有在没有定义构造函数时才生成 Sales_data(const string str): bookNo(str) &#123;&#125;; //构造函数初始值列表，是初始化const或引用类型成员的唯一方法 Sales_data(const string str , unsigned n , double p) : bookNo(str) , units_sold(n) , revenue(p*n) &#123;&#125;; Sales_data(istream &amp;);private: string bookNo; //如果没有构造函数，那么合成的构造函数就会对其进行默认初始化 unsigned units_sold = 0; double revenue = 0.0; double avg_price() const &#123;return units_sold ? revenue / units_sold : 0;&#125;&#125;;istream &amp;read(istream &amp;is , Sales_data &amp;item)&#123; //由于IO类属于不能拷贝的类型，所以用&amp;来传递 double price = 0; is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; item.revenue = price * item.units_sold; return is; //返回值也必须是&amp;类型，不然相当于拷贝&#125;Sales_data::Sales_data(istream &amp;is)&#123; //构造函数可以定义在类的外面 read(is , *this);&#125;Sales_data&amp; Sales_data::combine(const Sales_data &amp;rhs)&#123; revenue += rhs.revenue; units_sold += rhs.units_sold; return *this; //返回的是Sales_data类的&amp;类型，可以是左值返回，即返回值可以当成是左侧运算对象，不能是拷贝&#125;ostream &amp;print(ostream &amp;os , const Sales_data &amp;item)&#123; //必须用&amp;，不然是拷贝，那么就毫无意义 os &lt;&lt; item.isbn() &lt;&lt; ' ' &lt;&lt; item.units_sold &lt;&lt; ' ' &lt;&lt; item.revenue &lt;&lt; ' ' &lt;&lt; item.avg_price(); return os;&#125;Sales_data add(const Sales_data &amp;lhs , const Sales_data &amp;rhs)&#123; Sales_data sum = lhs; sum.combine(rhs); return sum;&#125;int main()&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); //test(42); Sales_data s("lzc" , 2 , 10); read(cin , s); print(cout , s) &lt;&lt; endl; Sales_data s1 = s; print(cout , s1) &lt;&lt; endl; Sales_data s2 = add(s , s1); print(cout , s2) &lt;&lt; endl;&#125; Screen类和Window_mgr类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#include&lt;iterator&gt;using namespace std;class Screen &#123; friend class Window_mgr; //友元类 //friend Window_mgr::clear(ScreenIndex); //可以把一个类的某个成员函数设为友元函数public: typedef string::size_type pos; //用来定义类型的成员必须先定义后使用，所以一般放在类开始的地方 //using pos = string::size_type; //等价定义 Screen() = default; Screen(pos ht , pos wd = period , char c = '^'): height(ht) , width(wd) , contents(ht*wd , c)&#123;&#125;; //使用默认实参，必须保证默认实参后边的实参都是有默认实参的，其中静态变量可以作为默认实参，而普通成员变量不能 explicit Screen(char c): Screen(4,2,c) &#123;&#125;; char get() const &#123;return contents[cursor];&#125;; //读取光标处的字符 inline char get(pos ht , pos wd) const; //内联函数 Screen &amp;move(pos r , pos c); Screen &amp;set(char); Screen &amp;set(pos , pos , char); Screen &amp;display(ostream &amp;os) &#123; do_display(os); return *this; &#125; const Screen &amp;display(ostream &amp;os) const &#123; do_display(os); return *this; &#125;private: static int period; //静态成员存在于任何对象之外，即对象中不包含任何与静态成员有关的数据，被类的所有对象所共享 pos cursor = 0; //光标 pos height = 0 , width = 0; string contents; //屏幕内容 mutable size_t access_ctr = 0; //可变数据成员 void do_display(ostream &amp;os) const &#123; os &lt;&lt; contents; &#125;&#125;;int Screen::period = 4; //静态成员必须在类的外部定义和初始化class Window_mgr&#123;public: using ScreenIndex = vector&lt;Screen&gt;::size_type; void clear(ScreenIndex);private: vector&lt;Screen&gt; screens&#123;Screen(24 , 80 , ' ')&#125;;&#125;;void Window_mgr::clear(ScreenIndex i)&#123; Screen &amp;s = screens[i]; s.contents = &#123;s.height * s.width , ' '&#125;;&#125;inline Screen &amp;Screen::set(char c)&#123; contents[cursor] = c; return *this;&#125;inline Screen &amp;Screen::set(pos r , pos col , char ch)&#123; contents[r*width + col] = ch; return *this;&#125;inlineScreen &amp;Screen::move(pos r , pos c)&#123; cursor = r * width; cursor += c; return *this;&#125;char Screen::get(pos r , pos c) const &#123; pos row = r * width; row += c; return contents[row];&#125;int main()&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); //Screen s = Screen('^'); //Screen s = static_cast&lt;Screen&gt;('^'); Screen s = &#123;4 , 2 , '*'&#125;; s.move(3 , 0).set('$'); cout&lt;&lt;s.get()&lt;&lt;endl; s.display(cout).set('&amp;'); cout&lt;&lt;endl; s.display(cout); cout&lt;&lt;endl;&#125; 1. Screen(char c): Screen(4,2,c) {}; 的写法这其实也是构造函数，是委托构造函数，Screen(4,2,c)是受委托的函数。执行时，受委托的构造函数的初始值列表和函数体先执行，然后在执行委托者的函数体。 2. explicit Screen(char c): Screen(4,2,c) {}; 中的explicitexplicit 可以抑制构造函数定义的隐式转换。 123456//如果去掉中的explicit，那么下面的代码是可以通过的Screen s = '^';//这是因为这样相当于编译器自动调用了Screen('^')，即进行了类类型转换，然后把一个临时的Screen对象赋给了s。//但是类类型转换只能发生一步，比如，假定item是Sales_data的一个对象：item.combine("123");//这是不行的，我们需要把"123"先转成string，然后才能由string转成Sales_data 3. 为什么move，set，这些函数要左值返回？有什么好处？左值返回意味着我们可以当做左侧运算对象。123// 如果不是左值返回，那么下面代码无法通过：s.move(3 , 0).set('$');//如果是左值返回，那么s.move(3 , 0)返回的是一个Screen对象的&amp;，即还是返回了s，那么就可以调用set函数了。 4. 为什么display函数要定义两个？因为display函数只是负责打印而没有修改的功能，所以我们希望display为const成员，所以this指针将是指向const的指针，所以display返回类型是const Screen &amp;，注意const Screen &amp;display(ostream &amp;os) const 中const Screen &amp;才是返回类型。123//如果display返回的是const Screen &amp;，那么下边的代码无法通过编译：s.display(cout).set('&amp;');//所以我们重载一个非const版本 5. 为什么要单独定义do_display这个函数？这就是公共代码使用私有功能的函数 避免重复相同的代码 修改代码时更方便 不会带来额外开销，类内隐式被声明为inline函数]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2020%2F05%2F10%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[10. 正则表达式匹配https://leetcode-cn.com/problems/regular-expression-matching/ 方法1如果没有的话，那么就是一个字符一个字符匹配，但是有\的存在使得问题变得复杂。而题目中说*可以匹配0个、1个和多个字符，所以我们要分情况讨论。我们必须把*和其前面的字符看做一个整体。设$p[j+1]$为* 如果$p[j]\ != s[i]\ and\ \ p[j] != ‘.’$，那么$p[j]p[j+1]$必须只匹配0个，进而转到$p[j+2]$，与$s[i]$进行匹配，不然没法保证匹配； 如果$p[j] == s[i]\ \ or \ \ p[j] == ‘.’$，那么我们就要考虑到底要匹配几个。 123456789101112131415161718192021222324// 方法1，递归// 这个函数返回bool值，返回的是p&#123;0 , ... , j&#125;和s[0 , .... , i] 到底是否匹配。class Solution &#123;public: bool isMatch(string s, string p) &#123; return recursion(s , p , 0 , 0); &#125; bool recursion(const string &amp;s , const string &amp;p , int i , int j)&#123; int ls = s.size() , lp = p.size(); if(i == ls &amp;&amp; j == lp) return true; if(i != ls &amp;&amp; j == lp) return false; if(j+1 &lt; lp &amp;&amp; p[j+1] == '*')&#123; \\如果后面是* if(i &lt; ls &amp;&amp; (p[j] == '.' || p[j] == s[i]))&#123; return (recursion(s , p , i , j+2) || recursion(s , p , i+1 , j+2) || recursion(s , p , i+1 , j)); //分别对应0，1，多 &#125; else return recursion(s , p , i , j+2); //只能匹配0个 &#125; else if(i &lt; ls &amp;&amp; (p[j] == '.' || p[j] == s[i]))&#123; return recursion(s , p , i+1 , j+1); &#125; else return false; &#125;&#125;; 这是一种暴力的做法，会超时。 方法2我们可以发现，要判断$p[0 , … , j]$和$s[0 , … , i]$是否匹配，与二者的子串是否匹配有关。 我们设$dp[i][j]$表示$p[0 , … , j-1]$和$s[0 , … , i-1]$是否匹配，是一个bool型数组。 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isMatch(string s, string p) &#123; int lens = s.size() , lenp = p.size(); if(s.empty() &amp;&amp; p.empty()) return true; if(!s.empty() &amp;&amp; p.empty()) return false; vector&lt;vector&lt;bool&gt;&gt; dp(lens+1 , vector&lt;bool&gt;(lenp+1 , false)); //第一步：初始化，由于下标要进行减的操作，所以要把dp[0][0....lenp]和dp[0......lens][0]初始化 dp[0][0] = true; //一定是true，两个空串一定是匹配的 for(int i = 2 ; i&lt;=lenp ; ++i)&#123; //注意下标 if(p[i-1] == '*')&#123; dp[0][i] = dp[0][i-2]; //由于i = 0，所以相当于与s空串相匹配，此时只有是a*a*a*类似于这种格式的才能匹配，此时对应的是匹配0个。 &#125; &#125; for(int i = 1 ; i&lt;=lens ; ++i)&#123; //注意下标 for(int j = 1 ; j&lt;=lenp ; ++j)&#123; //注意下标 if(p[j-1] == s[i-1] || p[j-1] == '.') dp[i][j] = dp[i-1][j-1]; //如果没有*，那么直接匹配。 else if(j-1 &gt; 0 &amp;&amp; p[j-1] == '*')&#123; if(p[j-2] != s[i-1] &amp;&amp; p[j-2] != '.')&#123; \\如果有*但是只能匹配0个。 dp[i][j] = dp[i][j-2]; &#125; else dp[i][j] = (dp[i][j-2] || dp[i-1][j-2] || dp[i-1][j]); \\分别对应0，1，多 &#125; &#125; &#125; return dp[lens][lenp]; &#125;&#125;; 问题1：为什么匹配多个时看$dp[i-1][j]$？ $dp[i-1][j]$表示的是$p[0,…..,j-1]$和$s[0,…..,i-2]$是否匹配，而$dp[i][j]$表示的是$p[0,…..,j-1]$和$s[0,…..,i-1]$是否匹配，两者只差一个$s[i-1]$，此时我们已经判断出$p[j-1] == s[i-1]$。其实当$dp[i-1][j] == 1 \ and \ dp[i-1][j-1] == 0$的时候才是真正的多个。 问题2：为什么$dp[i-1][j-1]$不需要判断？ 我们可以发现：如果$dp[i-1][j-2]$成立，那么$dp[i-1][j]$一定成立，因为此时$dp[i-1][j]$可认为是在$dp[i-1][j-2]$的基础上匹配了0个，由真值表可知，通过判断$dp[i-1][j]$就可以判断出$dp[i-1][j] \ or \ dp[i-1[j-2]$的值。 523. 连续的子数组和—-前缀和+哈希表https://leetcode-cn.com/problems/continuous-subarray-sum/ 这道题和560. 和为K的子数组题有点相似，不同的是这道题要求数组大小至少为2，而且和是$k$的倍数，即和为$n*k$，其中$n$可以为0和负数。 我们可以这样想：如果存在$array[i…..j]$，使得$sum[i….j] == n*k$，那么有： sum[0....i-1] + n*k == sum[0....j]sum[0....j] + sum[0....i-1] == n*k我们令 $sum[0….i-1] == x_1k+y_1$，$sum[0….j] == x_2k+y_2$，且$0 &lt; y_1 &lt; k \ and \ 0 &lt; y_2 &lt; k$所以有： (x_1+n)k+y_1 == x_2k+y_2所以$y_1 == y_2$ 这样，我们就可以知道：当存在$i-1 &lt; j-1$，其$sum \div k$相等，那么就找到了解。 1234567891011121314151617181920212223class Solution &#123;public: bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; if(nums.empty()) return false; int len = nums.size(); int sum = 0; unordered_map&lt;int , int&gt; mp; mp[0] = -1; //初始化很重要，这样做是处理特例比如：[0,0,1,0]，其中k=0 for(int i = 0 ; i&lt;len ; ++i)&#123; sum += nums[i]; if(k)&#123; sum %= k; &#125; if(mp.count(sum))&#123; if(i - mp[sum] &gt; 1)&#123; //要保证数组长度大于2 return true; &#125; &#125; else mp[sum] = i; //哈希表的值必须是下标，方便比较数组长度 &#125; return false; &#125;&#125;; 1012. 至少有 1 位重复的数字——数位dphttps://leetcode-cn.com/problems/numbers-with-repeated-digits/ 这道题求至少有1位重复数字的正整数的个数，但是至少很难搞，所以我们转化成求没有重复数字的正整数个数。 所以，我们找到了筛选目标： 没有重复数字 注意前导零，比如0010看做10 数位dp需要我们搞清楚每一位的状态。这道题每一位的状态很显然是其前几位的数字的排列组合。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int a[20]; int dp[20][1 &lt;&lt; 10]; //初始状态下，每一位的前几位的数字都是0 int numDupDigitsAtMostN(int N) &#123; memset(dp , -1 , sizeof(dp)); return N - solve(N) + 1; &#125; int dfs(int pos , int sta , bool limit)&#123; if(pos == -1) return 1; //如果所有位遍历完成，那么证明这个数是符合条件的 if(!limit &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; //读取记忆，如果没有限制而且相同位数，而且其前几位的排列组合是一样的，那么就不需要再算了 int up = limit ? a[pos] : 9; int sum = 0; for(int i = 0 ; i&lt;=up ; ++i)&#123; if((sta &gt;&gt; i) &amp; 1) continue; //如果这个数的前几位中已经有了i，那么说明重复了 if(i == 0 &amp;&amp; sta == 0) sum += dfs(pos-1 , sta , limit &amp;&amp; (i == a[pos])); //处理前导0，如果一直是前导0，那么这个数的前几位中不能算有0 else sum += dfs(pos-1 , sta | (1 &lt;&lt; i) , limit &amp;&amp; (i == a[pos])); //将此位的数字包括进去 &#125; //储存 if(!limit) dp[pos][sta] = sum; return sum; &#125; int solve(int x)&#123; int pos = 0; while(x)&#123; a[pos++] = x%10; x /= 10; &#125; return dfs(pos-1 , 0 , true); &#125;&#125;; 本题数位dp在哪里进行了剪枝？答案就在记忆化中，我们考虑每一位的状态是考虑本位的前几位的数字的排列组合，比如12_ _ 和21_ _，我们在虽然两个数不同，但是第三位的状态是相同的，都是$dp[2][(0000000110)_2]$(我的位数是从0开始的)，即同一组数的不同排列组合是一种状态， 那么我们在算21··时直接记忆化就行了。 53. 最大子序和https://leetcode-cn.com/problems/maximum-subarray/ 方法1：简单dp 求以每个数为右端点的最大子数组和 123456789101112131415class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; dp(len , 0); int Max = nums[0]; for(int i = 1 ; i&lt;len ; ++i)&#123; if(nums[i-1] &gt; 0)&#123; nums[i] += nums[i-1]; &#125; Max = max(Max , nums[i]); &#125; return Max; &#125;&#125;; 方法2：分治 让我想起了归并排序，也是分治思想。就是一个数组$[l,r]$可分为$[l,m]$和$[m+1,r]$这两个子区间，其中$m = (l+r)/2$，$[l,r]$中的最大子数组的和就可以通过$[l,m]$和$[m+1,r]$来求，直到$l == r$时，即每个子区间只有一个元素是，表示递归到了最深处。 那么，如何通过两个子区间来求$[l,m]$的最大值呢？ 我们先设出变量： $msum$表示区间的最大子数组和 $lsum$表示区间中以区间左端点为子数组左端点的子数组的最大和 $rsum$表示区间中以区间右端点为子数组右端点的子数组的最大和 $isum$表示区间的所有元素的和 我们可以这样想，由于题目要求是连续的数组和，所以区间的$msum$要么在左区间内，要么在右区间内，要么一半在左区间，一半在右区间，前两种好说，即$msum = max(l_msum , r_msum)$，最后一种就需要变量$lsum$和$rsum$了，即左边一半是$l_rsum$，右边一半是$r_lsum$。 再说说$lsum$和$rsum$怎么维护。以$lsum$为例：有两种情况： 如果$l_lsum$没有覆盖所有的左区间，那么只能是$lsum == l_lsum$ 如果$l_lsum$覆盖了所有的左区间，即$l_lsum == l_isum$那么就要考虑右区间了，考虑到连续性，我们只能考虑$r_lsum$，所以$lsum == max(l_lsum , l_lsum + r_lsum)$ 最后$isum == l_isum + r_isum$ 1234567891011121314151617181920212223class Solution &#123;public: struct Status &#123; int lsum , rsum , msum , isum; &#125;; Status pushUp(Status l , Status r)&#123; //维护各个变量 int lsum = max(l.lsum , (l.isum + r.lsum)); int rsum = max(r.rsum , (r.isum + l.rsum)); int msum = max(l.rsum + r.lsum , max(l.msum , r.msum)); int isum = l.isum + r.isum; return (Status)&#123;lsum , rsum , msum , isum&#125;; &#125; Status get(vector&lt;int&gt; &amp;a , int l , int r)&#123; if(l == r) return (Status)&#123;a[l] , a[l] , a[l] , a[l]&#125;; //终止条件：只有一个元素时 int m = (l + r) / 2; Status lsub = get(a , l , m); //左区间 Status rsub = get(a , m+1 , r); //右区间 return pushUp(lsub , rsub); //区间合并 &#125; int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; return get(nums , 0 , nums.size() - 1).msum; &#125;&#125;; 546. 移除盒子https://leetcode-cn.com/problems/remove-boxes/ 是真的难，毫无思路。 方法：区间dp设$dp[i][j][k]$。其中$k$表示区间$[i,j]$的前面有$k$个箱子的颜色和第$j$个箱子的颜色相同。$dp$的值表示区间$[i,j+k]$个箱子最大能获得的分数。 我们用一个例子来说明： 我们考虑下面一堆箱子：一开始是$dp[0][8][0]$ 但是我们发现：上图的$dp[0][8][0] == dp[0][7][1]$ 所以我们的第一步就是移动$R$指针，使得$K$最大。到这里，我们就有了选择： 要么把最后的两个2和前面的若干个2排在一起，即把4，5，6这些1去掉 要么干脆不排2了，直接去掉最后两个2 第一种情况：我们把$L$和$R$中间的1去掉，得到$dp[0][3][2] + dp[4][6][0]$ 第二种情况：去掉最后两个2，得到$dp[0][6][0] + 2*2$ 然后一直dfs递归。 思路：其实当我们遇到图2的情况时，我们只能有两种选择，一种是直接去掉，一种是和后面的若干个与它相同颜色的箱子排在一起 12345678910111213141516171819202122232425class Solution &#123;public: int nums[101][101][101]; int removeBoxes(vector&lt;int&gt;&amp; boxes) &#123; int len = boxes.size(); memset(nums , 0 , sizeof(nums)); return dfs(boxes , 0 , len-1 , 0); &#125; int dfs(vector&lt;int&gt; &amp;boxes , int l , int r , int k)&#123; if(l &gt; r) return 0; while(l &lt; r &amp;&amp; boxes[r] == boxes[r-1])&#123; --r; ++k; &#125; //读取记忆，得到剪枝 if(nums[l][r][k] &gt; 0) return nums[l][r][k]; nums[l][r][k] = dfs(boxes , l , r-1 , 0) + (k+1) * (k+1); //情况2 for(int i = l ; i &lt; r ; ++i)&#123; //情况1 if(boxes[i] == boxes[r])&#123; nums[l][r][k] = max(nums[l][r][k] , dfs(boxes , i+1 , r-1 , 0) + dfs(boxes , l , i , k+1)); &#125; &#125; return nums[l][r][k]; &#125;&#125;; 疑问：代码中情况1中为什么得到一个$boxes[i] == boxes[r]$就进行递归，而不是找到最大的$i$后进行一次递归？当时有这个疑问的原因是假设一个序列：1 1 2 2 1 1 1 2 2，为什么$i$在2的位置就递归而不是在3的位置递归，虽然情况1是用for循环来解决这一问题，但是这不是多此一举吗？ 1234567//疑问代码：for(int i = l ; i &lt; r ; ++i)&#123; if(boxes[i] == boxes[r] &amp;&amp; (boxes[i+1] != boxes[r] || i == r-1))&#123; nums[l][r][k] = max(nums[l][r][k] , dfs(boxes , i+1 , r-1 , 0) + dfs(boxes , l , i , k+1)); break; &#125;&#125; 但是如果看序列：3 2 2 2 3 4 3，就会发现，如果我们想得到3 3 3，那么用上面的代码$i$在0的位置就递归然后break了，这就是错的，然而我们如果一直往后找当$i == 3$时，就会得到3 3 3，所以正确修改的代码：123456//上面的代码将break去掉（虽然最后没快多少）for(int i = l ; i &lt; r ; ++i)&#123; if(boxes[i] == boxes[r] &amp;&amp; (boxes[i+1] != boxes[r] || i == r-1))&#123; nums[l][r][k] = max(nums[l][r][k] , dfs(boxes , i+1 , r-1 , 0) + dfs(boxes , l , i , k+1)); &#125;&#125; 576. 出界的路径数https://leetcode-cn.com/problems/out-of-boundary-paths/ 方法1：dfs+记忆化这个没什么好说的，常规思路 1234567891011121314151617181920212223class Solution &#123;public: unsigned long long dp[55][55][55]; int height , width; int Max_step; unsigned long long INF = 1e9+7; int findPaths(int m, int n, int N, int i, int j) &#123; memset(dp , 0 , sizeof(dp)); height = m , width = n , Max_step = N; return dfs(i , j , N); &#125; unsigned long long dfs(int i , int j , int N)&#123; if(N &lt; 0) return 0; if(N &lt; i+1 &amp;&amp; N &lt; j+1 &amp;&amp; N &lt; width - j &amp;&amp; N &lt; height - i) return 0; //一定要判断一下，不然会超时 if(i &lt; 0 || j &lt; 0 || i == height || j == width)&#123; return 1; &#125; if(dp[i][j][N]) return dp[i][j][N]; //读取记忆 if(N == 0) return 0; dp[i][j][N] = (dfs(i-1 , j , N-1) + dfs(i , j-1 , N-1) + dfs(i+1 , j , N-1) + dfs(i , j+1 , N-1)) % INF; return dp[i][j][N]; &#125;&#125;; 方法2：dp我们定义$dp[k][i][j]$为在$[i,j]$处只剩下$k$步时最大可以出界的个数。 因为球是可以往回走的，所以在一个坐标处的$k$可以是$[0,1…..N]$，其中0的时候可以不考虑。那么我们在坐标$[i,j]$处最多可以出界的个数就是： \sum_{k=1}^Ndp[i][j][k]1234567891011121314151617181920212223242526class Solution &#123;public: unsigned long long dp[55][55][55]; int INF = 1e9+7; int findPaths(int m, int n, int N, int i, int j) &#123; memset(dp , 0 , sizeof(dp)); unsigned long long sum = 0; for(int i = 0 ; i&lt;=m+1 ; ++i)&#123; for(int j = 0 ; j&lt;=n+1 ; ++j)&#123; if(i == 0 || j == 0 || i == m || j == n)&#123; dp[0][i][j] = 1; //已经出界而且是0步时是1，可以避免重复 &#125; &#125; &#125; for(int k = 1 ; k&lt;=N ; ++k)&#123; for(int i = 1 ; i&lt;=m ; ++i)&#123; for(int j = 1 ; j&lt;=n ; ++j)&#123; dp[k][i][j] = (dp[k-1][i-1][j] + dp[k-1][i+1][j] + dp[k-1][i][j-1] + dp[k-1][i][j+1])%INF; &#125; &#125; sum += dp[k][i+1][j+1]; sum %= INF; &#125; return sum; &#125;&#125;; 疑问：为什么只在’已经出界而且是0步时是1’，k!=0时出界就不算了？12345678910//疑问代码：修改初始化for(int k = 0 ; k&lt;=N ; ++k)&#123; for(int i = 0 ; i&lt;=m+1 ; ++i)&#123; for(int j = 0 ; j&lt;=n+1 ; ++j)&#123; if(i == 0 || j == 0 || i == m+1 || j == n+1)&#123; dp[k][i][j] = 1; &#125; &#125; &#125;&#125; 上面的代码是错误的，原因是造成了重复，我们其实只算的是坐标$[i,j]$在$k=0$时恰好走到了边界的个数的路径，即如果一个坐标$[i,j]$在某一边界有步数$K == k$时就能走出去，那么对于所有的$step &gt; k$都能从这个边界沿着相同的路径走出去。所以我们算的是在$N$步内能走出界的路径数，不一定一个路径要走完$N$步。 1049.最后一块石头的重量2https://leetcode-cn.com/problems/last-stone-weight-ii/ 这道题求返回石头的最小重量，也就是说，两个相撞的石头$x$和$y$重量越接近越好。那么我们就可以将问题转化为将一堆石头分为两堆，这两堆石头的重量越接近越好，即尽可能地接近这堆石头总重量的一半。 那么我们可以想到用0-1背包问题来求解，即一堆石头装入容量为$sum/2$的背包，求背包最大能装多少，这里的$value$和$weight$是相同的。 123456789101112131415161718class Solution &#123;public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123; int len = stones.size(); int sum = 0; for(auto i : stones)&#123; sum += i; &#125; int target = sum / 2; //求重量较小的那堆 vector&lt;int&gt; dp(target + 1 , 0); for(int i = 0 ; i&lt;len ; ++i)&#123; for(int j = target ; j &gt;= stones[i] ; --j)&#123; dp[j] = max(dp[j] , dp[j - stones[i]] + stones[i]); &#125; &#125; return sum - 2 * dp[target]; &#125;&#125;; 1039. 多边形三角剖分的最低得分https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/ 方法一：dfs+记忆化我们设$dp[i][j]$表示区间$[i,j]$内能得到的最低分 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int dp[51][51]; int Max = -1; int minScoreTriangulation(vector&lt;int&gt;&amp; A) &#123; memset(dp , 0 , sizeof(dp)); return dfs(A , 0 , A.size() - 1); &#125; int dfs(vector&lt;int&gt; &amp;A , int l , int r)&#123; if(dp[l][r]) return dp[l][r]; if(r - l == 2)&#123; dp[l][r] = A[l] * A[l+1] * A[r]; return dp[l][r]; &#125; int sum = INT_MAX; for(int k = l+1 ; k&lt;r ; ++k)&#123; int ans = 0; if(k == l+1)&#123; dp[l][k] = A[l] * A[r] * A[k]; ans += dp[l][k]; &#125; else ans += dfs(A , l , k); if(k == r-1)&#123; dp[k][r] = A[k] * A[r] * A[l]; ans += dp[k][r]; &#125; else ans += dfs(A , k , r); if(k == l+1 || k == r-1)&#123; sum = min(sum , ans); &#125; else sum = min(sum , ans + A[k] * A[r] * A[l]); &#125; dp[l][r] = sum; return dp[l][r]; &#125;&#125;; 方法二：区间dp1234567891011121314151617181920class Solution &#123;public: int dp[51][51]; int Max = -1; int minScoreTriangulation(vector&lt;int&gt;&amp; A) &#123; memset(dp , 0 , sizeof(dp)); int n = A.size(); for(int i = n-3 ; i&gt;=0 ; --i)&#123; //逆序遍历，因为k &gt; i，所以dp[i][k]要先求出来 for(int j = i+2 ; j&lt;n ; ++j)&#123; for(int k = i+1 ; k&lt;j ; ++k)&#123; if(dp[i][j])&#123; dp[i][j] = min(dp[i][j] , dp[i][k] + dp[k][j] + A[i] * A[j] * A[k]); &#125; else dp[i][j] = A[i] * A[j] * A[k] + dp[i][k] + dp[k][j]; &#125; &#125; &#125; return dp[0][n-1]; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2020%2F05%2F05%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1010. 总持续时间可被 60 整除的歌曲https://leetcode-cn.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/题目让求所有满足i&lt;j 的$(time[i] + time[j])\div 60 == 0$的组数。 我们设 \begin{cases} x+y=60n \\[1ex] x_1 = x/60\\[1ex] x_1 = x/60\\[1ex] x_2 = x\div60\\[1ex] y_1 = y/60\\[1ex] y_2 = y\div60\\[1ex] \end{cases}那么式（1）就可以写成： 60x_1+x_2+60y_1+y_2 = 60n \tag {2}所以所有满足式$（2）$的$x$和$y$都是满足题意的。同时，我们还发现$x_2+y_2 == 60$，所以，我们可以把数组中每个数都对60取余，存在哈希表里，哈希表的值代表数组中余数是此值的个数。 同时，我们还得避免重复计算，这要对$x_2$和$y_2$的大小关系进行讨论： \begin{cases} if\ (x_2 == y_2),& sum += \frac{num(num-1)}{2}\\[3ex] if\ (x_2 < y_2),& sum += num_x*num_y\\[3ex] if\ (x_2 == 0 \ ||\ y_2 == 0),& sum += \frac{num(num-1)}{2}\\ \end{cases}时间复杂度为$O(n)$。12345678910111213141516171819202122class Solution &#123;public: int numPairsDivisibleBy60(vector&lt;int&gt;&amp; time) &#123; int sum = 0; unordered_map&lt;int , int&gt; book; \\哈希表 for(int i = 0 ; i&lt;time.size() ; ++i)&#123; book[time[i]%60]++; &#125; for(auto it = book.begin() ; it != book.end() ; ++it)&#123; if(it-&gt;first &lt;= 30)&#123; if(it-&gt;first == 30 || it-&gt;first == 0)&#123; sum += it-&gt;second * (it-&gt;second - 1)/2; &#125; else if(book.count(60 - it-&gt;first))&#123; sum += it-&gt;second * (book[60 - it-&gt;first]); &#125; &#125; &#125; return sum; &#125;&#125;; 1011. 在 D 天内送达包裹的能力https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/ 题目要求在$D$天内将传送带上的所有包裹送达的船的最低运载能力，我们设$q$为运载能力，所以$Max\leq q \leq sum$，其中$Max$为最大的货物重量，$sum$为总的货物重量，我们的目的就是在这个范围里找到一个$q$，所以可以想到用二分查找法，对于每一次的$mid$,我们可以求出一个$day$, 其中$day$为当$(q == mid)$时，将传送带上的所有包裹送达的船的天数。 \begin{cases} 如果\ day \leq D,& 说明是符合题意的，但是q可能还是偏大\\ 如果\ day \gt D,& 说明q偏小了 \end{cases} 为什么不选取$day == D$时的q呢，原因是当数组的长度小于$D$时，我们找不到这样的$q$。 为什么$day == D$时，$q$还是可能偏小呢，原因是缩小$q$时可能还能满足$day == D$。 如何确保找到了最小的$q$呢，$day \gt D$不用多说，这种情况是不满足题意的。当$day \leq D$时，我们舍去了比$q$大的值。所以我们舍去的一定不影响求最小值。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int shipWithinDays(vector&lt;int&gt;&amp; weights, int D) &#123; int sum = 0; int Max = -1; for(int i = 0 ; i&lt;weights.size() ; ++i)&#123; sum += weights[i]; if(Max &lt; weights[i])&#123; Max = weights[i]; &#125; &#125; int left = Max , right = sum; int Min = INT_MAX; while(left &lt;= right)&#123; int mid = (right + left)/2; int temp = 0; int day = 0; for(int i = 0 ; i&lt;weights.size() ; ++i)&#123; temp += weights[i]; if(temp &gt; mid)&#123; temp = weights[i]; day++; &#125; &#125; day++; \\一定要注意 if(day &gt; D)&#123; left = mid + 1; &#125; else if(day &lt;= D)&#123; right = mid - 1; if(Min &gt; mid) Min = mid; &#125; &#125; return Min; &#125;&#125;; 4. 寻找两个有序数组的中位数总结见 https://lzclzclzc12.github.io/2020/04/18/leetcode%E4%B8%8D%E4%BC%9A%E7%9A%84%E9%A2%98/ 1014. 最佳观光组合https://leetcode-cn.com/problems/best-sightseeing-pair/ 题目要求$\max_{}(A[i] + A[j] + i - j)$，乍一看是找$i$和$j$的关系，但是由于数组是无序的，而且如果要保证最大值，那么$A[i] + A[j]$越大越好，但是$i-j$却是越小越好，所以很难找到两者之间的关系。我们可以把式子变形： \max_{}(A[i] + i + A[j] - j)这样我们就能不考虑两者之间的距离了，而是只考虑值的大小，相当于两者独立了。只要保证$i \lt j$，我们就可以$i$为慢指针，$j$为快指针，将数组遍历完后，求得最大值。1234567891011class Solution &#123;public: int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123; int left = A[0] , sum = 0; for(int i = 1 ; i&lt;A.size() ; ++i)&#123; sum = max(sum , left + A[i] - i); left = max(left , A[i] + i); &#125; return sum; &#125;&#125;; 代码如何保证$i \lt j$呢，我们先执行$sum$操作，此时$left$的状态还是$i$的状态，这样就能保证$i \lt j$了。 如何保证求的是最大值呢，在遍历每个$A[j]$时，我们$left$都取最大值，这是毫无疑问的，我们$sum$更新原则就是$sum_j = \max_{}(\max_{i \lt j}(A[i]+i) + A[j] - j)$，这样$\max(sum_j)$就是解。 1277. 统计全为 1 的正方形子矩阵https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/ 这道题用dp思想。 下面是官方题解图： 我们用 $dp[i][j]$ 表示以$(i,j)$点为右下角的正方形的最大个数，由图可知，若已知 $dp[i][j]$ ，那么: \min_{}(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) \geq dp[i][j]-1 \tag {1}其实上式要表达的就是三个点的最大正方形个数都比$dp[i][j]-1$大。 我们在来看下面这张图： 我们可以发现，$dp[i][j] \leq \min_{}(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1$，所以可以推出： dp[i][j] == \min_{}(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1所以递推公式就有了。1234567891011121314151617181920class Solution &#123;public: int countSquares(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int sum = 0; int n = matrix.size() , m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n , vector&lt;int&gt;(m , 0)); for(int i = 0 ; i&lt;n ; ++i)&#123; for(int j = 0 ; j&lt;m ; ++j)&#123; if(!i || !j)&#123; \\注意边界值 dp[i][j] = matrix[i][j]; &#125; else if(matrix[i][j])&#123; dp[i][j] = min(min(dp[i-1][j] , dp[i][j-1]) , dp[i-1][j-1])+1; &#125; sum += dp[i][j]; &#125; &#125; return sum; &#125;&#125;; 为什么要选右下角呢，原因是我们遍历数组是从左上角开始的，由递推公式可知，要知道$dp[i][j]$，我们必须要先求出$dp[i-1][j] , dp[i][j-1]) , dp[i-1][j-1]$，这样的次序和遍历的次序一致，所以才能保证正确性。 面试题 01.07. 旋转矩阵https://leetcode-cn.com/problems/rotate-matrix-lcci/ 我们可以看出，一个数顺时针旋转90°: Matrix_{after}[j][n-i-1] = Matrix_{before}[i][j]我们知道一个数旋转360°一定可以回到原地，所以我们可以继续推： \begin{cases} Matrix_{after}[j][n-i-1] = Matrix_{before}[i][j]\\[2ex] Matrix_{after}[n-i-1][n-j-1] = Matrix_{before}[j][n-i-1]\\[2ex] Matrix_{after}[n-j-1][i] = Matrix_{before}[n-i-1][n-j-1]\\[2ex] Matrix_{after}[i][j] = Matrix_{before}[n-j-1][i] \end{cases}为了防止覆盖，我们可以把被覆盖的值保存起来。上面讨论的是一个数的旋转，一个数旋转代表4个数旋转完成，要想把方阵旋转完成，我们可以把方阵分割成四部分，其中某一部分的旋转代表4个部分一起旋转。 对于边长是偶数的方阵来说，每一部分是边长为$n/2$的方阵 对于边长是奇数的方阵来说，每一部分可以是$\frac{n}{2} * \frac{n+1}{2}$ 的矩阵123456789101112131415class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); for(int i = 0 ; i&lt;n/2 ; ++i)&#123; for(int j = 0 ; j&lt;(n+1)/2 ; ++j)&#123; int temp = matrix[i][j]; matrix[i][j] = matrix[n-j-1][i]; matrix[n-j-1][i] = matrix[n-i-1][n-j-1]; matrix[n-i-1][n-j-1] = matrix[j][n-i-1]; matrix[j][n-i-1] = temp; &#125; &#125; &#125;&#125;; 1031. 两个非重叠子数组的最大和——-前缀和+dphttps://leetcode-cn.com/problems/maximum-sum-of-two-non-overlapping-subarrays/ 这道题要求两个不重叠的连续子数组的和的最大值，看了别人的思路才反应过来，这是其实是1014. 最佳观光组合的变式。我们可以写出目标公式： max_{}(数组L+数组M)由于数组$L$和数组$M$的位置关系不确定，所以我们可以分类讨论： 我们可以先假定数组$M$在数组$L$之前，那么我们可以遍历所有的数组$M$，每次都用在数组$M$之前的$max_{}(数组L)$，这样可以保证这个位置的和最大，然后逐一比较； 然后在假定数组$L$在数组$M$之前，一样的做法。 那么，我们怎么每次都用$max_{}(数组L)$呢？ &nbsp;&nbsp;&nbsp;&nbsp;我们在遍历$数组M$的时候同时也遍历了$数组M$之前的所有$数组L$，这样我们每次都更新$数组L$的最大值，那么就可以求出特定$数组M$特定位置的最大值。 由于每次都要求出特定区间的数的总和，所以我们用前缀和的思想，这样，我们直接用下标的加减法就可以求出区间的总和了。 1234567891011121314151617181920class Solution &#123;public: int maxSumTwoNoOverlap(vector&lt;int&gt;&amp; A, int L, int M) &#123; int len = A.size(); int sum = 0; for(int i = 1 ; i&lt;len ; ++i)&#123; A[i] += A[i-1]; //前缀和数组 &#125; for(int h = 0 ; h&lt;2 ; ++h)&#123; int left_max = A[L - 1]; sum = max(sum , left_max + A[L-1+M] - A[L-1]); for(int i = L ; i+M &lt;= len-1 ; ++i)&#123; left_max = max(left_max , A[i] - A[i - L]); sum = max(sum , left_max + A[i+M] - A[i]); &#125; swap(L , M); //分类讨论 &#125; return sum; &#125;&#125;; 31. 下一个排列https://leetcode-cn.com/problems/next-permutation/ 一开始不了解字典序的含义，后来查了才懂了。没啥好说的。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int i; for(i = len - 1 ; i&gt;=0 ; --i)&#123; if(i &gt;= 1 &amp;&amp; nums[i] &gt; nums[i-1])&#123; break; &#125; &#125; if(i == -1)&#123; i = 0; int j = len - 1; while(i &lt; j)&#123; swap(nums[i++] , nums[j--]); &#125; return; &#125; int j; for(j = i ; j &lt; len ; ++j)&#123; if(j &lt; len &amp;&amp; nums[j] &lt;= nums[i-1])&#123; swap(nums[j-1] , nums[i-1]); break; &#125; &#125; if(j == len)&#123; swap(nums[len - 1] , nums[i-1]); &#125; int j1 = len - 1; while(i &lt; j1)&#123; swap(nums[i++] , nums[j1--]); &#125; &#125;&#125;; 面试题 08.04. 幂集https://leetcode-cn.com/problems/power-set-lcci/ 这道题一看就是递归回溯。 代码1：dfs把这些子集看成一颗树 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; v; unordered_map&lt;int , int&gt; book; vector&lt;int&gt; v1; for(int i = 0 ; i&lt;nums.size() ; ++i)&#123; book[nums[i]]++; &#125; func(v , nums , book , v1 , 0); return v; &#125; void func(vector&lt;vector&lt;int&gt;&gt; &amp;v , const vector&lt;int&gt; &amp;nums , unordered_map&lt;int , int&gt; book , vector&lt;int&gt; v1 , int i)&#123; for(i ; i&lt;nums.size() ; ++i)&#123; if(book[nums[i]])&#123; v1.push_back(nums[i]); book[nums[i]]--; func(v , nums , book , v1 , i+1); v1.pop_back(); //出来后回溯 book[nums[i]]++; &#125; &#125; v.push_back(v1); //循环完一次后再加 &#125;&#125;; 代码2：状态树的思想其实也是dfs 一个数有两个状态：一个是取，一个数不取，那么就相当于是个颗二叉树，每个节点都是一个数的状态。这种方法不用哈希表标记。 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; v; vector&lt;int&gt; v1; func(v , nums , v1 , 0); return v; &#125; void func(vector&lt;vector&lt;int&gt;&gt; &amp;v , const vector&lt;int&gt; &amp;nums , vector&lt;int&gt; v1 , int i)&#123; if(i == nums.size()) &#123; v.push_back(v1); //遍历完最后一个数的时候，一个子集生成 return; &#125; v1.push_back(nums[i]); func(v , nums , v1 , i+1); //取这个数 v1.pop_back(); func(v , nums , v1 , i+1); //不取这个数 &#125;&#125;; 560. 和为K的子数组——-前缀和+哈希表https://leetcode-cn.com/problems/subarray-sum-equals-k/ 这道题要求找的是连续子数组，其和是$k$，我们可以这样想，如果有一个连续子数组$array[i….j]$，其和是$k$，那么$sum[j] - sum[i-1] == k$，其中$sum[j]$表示从$array[0]+…..+array[j]$。如果我们采用双指针$i$和$j$来暴力求解的话会超时，我们可以采用哈希表的思想：我们只移动$j$这一指针，如果$sum[j] - k == sum[i-1]$，即存在$i-1 \lt j$，使得等式成立，每次遍历时，我们记录$sum[j]$到哈希表中，哈希表的每一个值代表有多少个$i-1$使得等式成立。 1234567891011121314151617class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); if(!len) return 0; int sum = 0; unordered_map&lt;int , int&gt; mp; mp[0] = 1; //一定注意哈希表的初始化，如果不初始化，那么比如3,4,7就会丢掉3,4 int num = 0; for(int i = 0 ; i&lt;len ; ++i)&#123; num += nums[i]; //求sum[j] if(mp.count(num - k)) sum += mp[num - k]; //如果i-1存在 mp[num]++; &#125; return sum; &#125;&#125;; 40. 组合总和 IIhttps://leetcode-cn.com/problems/combination-sum-ii/ 这道题坑就坑在解集中不能有重复的组合，比如[2,5,2,1,2]，如果只是dfs的话，会出现重复的情况，我们来想想单纯dfs出现重复的原因： 如果，由于相同的2是兄弟节点，导致dfs时进行了重复操作，由于我们对数组进行了排序，所以值相同的节点的位置是相邻的，所以表现在树中就是： 如果一个节点$j$，有$array[j] == array[j-1]$，而此时的树根不是$j-1$，那么就是重复的。 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; v; if(candidates.empty()) return v; sort(candidates.begin() , candidates.end()); vector&lt;int&gt; v1; dfs(candidates , v , v1 , target , -1 , 0 , -1); return v; &#125; void dfs(const vector&lt;int&gt; &amp;candidates , vector&lt;vector&lt;int&gt;&gt; &amp;v , vector&lt;int&gt; &amp;v1 , int target , int i , int sum , int index)&#123; if(sum == target)&#123; v.push_back(v1); return; &#125; for(int j = i+1 ; j &lt; candidates.size() &amp;&amp; sum &lt; target ; ++j)&#123; if(j &amp;&amp; candidates[j-1] == candidates[j] &amp;&amp; index != j-1)&#123; continue; &#125; v1.push_back(candidates[j]); dfs(candidates , v , v1 , target , j , sum + candidates[j] , j); //由于dfs每次都是进入下一层，所以树根是j。 v1.pop_back(); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode不会的题]]></title>
    <url>%2F2020%2F04%2F18%2Fleetcode%E4%B8%8D%E4%BC%9A%E7%9A%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[11. 盛最多水的容器-双指针的应用这道题用两个for然后剪枝可以通过，但是思路不行。https://leetcode-cn.com/problems/container-with-most-water/ 可以使用双指针来解答12345678910111213class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int Max_capacity = -1; int left = 0 , right = height.size()-1; while(left != right)&#123; int capacity = min(height[left] , height[right]) * (right - left); if(Max_capacity &lt; capacity) Max_capacity = capacity; height[left] &lt; height[right] ? (++left) : (--right); &#125; return Max_capacity; &#125;&#125;; 正确性证明： capacity = min(h[left] , h[right]) * (right - left)，我们假设h[left] &lt; h[right]，如果我们向左移动right，那么capacity只会减小，这样没法找到最大值，而向右移动left，capacity可能增大也可能减小。 一开始left和right分别指向容器的最左端和最右端，如果用暴力来求的话，[left , right]范围内一定可以找到Max_capacity，还是假设h[left] &lt; h[right]，left++相当于减少了(left , right-1)、(left , right-2)……这些值都&lt;(left , right)，所以我们每一步所丢失的解都不会影响当前解空间内的最大值（要么是min(h[left] , h[right]) * (right - left)，要么在[left-1 , right]的解空间内）。 1. 两数之和这道题用暴力也可以过，但是这显然不是好的方法。 https://leetcode-cn.com/problems/two-sum/ multimap+双指针首先我们使用multimap记录数据的index，因为map是排好序的，所以我们可以用双指针来缩小查找范围。1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; multimap&lt;int , int&gt; mp; for(int i = 0 ; i&lt;nums.size() ; ++i)&#123; mp.insert(pair&lt;int , int&gt;(nums[i] , i)); &#125; auto left = mp.begin() , right = --mp.end(); while(left != right)&#123; if(left-&gt;first + right-&gt;first == target)&#123; return &#123;left-&gt;second , right-&gt;second&#125;; &#125; else if(left-&gt;first + right-&gt;first &lt; target)&#123; left++; &#125; else right--; &#125; return &#123;&#125;; &#125;&#125;; unordered_map（哈希表的应用）unordered_map的实现是基于哈希表，所以其查找很快，所以最终是无序的。由于这道题每个测试样例只有一个答案，所以用map虽然会覆盖重复元素，但是可以找到解。123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; m; for(int i=0;i&lt;nums.size();i++)&#123; m[nums[i]] = i; &#125; for(int i=0;i&lt;nums.size();i++) &#123; if(m.find(target-nums[i]) != m.end() &amp;&amp; m[target-nums[i]] != i)&#123; return &#123;i , m[target-nums[i]]&#125;; &#125; &#125; return &#123;&#125;; &#125;&#125;; 466. 统计重复个数-循环节（好难）https://leetcode-cn.com/problems/count-the-repetitions/ 我们可以把这道题转成：n1个s1中可以找出多少个s2(个数向下取整)，然后除以n2就是答案了，所以关键是求有多少个s2，但是n1可以很大，所以遍历n1个s1肯定不行。 再想，我们可以求出x个s1中有y个s2，其中x和y都是整数，但是这样不能保证y是整数，由于s1和s2是循环出现的，所以1个s2占多少s2都是固定的，所以很多情况下找不出这样的y。 有没有一种方法可以实现x个s1中有y个s2，其中x和y都是整数呢？我们可以这样想，如果此题有解，那么s1中必定包含s2中所有种类的元素，只不过顺序是不同的，比如说s1 = ‘abaacdbac’，s2 = ‘adcbda’，第一次只能有’abc’，第二次为’bda’。那么是否存在一个x，使得x个s1中找到s2的一段循环节，即从x开始遍历s2而不是从s2[0]开始遍历。我们考虑每次遍历s1时第一个s2元素，比如下图中的b,d,b,d，我们假设为x，那么x只能取s2中的任意一个元素，如果有两次x重复了，那么接下来的工作就和上一次一样了，因为相当于循环节和s1同步了，这样就找到了循环节了。 正确性证明 x一定会有重复，根据鸽巢原理，x的取值是有限的。 循环节里一定包含的是整数个s2，因为我们可以认为是从s2中x元素开始对应，经过几个s1的遍历后，又以x元素结束，此时一定是整数个s2 其实循环节就是换一种方式求出x个s1中有y个s2，其中x和y都是整数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int getMaxRepetitions(string s1, int n1, string s2, int n2) &#123; if(n1 == 0) return 0; int index = 0 , sum_s1 = 0 , sum_s2 = 0; //index表示当前对应的是s2中的第几个元素，sum_s1和sum_s2表示s1经过sum_s1次遍历后，所包含的完整的sum_s2个s2(此时可能还包含不完整的s2，向下取整) unordered_map&lt;int , pair&lt;int , int&gt; &gt; mp; pair&lt;int , int&gt; pre , in; while(1)&#123; ++sum_s1; for(auto ch : s1)&#123; if(ch == s2[index])&#123; ++index; if(index == s2.size())&#123; index = 0; sum_s2++; &#125; &#125; &#125; if(sum_s1 == n1)&#123; //未找到循环节 return sum_s2 / n2; &#125; if(mp.count(index))&#123; //找到了循环节 pre = mp[index]; int sum_s1_prime = pre.first; int sum_s2_prime = pre.second; in = &#123;sum_s1 - sum_s1_prime , sum_s2 - sum_s2_prime&#125;; //一个循环节中包含（sum_s1 - sum_s1_prime）个s1，包含(sum_s2 - sum_s2_prime)个s2 break; &#125; else &#123; mp[index] = &#123;sum_s1 , sum_s2&#125;; //用哈希表存 &#125; &#125; int sum = pre.second + (n1 - pre.first) / in.first * in.second; //循环节中s2的个数 + 一开始未进入循环节中s2的个数 int rest = (n1 - pre.first) % in.first; //不够一个循环节的s1个数 for(int i = 0 ; i&lt;rest ; ++i)&#123; for(auto ch : s1)&#123; if(ch == s2[index])&#123; index++; if(index == s2.size())&#123; sum++; index = 0; &#125; &#125; &#125; &#125; return sum / n2; &#125;&#125;; 4. 寻找两个有序数组的中位数-二分法https://leetcode-cn.com/problems/median-of-two-sorted-arrays/ 此题要求复杂度为o(log(n+m))，所以合并是o((n+m)/2)，不符合要求，要用二分法来查找。 一开始根本没想到用二分，看了官方题解才知道是这样的思路。 如图，我们可以考虑有一条分割线把A和B分开，使得： 如果n+m是奇数，那么left_part部分的总长度 = right_part部分的总长度+1； 如果n+m是偶数，那么left_part部分的总长度 = right_part部分的总长度； A[i-1] &lt;= B[j]，B[j-1] &lt;= A[i] 第三点如果成立了，那么说明left_part部分的所有数都小于right_part部分的所有数，而一二点保证了两边的数的个数相同，那么此时中位数不就找到了吗？ 如果n+m是奇数，由于left_part部分的总长度 = right_part部分的总长度+1，所以中位数一定是left_part中最大的数，即result = max{A[i-1] , B[j-1]}； 如果n+m是偶数，由于left_part部分的总长度 = right_part部分的总长度，所以一个数在left_part中，一个在right_part中，即result = (max{A[i-1] , B[j-1]} + min{A[i] + B[j]} )/2 当然，我们可以让i从0开始到n结束一个一个找，但是时间不允许，现在的问题是从[0 , n]中找到i，所以用二分法来找，用二分法就必须确定边界，即i的查找边界，我们可以把left_part部分的总长度设为k，由图可知，i+j = k（0&lt;=i&lt;=n），但是我们要保证0&lt;=j&lt;=m，所以我们就可以确定i的范围[max(0 , k-m) , min(n , k)]，有了范围后，还得确定二分法的内容： 如果A[i-1] &lt;= B[j]，B[j-1] &lt;= A[i]，那么就可以break了 如果A[i-1] &gt; B[j]，那么说明A[i-1]太大，需要减小i，所以right = mid - 1 如果B[j-1] &gt; A[i]，那么说明A[i]太小，需要增加i，所以left = mid + 1 最后要注意边界值的问题：j = 0时，j-1会是负数，j = m时，j是不合法的值，但是这样的情况是存在的，需要特殊处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int n = nums1.size(); int m = nums2.size(); if(n == 0)&#123; if(m%2) return nums2[m/2]; else &#123; return (double(nums2[m/2]) + double(nums2[m/2-1]))/2; &#125; &#125; if(m == 0)&#123; if(n%2) return nums1[n/2]; else &#123; return (double(nums1[n/2]) + double(nums1[n/2-1]))/2; &#125; &#125; int k; if((n + m) % 2)&#123; k = (n + m)/2 + 1; &#125; else &#123; k = (n + m)/2 ; &#125; int left = max(0 , k-m) , right = min(k , n); int result; int a , b , c , d; while(left &lt;= right)&#123; int mid = (left + right) / 2; int mid1 = k - mid; //特殊值的处理 if(mid-1 &gt;= 0)&#123; a = nums1[mid-1]; &#125; else a = min(nums1[0] , nums2[0]); if(mid1-1 &gt;=0)&#123; b = nums2[mid1-1]; &#125; else b = min(nums1[0] , nums2[0]); if(mid &lt; n)&#123; c = nums1[mid]; &#125; else c = max(nums1[n-1] , nums2[m-1]); if(mid1 &lt; m)&#123; d = nums2[mid1]; &#125; else d = max(nums1[n-1] , nums2[m-1]); if( a &lt;= d &amp;&amp; b &lt;= c)&#123; result = mid; break; &#125; else if(b &gt; c)&#123; left = mid + 1; &#125; else if(a &gt; d)&#123; right = mid - 1; &#125; &#125; if((n + m) % 2)&#123; return max(a , b); &#125; else &#123; return (double(max(a , b)) + double(min(c , d))) / 2.0; &#125; &#125;&#125;; 3. 无重复字符的最长子串-优化的滑动窗口https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 我们可以将一段没有重复字符的字符串想成一个滑动窗口，用哈希表记录上一次遇见字符的下标，如果此字符在滑动窗口中出现过，那么更新滑动窗口的开始位置。窗口的左端走的慢，右端走的快，窗口只能向前运动，不能向后运动。1234567891011121314151617class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; if(s.size() == 0) return 0; int Max_sum = -1 , sum = 0; unordered_map&lt;char , int&gt; mp; int i = 0 , j = 0; //i是左端，j是右端 for(j ; j&lt;s.size() ; ++j)&#123; if( !mp.count(s[j]) || mp[s[j]] &lt; i)&#123; //如果以前没有出现过 或者是 出现过但是当前窗口中没有此字符 Max_sum = max(Max_sum , j-i+1); &#125; else i = mp[s[j]] + 1; mp[s[j]] = j; &#125; return Max_sum; &#125;&#125;; 5. 最长回文子串https://leetcode-cn.com/problems/longest-palindromic-substring/ 解法1：动态规划动态规划的题不熟，几乎遇见动态规划就不会做了。。。 首先要说的是暴力法，就是遍历每个子串，然后判断是不是回文串，但是这样会有很大的字符串是没必要判断的，比如说’babac’，判断’babac’时，’aba’已经是回文串了，那么’babac’肯定不是回文串，而无需再用常规方法来判断其是否为回文串，即暴力法最大的问题在于判断是否为回文串的这一环节上浪费了时间。时间效率是O(n^3）。 动态规划法就解决了这一问题，我们设dp[j][i]表示从j到i的字符子串，那么dp[j][i]是回文串 &lt;=&gt; (dp[j+1][i-1] == 1 and s[j] == s[i])，即判断一个字符子串是否为回文串仅需判断他的子串是否为回文串。12345678910111213141516171819202122232425262728293031class Solution &#123;public: string longestPalindrome(string s) &#123; int len = s.size(); if(len &lt;= 1) return s; vector&lt;vector&lt;int&gt; &gt; dp(len , vector&lt;int&gt;(len , 0)); for(int i = 0 ; i&lt;len ; ++i)&#123; dp[i][i] = 1; //一个字符的子串一定是回文串 &#125; int start = 0 , sum = -1; //定义结果的开始字符index和子串的最大长度 for(int i = 1 ; i&lt;len ; ++i)&#123; for(int j = 0 ; j&lt;i ; ++j)&#123; if(s[j] == s[i])&#123; if(i == j+1)&#123; dp[j][i] = 1; &#125; else dp[j][i] = dp[j+1][i-1]; &#125; else dp[j][i] = 0; if(dp[j][i])&#123; if(sum &lt; i-j+1)&#123; sum = i-j+1; start = j; &#125; &#125; &#125; &#125; return s.substr(start , sum); &#125;&#125;;由双重for循环得知，遍历了所有的子串。效率是O(n^2)，虽然遍历了所有子串，但是在判断是否是回文串这一环节中提高了效率。 解法二：中心拓展法这一解法思想很简单，效率也比dp高一点。思路就是回文串是对称的，所以一定有中心点，中心点可以是一个字符，也可以是两个字符，一个字符的中心点有n个，两个字符的中心点有n-1个，所以一共有2n-1个中心点，然后在中心点的基础上左右两边同时进行拓展。1234567891011121314151617181920212223class Solution &#123;public: string longestPalindrome(string s) &#123; int len = s.size(); int start = 0 , Max_length = 1; for(int i = 0 ; i&lt;len ; ++i)&#123; int l1 = get_palindromic_substring(s , i , i); int l2 = get_palindromic_substring(s , i , i+1); if(Max_length &lt; max(l1 , l2))&#123; Max_length = max(l1 , l2); start = i - (Max_length - 1) / 2; &#125; &#125; return s.substr(start , Max_length); &#125; int get_palindromic_substring(string &amp;s , int left , int right)&#123; while(left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])&#123; --left; ++right; &#125; return right - left - 1; &#125;&#125;;注意代码中函数get_palindromic_substring中第一个参数使用了引用，这样使得在每次调用函数时，不用复制字符串。其实用const string &amp; 更好。时间效率是O(n^2)。]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看新闻学单词]]></title>
    <url>%2F2020%2F03%2F25%2F%E7%9C%8B%E6%96%B0%E9%97%BB%E5%AD%A6%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[1. Will the Olympics Go On? Japan’s Businesses Would Like to Knowhttps://cn.nytimes.com/business/20200319/japan-olympics-coronavirus/dual/leather&emsp;stage&emsp;drastic&emsp;simultaneous&emsp;brace&emsp;leftover incentive &emsp;gamble &emsp;course &emsp;outright &emsp;schedule &emsp;brink venue &emsp;mess &emsp;inn &emsp;on top of &emsp;collapse &emsp;sailing duration during durable &emsp;devastate devastating devastatingly wear worn //wear down &emsp;blow &emsp;mortgage &emsp;virtually &emsp;deputy contract &emsp;proof &emsp;relay &emsp;concede &emsp;diplomacy &emsp;sacrifice course &emsp;deter &emsp;wary &emsp;quarantine &emsp;diamond &emsp;princess anticipate &emsp;browse &emsp;shelf shelves &emsp;handful &emsp;branded merchandise merchant &emsp;break &emsp;lottery &emsp;trickle n/v 2. Another Virus Victim: The U.S. as a Global Leader in a Time of Crisishttps://cn.nytimes.com/usa/20200323/trump-leadership-coronavirus-united-states/dual/ pull out of &emsp; generous &emsp; coordinate &emsp; assume &emsp; gratitude &emsp; foe broad &emsp; reach &emsp; temper &emsp; confirm &emsp; rally &emsp; cope fend &emsp; consult &emsp; advance &emsp; accusation &emsp; monopoly &emsp; approach in terms of &emsp; harsh &emsp; respiratory &emsp; personnel &emsp; condemn &emsp; kit narrative &emsp; domestic &emsp; fragment &emsp; legislator &emsp; rhetoric &emsp; internal let alone &emsp; bloc &emsp; hasty &emsp; dismantle &emsp; negotiation &emsp; sophisticated mature &emsp; authority &emsp; retrospect &emsp; fundamental &emsp; shift &emsp; rebound parallel &emsp; unparalleled 3. What to Call 2021 Olympics? Just One of Many Challenges for Japanhttps://cn.nytimes.com/asia-pacific/20200326/japan-olympics-delay/dual/ relief &emsp; suspension &emsp; pose &emsp; flame &emsp; second &emsp; corporate estate &emsp; contract &emsp; hurdle &emsp; steer &emsp; response &emsp; cruise infinite &emsp; bruise &emsp; outright &emsp; farewell &emsp; convene &emsp; swing intensive &emsp; vast &emsp; vastly &emsp; drastically &emsp; disproportionate &emsp; with regard to longevity &emsp; evaporate &emsp; slump &emsp; cope &emsp; lease &emsp; facility &emsp; maintenance venue &emsp; liability &emsp; overwhelmingly &emsp; opinion &emsp; stage &emsp; refund narrative &emsp; pitch &emsp; avert &emsp; spectator &emsp; breed &emsp; relived 4. North Korea Claims No Coronavirus Cases. Can It Be Trusted?https://cn.nytimes.com/asia-pacific/20200401/north-korea-coronavirus/dual/ assess &emsp; invasion &emsp; novel &emsp; stagger &emsp; drastic &emsp; seal &emsp; account for clamp &emsp; clamp down on &emsp; smuggle &emsp; thrive &emsp; function &emsp; singular ravage &emsp; surge &emsp; literally &emsp; preserve &emsp; order &emsp; secretary &emsp; general contact &emsp; erupt &emsp; urgent &emsp; toll &emsp; panic &emsp; hoard &emsp; contrast tram &emsp; garment &emsp; clip &emsp; sliver &emsp; stick &emsp; stuck &emsp; ascribe ascribe sth to sth &emsp; hush &emsp; play down &emsp; rebellion &emsp; disaster &emsp; undermine faith &emsp; detain &emsp; prevent &emsp; devastate &emsp; mal- &emsp; missile &emsp; sanction given 5. C.I.A. Hunts for Authentic Virus Totals in China, Dismissing Government Tallieshttps://cn.nytimes.com/usa/20200403/cia-coronavirus-china/dual/ state &emsp; rely on/upon sb/sth &emsp; brief &emsp; asset &emsp; implication &emsp; critical &emsp; frustration extent &emsp; chronic &emsp; suppress &emsp; suppression &emsp; account for &emsp; leave out &emsp; lag assess &emsp; assessment &emsp; revelation &emsp; verify &emsp; caution &emsp; aggressive &emsp; credit drastic &emsp; contain &emsp; classified &emsp; statistics &emsp; conspiracy &emsp; retaliate &emsp; prominent 6. New Research Links Air Pollution to Higher Coronavirus Death Rateshttps://cn.nytimes.com/health/20200409/air-pollution-coronavirus-covid/dual/ county &emsp; reveal &emsp; overlap &emsp; fine &emsp; slight &emsp; adjacent &emsp; concentrate susceptible &emsp; tend &emsp; affluent &emsp; folk &emsp; regulation &emsp; roll back &emsp; on the grounds &emsp; premature &emsp; dean &emsp; consistent]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>学单词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求最大公约数和最小公倍数]]></title>
    <url>%2F2020%2F03%2F21%2F%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[求最大公约数可以用辗转相除法来求，基本思想：两个数的最大公约数等于两个数中较小的数与两数余数的最大公约数。1234567891011121314151617181920212223242526//n不能 = 0int gcd(int m,int n)&#123; int t = 1; while(t != 0) &#123; t=m%n; m=n; n=t; &#125; return m;&#125;// a和b不能 = 0int gcd(ll a , ll b)&#123; if(a &lt; b)&#123; ll t = a; a = b; b = t; &#125; if(a % b)&#123; gcd(b , a%b); &#125; else return b;&#125; 正确性证明我们设g为a和b的最大公约数，则a = mg , b = ng，其中，m和n互质。 证明算法的最终结果为a和b的一个公因子a/b = f1 …….. c1 b/c1 = f2 ……….. c2 . . . cn-1/cn = fn …….. 0 由上式可得：cn为最终结果，且 cn-1 = fn cn, cn-2 = fn-1 cn-1 + cn, 同理可得，a和b均可以被cn整除，所以cn为a和b的一个公因子，所以 cn &lt;= g 证明cn为最大的公因子由于a = mg = f1 b + c1 = f1 n g + c1, 所以 (m - f1 n) g = c1, 又因为(m - f1 * n) &gt;=1 ，所以 g &lt;= c1，同理，g &lt;= cn，而cn &lt;= g，所以cn = g。 求最小公倍数a和b的最小共倍数 = a * b / gcd(a , b)]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[完全背包]]></title>
    <url>%2F2020%2F02%2F29%2F%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[常规类型问题描述有多种物品，和一个最大承重量为w的背包，每种物品有weight和value，问将这些物品放入背包中（每种物品可以放多个），背包的最大价值是多少。 与0-1背包不同的是，0-1背包每件物品只能放一次，而完全背包每种物品可以无限多地放。 解决方法状态转移方程：dp[i , j] = max{dp[i-1 , j] , dp[i , j - weight[i]] + value[i]} 优化后：dp[j] = max{dp[j] , dp[j - weight[i]] + value[i]} 注意与0-1背包不同的是方程右边是dp[i , j - weight[i]] + value[i]。 上代码：1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int n,W;int w[1000],v[1000];int dp[10000];int main()&#123; freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); cin&gt;&gt;n&gt;&gt;W; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=w[i];j&lt;=W;j++)&#123; dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125; for(int j = 0 ; j&lt;=W ; ++j)&#123; cout&lt;&lt;dp[j]&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;dp[W]&lt;&lt;endl; return 0;&#125; 完全背包的内层循环是正序的，而0-1背包是逆序的，为什么呢？ 我们先来理解一下完全背包的状态转移方程：dp[i , j] = max{dp[i-1 , j] , dp[i , j - weight[i]] + value[i]}，在放i物品时，我们还是要考虑放还是不放？在什么基础上放？ 如果是0-1背包，那么在放i物品时，由于一个物品只能放一次，所以它的基础是前面i-1个物品所更新好的背包，即j背包前面的背包的状态必须是i-1； 而如果是完全背包，在背包j里放物品i时，它的基础却是状态i的背包，即比j容量小的背包是已经被i更新过的，为什么呢？ 比如容量10的背包，放weight=3的物品，那么我们只需要考虑在容量为7的背包里放weight=3的物品就好了，但不是前面说是一种物品可以放多个么，容量10的背包可以放3个weight=3的物品吧，为什么只放了一个呢？但是，由于内层循环是正序的，所以背包7的基础是4，背包4的基础是1，我们在背包4里放了一个3，在背包7里又放了一个，而背包7的基础是4，所以相当于放了2个3，所以到背包10时，想当于放了3个3，这就是为什么完全背包要正序的原因。 例题：hdu 2159 FATEhttp://acm.hdu.edu.cn/showproblem.php?pid=2159 我们把耐久度当成weight，经验值当成value，求满足经验值大于n，次数小于s的最小耐久度1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); int n , m , k , s; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s)&#123; int weight[110] , value[110] , dp[110] , num[110]; memset(weight , 0 , sizeof(weight)); memset(value , 0 , sizeof(value)); memset(dp , 0 , sizeof(dp)); memset(num , 0 , sizeof(num)); for(int i = 0 ; i&lt;k ; ++i)&#123; cin&gt;&gt;value[i]&gt;&gt;weight[i]; &#125; for(int i = 0 ; i&lt;k ; ++i)&#123; for(int j = weight[i] ; j&lt;=m ; ++j)&#123; if(dp[j] &lt; dp[j - weight[i]] + value[i])&#123; dp[j] = dp[j - weight[i]] + value[i]; num[j] = num[j - weight[i]] + 1; &#125; &#125; &#125; int flag = 0; for(int i = 0 ; i&lt;=m ; ++i)&#123; if(num[i] &lt;= s &amp;&amp; dp[i] &gt;= n)&#123; cout&lt;&lt;m - i&lt;&lt;endl; flag = 1; break; &#125; &#125; if(!flag)&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125; &#125;&#125; 其实还可以用二维完全背包做，把耐久度和次数都当做weight，经验当做value，每个怪物的次数这个weight都是1，题目要求输出的是最小耐久度，所以我们最终输出最大的次数，最小的&gt;n的经验值的情况下的最小耐久度，其中最大次数保证了最小耐久度下能获得的最大经验值。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); int n , m , k , s; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s)&#123; int weight[110] , value[110] , dp[110][110] , num[110]; memset(weight , 0 , sizeof(weight)); memset(value , 0 , sizeof(value)); fill(dp[0] , dp[0] + 110 * 110 , 0); memset(num , 0 , sizeof(num)); for(int i = 0 ; i&lt;k ; ++i)&#123; cin&gt;&gt;value[i]&gt;&gt;weight[i]; &#125; for(int i = 0 ; i&lt;k ; ++i)&#123; //一种物品一种物品地放 for(int j = weight[i] ; j&lt;=m ; ++j)&#123; //考虑耐久度 for(int h = 1 ; h&lt;=s ; ++h)&#123; //考虑次数 dp[j][h] = max(dp[j][h] , dp[j - weight[i]][h-1] + value[i]); &#125; &#125; &#125; if(dp[m][s] &gt;= n)&#123; for(int i = 1 ; i&lt;=m ; ++i)&#123; if(dp[i][s] &gt;= n)&#123; cout&lt;&lt;m-i&lt;&lt;endl; break; &#125; &#125; &#125; else cout&lt;&lt;-1&lt;&lt;endl; &#125;&#125; 求装特定重量的装法总数 给一个特定的容量，必须装满 与装的顺序无关 每个物品可以装无限多次 123456dp[0] = 1 ;必须初始化,其他为0for(int i = 0 ; i &lt; n ; ++i)&#123; for(int j = weight[i] ; j &lt;= w ; ++j)&#123; dp[j] = dp[j] + dp[j - weight[i]]; &#125; &#125; 其中$dp[i][j]$表示考虑前$i$件物品而且装满容量$j$的背包的装法总数。 所以状态转移函数为 dp[i][j] = sum(dp[i-1][j] , dp[i][j - weight[i]])也就是说，装法总数 = 我不装这个物品时的装法总数 + 装这个物品时的装法总数。 变种：背包需要装满常规的完全背包是只要背包能装得下就往里面装，现在是背包必须装满，我们设$dp(i,j)$表示前$i$个物品来装满容量为$j$的背包的最大价值，那么我们的递推公式： dp(i,j) = max(dp(i-1,j) , dp(i-1 , j - weight[i]) + value[i]就必须保证$j - weight[i]$的背包是满的。 12345678910111213141516171819202122232425262728293031323334353637int main()&#123; freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); int n , m; cin&gt;&gt;n; vector&lt;int&gt; weight , value; for(int i = 0 ; i&lt;n ; ++i)&#123; int a; cin&gt;&gt;a; weight.push_back(a); &#125; m = n; for(int i = 0 ; i&lt;m ; ++i)&#123; int a; cin&gt;&gt;a; value.push_back(a); &#125; int target; cin&gt;&gt;target; vector&lt;int&gt; dp(target+1 , -1); dp[0] = 0; //容量为0的背包是满的 for(int i = 0 ; i &lt; m ; ++i)&#123; for(int j = weight[i] ; j &lt;= target ; ++j)&#123; if(dp[j - weight[i]] != -1)&#123;//如果j - weight[i]的背包是满的 if(dp[j] == -1 || dp[j] &lt; dp[j - weight[i]] + value[i])&#123; dp[j] = dp[j - weight[i]] + value[i]; &#125; &#125; &#125; for(auto h : dp)&#123; cout&lt;&lt;h&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;dp.back();&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1068 Find More Coins (30分)]]></title>
    <url>%2F2020%2F02%2F29%2F1068%20Find%20More%20Coins%20(30%E5%88%86)%2F</url>
    <content type="text"><![CDATA[题目大意有几个数字，问是否有其中几个数加起来等于给定的数，如果有多个结果，输出最小的一组。https://pintia.cn/problem-sets/994805342720868352/problems/994805402305150976 解法一：dfs+特判12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; v;int n , m;int sum = 0;vector&lt;int&gt; money;int book = 0;void dfs(int u , int i)&#123; money.push_back(u); sum += u; //cout&lt;&lt;u&lt;&lt;' '&lt;&lt;sum&lt;&lt;endl; if(book)&#123; return; &#125; if(sum == m)&#123; book = 1; for(int j = 0 ; j&lt;money.size() ; ++j)&#123; if(!j)&#123; printf("%d" , money[j]); &#125; else printf(" %d" , money[j]); &#125; cout&lt;&lt;endl; return ; &#125; else if(sum &gt; m)&#123; money.pop_back(); sum -= u; return ; &#125; for(int j = i+1 ; j&lt;n ; ++j)&#123; dfs(v[j] , j); if((sum + v[j+1]) &gt; m) break; &#125; money.pop_back(); sum -= u;&#125;int main()&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); scanf("%d%d" , &amp;n , &amp;m); int ssum = 0; for(int i = 0 ; i&lt;n ; ++i)&#123; int a; scanf("%d" , &amp;a); if(a &lt;= m)&#123; v.push_back(a); ssum += a; &#125; &#125; if(!v.size() || ssum &lt; m)&#123; cout&lt;&lt;"No Solution"; return 0; &#125; sort(v.begin() , v.end()); for(int i = 0 ; i&lt;n ; ++i)&#123; sum = 0; book = 0; dfs(v[i] , i); money.clear(); if(book)&#123; return 0; &#125; &#125; cout&lt;&lt;"No Solution";&#125; 如果不加特判，那么最后一点会超时，29分，这显然不是很好的解法 解法二：0-1背包首先需要把序列从大到小排列，然后在dp，为什么呢？ 看一组样例：5 9 8 7 2 3 4 1，容量为9 我们可以这样想，我们可以一个一个数地放入“背包”，如果符合条件dp[j] &lt;= dp[j-weight[i]]+value[i]，那么我们就把i标记（flag[i][j] = 1），最终通过while遍历最小的数。当该放每组结果的最小的数时，由于我们是从大到小排列的，所以前面比它大的数已经把其他背包更新好了，比如1 3 5，由于3和5已经把背包8更新成8，所以1就被背包9标记了，所以其实我们最终是把每组结果在各个背包的第一个数（即小的数）标记，即大数把背包更新，最小的数在此铺垫上就被标记了，而题目要求我们输出最小的结果，所以这就是序列必须从大到小排列的原因。 启发：0-1背包由于我们是一个数一个数地放，所以当放第i个数时，前面i-1个数已经把背包更新好了，这就是铺垫，第i个数在此铺垫上更新背包。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;using namespace std;int dp[10010], w[10010];bool flag[10010][110];int cmp1(int a, int b)&#123;return a &gt; b;&#125;int main()&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); fill(flag[0] , flag[0] + 10010*110 , false); int n , m; cin&gt;&gt;n&gt;&gt;m; for(int i = 1 ; i&lt;=n ; ++i)&#123; cin&gt;&gt;w[i]; &#125; sort(w+1 , w+n+1 , cmp1); for(int i = 1 ; i&lt;=n ; ++i)&#123; for(int j = m ; j&gt;=w[i] ; --j)&#123; if(dp[j] &lt;= dp[j - w[i]] + w[i])&#123; flag[i][j] = 1; dp[j] = dp[j - w[i]] + w[i]; &#125; &#125; &#125; if(dp[m] &lt; m)&#123; cout&lt;&lt;"No Solution"; return 0; &#125; else &#123; vector&lt;int&gt; v; int index = n; while(m)&#123; if(flag[index][m])&#123; v.push_back(w[index]); m -= w[index]; &#125; index--; &#125; for(int i = 0 ; i&lt;v.size() ; ++i)&#123; if(i &gt; 0)&#123; cout&lt;&lt;' '; &#125; cout&lt;&lt;v[i]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>0-1背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0-1背包]]></title>
    <url>%2F2020%2F02%2F29%2F0-1%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[问题描述 有几个物品，各自有各自的重量（weight）和价值（value），现在有一个最大承重为v的背包，问此背包最多可以装的价值是多少？ 一件物品只能放一次，可以不放 与放入次序无关，即数据可以是无序的 背包有最大承重量 求最大价值 解决方法我们可以一件一件地放物品，那么我们只需要考虑这件物品到底该不该放入背包里，假设用dp[i , j]来表示放前i件物品（不一定这i件物品都放进去）到最大承重为j的背包时的最大价值，那么dp[i , v]就表示此背包在放前i件物品时的最大价值，我们用weight[i]表示第i件物品的重量，value[i]表示第i件物品的价值。那么我们可以状态转化方程：dp[i , j] = max{dp[i-1 , j] , dp[i-1 , j - weight[i]] + value[i]}，其中，j&gt;=weight[i]。 dp[i , j]表示承重量为j的背包里放前i件物品的最大价值（第i件物品不一定放进去） dp[i - 1 , j]表示承重量为j的背包里放前i-1件物品的最大价值。 dp[i-1 , j - weight[i]]表示承重量为j-weight[i]的背包里放前i-1件物品的最大价值。 我们如果考虑是否要放第i件物品，由于随着背包容量的增加，背包的价值是递增的，那么我们如果要把第i件物品放入背包，就要看j-weight[i]的背包里的价值加上value[i]是否比dp[i-1 , j]（不放i物品）的价值大。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string.h&gt;#include &lt;iomanip&gt;using namespace std;int dp[100];int main()&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); int n , v; //总物品数和最大重量 int value[100] , weight[100]; cin&gt;&gt;n&gt;&gt;v; for(int i = 0 ; i&lt;n ; ++i)&#123; cin&gt;&gt;weight[i]&gt;&gt;value[i]; &#125; for(int i = 0 ; i&lt;n ; ++i)&#123; //一件一件放物品 for(int j = v ; j&gt;=weight[i] ; --j)&#123; //0-1背包一定要逆序更新 dp[j] = max(dp[j] , dp[j - weight[i]] + value[i]); //注意两个dp[j]所表示的状态不同，左边表示状态i，右边表示状态i-1 &#125; &#125; for(int i = 0 ; i&lt;=v ; ++i)&#123; cout&lt;&lt;dp[i]&lt;&lt;' '; &#125;&#125; 为什么要逆序更新？？这就涉及到状态的问题了，我们在考虑是否要放入第i件物品时，必须保证所有的背包的价值是未考虑i时的价值（即i-1的状态），而背包的价值的更新只和比它容量小的背包的价值有关，如果我们先更新小的背包，那么等到要更新大的背包时，小的背包的状态已经是状态i了，这与我们的初衷不符，所以要先把容量大的背包更新成状态i，等到更新小的背包时，大的背包的状态与它是没有关系的，所以要逆序更新。 hdu 2955 Robberieshttp://acm.hdu.edu.cn/showproblem.php?pid=2955 这个题目给出抢劫每一个银行时的被捕概率和钱数，不能把概率当做weight，钱当做value来求最大钱数，因为概率是double类型，无法枚举。我们可以把钱当做weight，逃跑概率当做value，转化成求最大逃跑概率。]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>0-1背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2020%2F02%2F24%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡二叉树的插入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;typedef struct AVLnode&#123; int data; int height; AVLnode *left , *right;&#125;AVLnode , *AVLtree;int getHeight(AVLtree tree)&#123; if(tree == NULL)&#123; return 0; &#125; return tree-&gt;height;&#125;void updateHeight(AVLtree tree)&#123; //每次插入后都要更新高度，由于是递归，所以在每次插入后加1就可以更新全部节点的高度 tree-&gt;height = max(getHeight(tree-&gt;left) , getHeight(tree-&gt;right)) + 1;&#125;int getBalance(AVLtree tree)&#123; //左子树高度-右子树高度，如果是2或-2，那么说明不平衡了 return getHeight(tree-&gt;left) - getHeight(tree-&gt;right);&#125;void leftTurn(AVLtree &amp;tree)&#123; //左旋操作 AVLtree temp = tree-&gt;right; tree-&gt;right = temp-&gt;left; temp-&gt;left = tree; updateHeight(tree); //旋转后位置变化，要更新节点高度 updateHeight(temp); tree = temp;&#125;void rightTurn(AVLtree &amp;tree)&#123; //右旋操作 AVLtree temp = tree-&gt;left; tree-&gt;left = temp-&gt;right; temp-&gt;right = tree; updateHeight(tree); //先更新高度低的节点 updateHeight(temp); tree = temp;&#125;void insertt(AVLtree &amp;tree , int v)&#123; //传入的是指针的引用，如果只传入指针，无法改变指针参数所指向的地址，只有传入指针引用才能改变地址 if(tree == NULL)&#123; tree = new AVLnode; tree-&gt;data = v; tree-&gt;height = 1; tree-&gt;left = tree-&gt;right = NULL; return ; &#125; if(v &lt; tree-&gt;data)&#123; insertt(tree-&gt;left , v); updateHeight(tree); if(getBalance(tree) == 2)&#123; if(getBalance(tree-&gt;left) == 1)&#123; //LL型 根节点右旋 rightTurn(tree); &#125; else if(getBalance(tree-&gt;left) == -1)&#123; //LR，先左子树左旋，然后根节点右旋 leftTurn(tree-&gt;left); rightTurn(tree); &#125; &#125; &#125; else &#123; insertt(tree-&gt;right , v); updateHeight(tree); if(getBalance(tree) == -2)&#123; if(getBalance(tree-&gt;right) == -1)&#123; //RR 根节点左旋 leftTurn(tree); &#125; else if(getBalance(tree-&gt;right) == 1)&#123; //RL 右子树右旋，根节点左旋 rightTurn(tree-&gt;right); leftTurn(tree); &#125; &#125; &#125;&#125;int main()&#123; freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); int n; cin&gt;&gt;n; AVLtree tree = NULL; for(int i = 0 ; i&lt;n ; ++i)&#123; int a; cin&gt;&gt;a; insertt(tree , a); &#125; cout&lt;&lt;tree-&gt;data;&#125;]]></content>
      <categories>
        <category>PTA甲级题目</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1057 Stack (30分)]]></title>
    <url>%2F2020%2F02%2F22%2F1057-Stack-30%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目要求我们输出栈中从小到大中间的数，考虑到有重复元素和排序，所以选择multiset，但是我们不能直接使用下标访问set元素，比如*(s.begin() + 2) 或 s[2]，都是不行的。直接遍历的话会超时，所以我们可以用以下思路： 我们可以动态化地更新mid的值，比如3的时候mid = 3，2 3 的时候mid = 2，1 2 3的时候mid值是2，1 1 2 3 的时候mid = 1。 我们可以用两个multiset来存放值，s1用来存放 &lt;= mid的值，s2用来存放 &gt; mid的值。1 2 3 的时候s1里放1 2，s2里放3，mid的值是s1的最后一个元素2，1 1 2 3 的时候s1里放1 1，s2里放2 3，mid的值是1。 由于插入和删除的时候mid的值会有所变化，我们可以通过更新s1和s2里存放的值来更新mid，我们要使得s1.size() == s2.size() （这是偶数情况），或s1.size() == s2.size() + 1（这是奇数情况）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;stack&lt;int&gt; s;multiset&lt;int&gt; s1 , s2;int mid = 0;void opt()&#123; if(s1.size() &lt; s2.size())&#123; multiset&lt;int&gt;::iterator iter = s2.begin(); s1.insert(*iter); s2.erase(iter); &#125; else if(s1.size() &gt; s2.size() + 1)&#123; multiset&lt;int&gt;::iterator iter = s1.end(); iter--; s2.insert(*iter); s1.erase(iter); &#125; if(!s1.empty())&#123; multiset&lt;int&gt;::iterator iter = s1.end(); iter--; mid = *iter; &#125;&#125;int main()&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); int n; cin&gt;&gt;n; for(int i = 0 ; i&lt;n ; ++i)&#123; string c; cin&gt;&gt;c; if(c[1] == 'o')&#123; if(s.empty())&#123; cout&lt;&lt;"Invalid"&lt;&lt;endl; &#125; else &#123; if(s.top() &lt;= mid)&#123; s1.erase(s1.find(s.top())); &#125; else s2.erase(s2.find(s.top())); opt(); cout&lt;&lt;s.top()&lt;&lt;endl; s.pop(); &#125; &#125; else if(c[1] == 'u')&#123; int a; scanf("%d" , &amp;a); s.push(a); if(s1.empty() || a &lt;= mid)&#123; s1.insert(a); &#125; else s2.insert(a); opt(); &#125; else &#123; if(s.empty())&#123; cout&lt;&lt;"Invalid"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;mid&lt;&lt;endl; &#125; &#125; //cout&lt;&lt;s1.size()&lt;&lt;' '&lt;&lt;s2.size()&lt;&lt;' '&lt;&lt;mid&lt;&lt;endl; &#125;&#125; 反思：由于是一个一个元素插入或删除，所以mid的值只会移动一步，所以找到这个位置是关键，如果只用一个multiset的话，这个位置是找不到的。]]></content>
      <categories>
        <category>PTA甲级题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1049 Counting Ones (30 分)]]></title>
    <url>%2F2020%2F02%2F20%2F1049%20Counting%20Ones%20(30%20%E5%88%86)%2F</url>
    <content type="text"><![CDATA[题目大意：给出整数N，要求求出从1到N的十进制数中位数是1的个数之和。思路：题目可以转化为求当每一位是1的时候，总共有多少种情况。 例如30710，我们从右向左遍历。 首先是0，那么它的右边的数为3071，如果我们假设它不是0而是1，那么前面的数可以取0-3070，3071不可以，因为30711 &gt; 30710 ， 所以总共有3071种情况。 接下来是1，那么当左边的数取0-306的时候，右边的数可以随便取（0-9），左边的数取307的时候，右边只能取原来的数，所以共有307*10+1种。 然后是7，假设此位是1而不是7，那么左边的数可以取0-30，右边的数随便取（0-99），所以共有（30+1）*100种。 然后是0，假设是1，那么左边可以取0-2，右边随便取（0-999），所以有3*1000种。 最后是3，假设是1，那么右边随便取，共有（0+1）* 10000种。 规律： 当前位数字 == 0时，那么此位为1时有 左边数 * 当前位数； 当前位数字 == 1时，那么此位为1时有 左边数 * 当前位数 + 右边数 + 1； 当前位数字 &gt; 1时，那么此位为1时有 （左边数+1） * 当前位数； 反思：求所有位数为1的个数，那么我们可以一位一位求，因为我们求这一位是1的情况的时候，虽然和求另外一位是1的情况的时候是有会重复数字，但是这不影响求总的1的个数。12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main()&#123; int n, a=1, ans = 0; int left, loc, right; scanf("%d", &amp;n); while(n/a!=0) &#123; left = n/(a*10); loc = n/a%10; right = n%a; if(loc == 0) ans += left*a; else if(loc==1) ans += left *a + right + 1; else ans += (left + 1)*a; a *= 10; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>PTA甲级题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1045 Favorite Color Stripe (30分)]]></title>
    <url>%2F2020%2F02%2F19%2Fdp%2F</url>
    <content type="text"><![CDATA[PTA甲级 1045 Favorite Color Stripe (30分) 找到最大长度的颜色序列 顺序要正确，可以缺少颜色 由于要求最大长度，所以肯定要把每一个元素都遍历。 可以发现，只要一个颜色序列包括这个颜色（假设为i），那么我们可以求出这个序列最开始的颜色到这个颜色i的最大长度，用dp表示如果这个颜色i被选中，那么这个序列最开始的颜色到颜色i的最大长度，一开始初始化为1。接下来从1到i遍历（即遍历颜色i之前的颜色），只要i之前的颜色j的等级不大于i（即j &lt;= i），那么就更新dp[i] = max(dp[i] , dp[j]+1)，也就是说，我们要想让颜色序列包括颜色i，那么颜色i之前的颜色j的等级就必须&lt;=，这样从1到i遍历后，我们就可以找到如果序列包括颜色i时的最大长度。 关键：dp[i] = max(dp[i] , dp[j]+1)123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; order , v;int book[201];vector&lt;int&gt; position[300];int dp[10010];int main()&#123; freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); int n; cin&gt;&gt;n; int m; cin&gt;&gt;m; for(int i = 1 ; i&lt;=m ; ++i)&#123; int a; cin&gt;&gt;a; book[a] = i; &#125; int L; cin&gt;&gt;L; for(int i = 0 ; i&lt;L ; ++i)&#123; int a; cin&gt;&gt;a; if(book[a])&#123; v.push_back(book[a]); &#125; &#125; int mmax = -1; for(int i = 0 ; i&lt;v.size() ; ++i)&#123; dp[i] = 1; for(int j = 0 ; j&lt;i ; ++j)&#123; if(v[i] &gt;= v[j])&#123; dp[i] = max(dp[i] , dp[j]+1); &#125; &#125; mmax = max(mmax , dp[i]); &#125; cout&lt;&lt;mmax;&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2F2020%2F02%2F17%2F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[参数传递值传递、引用参数和const形参 值传递就是实参的值被拷贝给形参，此时实参和形参是两个相互独立的对象。 而传引用参数时，实参和形参是同一个对象。12345678void test(int *a)&#123; *a = 1; //a所指向的int对象的值变为了1 a = 0; // 但是a的值没有变，即a所指向的地址没有变&#125;void test(int *&amp;a)&#123; *a = 1; //此时a和*a的值都被改变 a = 0;&#125;使用引用可以避免拷贝，当拷贝大的类类型或容器对象时比较低效，当函数无需修改引用参数的值时，最好使用常量引用。 把不会改变的形参定义为常量引用有很多好处。1234567891011121314void test(int &amp;a)&#123; a = 1;&#125;int main()&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); test(42); //编译错误，不能把字面值传递给普通引用形参。 const int a = 42; test(a); //编译错误，不能把const对象传递给普通引用。&#125; 数组形参由于不能拷贝数组，而且为函数传递一个数组时，实际上传递的是指向数组首元素的地址。1234//等价定义void test(int *a);void test(int a[]);void test(int a[10]); //这里的10并不是指数组有10个元素 传递多维数组多维数组其实就是数组的数组的。。。。。，所以首元素是一个数组，所以指向首元素的指针其实就是一个指向数组的指针。123456789//括号不能丢int (*a)[10]; //定义了一个指针，a是指针，指向含有10个整数的数组int *a[10]; //定义了一个含有10个指针构成的数组//二维数组的定义void test(int (*a)[10]); //a指向二维数组的首元素，首元素是一个由10个整数构成的数组void test(int a[][10]); //等价定义void test(int a[][10][10]); //三维数组void test(int (*a)[10][10]); 可变形参的函数如果函数的参数的数量未知，但是参数的类型一样时，可以使用initializer_list类型的形参。注意的是：initializer_list对象中的元素是常量值，无法改变元素的值。 需要可变参数的时候，为什么不用vector代替initializer_list？参考https://www.jianshu.com/p/3d69ff89a0c9 返回值和return语句列表初始化返回值函数可以返回{}包围的值的列表123vector&lt;string&gt; test()&#123; return &#123;"lzc" , "lzc"&#125;;&#125; 函数指针函数指针值向函数1234567891011121314151617181920212223int sum(int a , int b)&#123; return a + b;&#125;int (*pf)(int , int); //pf指向一个函数，该函数的形参是两个int，返回值是int类型。int ssum(int a , int b , int (*pf)(int , int))&#123; //函数指针用于形参，形参名任意取 return a + b + pf(1 , 2);&#125;int main()&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); //test(42); pf = sum; int a = pf(1 , 2); a = (*pf)(1 , 2); //等价定义 a = sum(1 , 2); cout&lt;&lt;a&lt;&lt;endl; a = ssum(2 , 3 , sum); //函数名转化为指针 cout&lt;&lt;a;&#125;可以使用类型别名简化函数指针的代码12345678910111213141516171819202122int sum(int a , int b)&#123; return a + b;&#125;typedef int func(int , int); //func和func1是函数类型typedef decltype(sum) func1;typedef int (*func2)(int , int); //func2和func3是函数指针类型typedef decltype(sum) * func3;int ssum(int a , int b , func1 f)&#123; //上面四个都可以用在这里，编译器会把func和func1所表示的函数类型转为指针 return a + b + f(1 , 2);&#125;int main()&#123; //freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); //test(42); int a = ssum(1 , 2 , sum); cout&lt;&lt;a;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[负数的二进制]]></title>
    <url>%2F2020%2F02%2F14%2F%E8%B4%9F%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[将十进制负数转换成二进制负数在计算机中是以补码来表示的，在二进制码中，最高位是符号位，1代表负数，0代表正数。具体过程如下： 以-2为例，8位为代表： 原码 10000010 符号位不变，取反 11111101（反码） 加一 11111110（补码） 所以-2的二进制是11111110 求二进制负数的原码以-2为例： 符号位不变，取反 10000001 加一 10000010 10000010是-2的原码表示 位运算进行位运算时，负数补1，正数补0]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径]]></title>
    <url>%2F2020%2F02%2F12%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[Dijkstra算法局限性：图中不能有负权边1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;const int max_point = 1000;const int maxint = 999999999;int dist[max_point];int c[max_point][max_point];void Dijkstra(int n , int v , int *dist , int c[max_point][max_point])&#123; int book[max_point]; for(int i = 0 ; i&lt;n ; ++i)&#123; book[i] = 0; dist[i] = c[v][i]; &#125; book[v] = 1; dist[v] = 0; for(int i = 0 ; i&lt;n-1 ; ++i)&#123; int tmp = maxint; int u = v; for(int j = 0 ; j&lt;n ; ++j)&#123; if(!book[j] &amp;&amp; dist[j] &lt; tmp)&#123; tmp = dist[j]; u = j; &#125; &#125; book[u] = 1; for(int j = 0 ; j&lt;n ; ++j)&#123; if(!book[j] &amp;&amp; c[u][j] &lt; maxint &amp;&amp;(dist[u] + c[u][j] &lt; dist[j]))&#123; dist[j] = dist[u] + c[u][j]; &#125; &#125; &#125; for(int i = 0 ; i&lt;n ; ++i)&#123; cout&lt;&lt;dist[i]&lt;&lt;' '; &#125;&#125;int main()&#123; freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); int n , m; cin&gt;&gt;n&gt;&gt;m; for(int i = 0 ; i&lt;n ; ++i)&#123; for(int j = 0 ; j&lt;n ; ++j)&#123; if(i == j)&#123; c[i][j] = 0; &#125; else c[i][j] = maxint; &#125; &#125; for(int i = 0 ; i&lt;m ; ++i)&#123; int u1 , u2 , length; cin&gt;&gt;u1&gt;&gt;u2&gt;&gt;length; if(length &lt; c[u1][u2])&#123; c[u1][u2] = length; c[u2][u1] = length; &#125; &#125; for(int i = 0 ; i&lt;n ; ++i)&#123; dist[i] = maxint; &#125; Dijkstra(n , 0 , dist , c);&#125; Dijkstra + dfs 遍历所有最短路径Dijkstra算法有个好处，就是它拓展点只会拓展一次，而且只会拓展边一次 ，因此该点到源点的最短路径要修改与它相邻的点时不会有重复路径。 递归算法中回溯法很重要。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int max_int = 1e8 , max_point = 1000; //距离最大值 最多点数int mp[max_point][max_point]; //地图vector&lt;int&gt; path[max_point]; //最短路径中，第i个点的前驱int dist[max_point]; //最短距离vector&lt;int&gt; p ; //储存最短 轨迹int sum_path[max_point]; //第i个点到原点的最短路径个数void Dijkstra(int n , int v , int *dist , int mp[max_point][max_point])&#123; int book[n]; for(int i = 0 ; i&lt;n ; ++i)&#123; book[i] = 0; dist[i] = mp[v][i]; &#125; for(int i = 0 ; i&lt;n ; ++i)&#123; int u , tmp = max_int; for(int j = 0 ; j&lt;n ; ++j)&#123; if(!book[j] &amp;&amp; tmp &gt; dist[j])&#123; tmp = dist[j]; u = j; &#125; &#125; book[u] = 1; for(int j = 0 ; j&lt;n ; ++j)&#123; if(!book[j] &amp;&amp; dist[j] &gt; dist[u] + mp[u][j])&#123; dist[j] = dist[u] + mp[u][j]; path[j].clear(); path[j].push_back(u); sum_path[j] = sum_path[u]; &#125; else if(!book[j] &amp;&amp; dist[j] == dist[u] + mp[u][j])&#123; path[j].push_back(u); sum_path[j] += sum_path[u]; //由于算法拓展一个点时只会拓展与它相邻的点，且每条边只拓展一次，所以不会有重复路径 &#125; &#125; &#125;&#125;void find_path(int u , int v)&#123; //u , v 是要求的最短路径的端点 if(v == u)&#123; p.push_back(u); for(int i = p.size()-1 ; i&gt;=0 ; --i)&#123; cout&lt;&lt;p[i]&lt;&lt;' '; &#125; cout&lt;&lt;endl; p.pop_back(); return; &#125; p.push_back(v); for(int i = 0 ; i&lt;path[v].size() ; ++i)&#123; //由于是遍历前驱，所以路是倒着的 find_path(u , path[v][i]); &#125; p.pop_back(); //回溯！！&#125;int main()&#123; freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); int n , m; //n个点，m条边 cin&gt;&gt;n&gt;&gt;m; //默认点从0到n-1 for(int i = 0 ; i&lt;n ; ++i)&#123; for(int j = 0 ; j&lt;n ; ++j)&#123; if(i == j) mp[i][j] = 0; else mp[i][j] = max_int; &#125; &#125; for(int i = 0 ; i&lt;m ; ++i)&#123; int c1 , c2 , length; cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;length; mp[c1][c2] = length; mp[c2][c1] = length; &#125; sum_path[0]++; //必须把要求的源点的sum_path++; Dijkstra(n , 0 , dist , mp); find_path(0 , 4); for(int i = 0 ; i&lt;n ; ++i)&#123; cout&lt;&lt;sum_path[i]&lt;&lt;' '; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针与多维数组]]></title>
    <url>%2F2020%2F01%2F18%2F%E6%8C%87%E9%92%88%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[多维数组多维数组实际上是数组的数组的数组的…………. 例如：a[3][4]，a指向一个维度为4的一维数组，a指向这个一维数组的第一个元素，*a表示这个一维数组的第一个元素。12345678910111213int a[3][4] , sum = 1;for(int i = 0 ; i&lt;3 ; ++i)&#123; for(int j = 0 ; j&lt;4 ; ++j)&#123; a[i][j] = sum++; &#125;&#125;for(int i = 0 ; i&lt;3 ; ++i)&#123; //遍历 for(int j = 0 ; j&lt;4 ; ++j)&#123; cout &lt;&lt; *(*(a+i) + j) &lt;&lt; ' '; &#125; cout&lt;&lt;endl;&#125; 函数的多维数组参数两种方式：12void print(int (*a)[10])void print(int a[][10]) //实际形参是指向含有10个元素的数组的指针注意：在函数里的参数不能直接用begin和end1234void print(int (*a)[10])&#123; cout&lt;&lt;end(a) - begin(a); //无法通过编译 cout&lt;&lt;end(*a) - begin(*a); // 10&#125; 使用范围for循环处理多维数组123456int arr[2][4] = &#123;1 , 2 , 3 , 4 , 5 , 6&#125;;for(auto &amp;i : arr)&#123; for(auto j : i)&#123; cout&lt;&lt;j; &#125;&#125; 注意上面代码i使用了引用类型，如果不加&amp;，那么编译器会把 i 变为指针类型int *，这样内层循环就不合法了。 1234567int arr[2][4] = &#123;1 , 2 , 3 , 4 , 5 , 6&#125;;for(auto p = begin(arr) ; p != end(arr) ; ++p)&#123; for(auto q = begin(*p) ; q != end(*p) ; ++q)&#123; cout&lt;&lt;*q; &#125;&#125;//相当于声明了 int (*p)[4] = arr;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2020%2F01%2F18%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[显式初始化数组元素当显式地初始化数组元素时，如果提供的维度比初始值数量大，那么剩下的元素会被初始化为默认值。1234567891011121314int a[10] = &#123;1 , 2 , 3&#125;; //默认值为0char a2[10] = "lzc"; //默认值为'\0'string a3[10] = &#123;"lzc" , "hello" , "world"&#125;; // 默认值为""for(auto i : a2)&#123; cout&lt;&lt;(i == '\0');&#125;cout&lt;&lt;endl;for(auto i : a)&#123; cout&lt;&lt;i;&#125;cout&lt;&lt;endl;for(auto i : a3)&#123; cout&lt;&lt;(i == "");&#125;当显式地用字面值初始化字符数组时，要注意：123456char a[] = "lzc"; //结尾有'\0'char a1[] = &#123;'l' , 'z' , 'c'&#125;; //结尾没有'\0'char a2[] = &#123;'l' , 'z' , 'c' , '\0'&#125;;char a3[3] = "lzc"; // 错误的，最小是4才能容得下cout&lt;&lt;(a[3] == '\0')&lt;&lt;endl;cout&lt;&lt;(a1[3] == '\0')&lt;&lt;endl; //结果虽然是0，但是a1[3]时不存在的 复杂数组的声明12345int *p[10]; //p是容量为10的数组，里面的元素为整形指针(可以从右向左理解)int &amp;p2[10]; //错误，没有引用的数组int (*p3)[10]; //可以从内向外理解，首先，p3是一个指针，它指向大小为10的数组，数组中的元素为intint (&amp;p4)[10]; //同理，p4是一个引用，引用的对象是大小为10的数组，数组中的元素为intint *(&amp;p5)[10]; //p5是一个引用，引用的对象是大小为10的数组，数组中的元素是整形指针 访问数组元素使用下标访问当使用下标时，通常将其定义 为size_t类型，size_t是一个无符号类型。 使用begin和end1234int a[] = &#123;1 , 2 , 3 , 4 , 5&#125;;for(auto i = begin(a) ; i != end(a) ; ++i)&#123; cout&lt;&lt;*i;&#125; 用string初始化char数组12string s = "13213123";const char *str = s.c_str(); // 此函数返回的是const char * 类型 用数组初始化vector12int arr[] = &#123;1 , 2 , 3 , 4 , 5&#125;;vector&lt;int&gt; v(begin(arr) , end(arr));]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string一些小知识]]></title>
    <url>%2F2020%2F01%2F07%2Fstring%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[string::size_type 类型string::size_type是无符号整形，所以有时候与int混用会出现问题。例如s.size() &lt; n，如果n是一个int类型，那么一旦n小于0，那么这个几乎都等于true，因为表达式中既有带符号类型又有无符号类型，带符号类型会自动转化为无符号类型，所以n如果是负数，那么就相当于n的绝对值对无符号类型表示数值总数取模后的余数。 所以一个表达式用有了size()函数(vector等很多size()函数也是无符号类型)就不要用int了！！！ 当要用string的下标时，可以采用：for(decltype(s.size()) i = 0 ; i != s.size() ; ++i)来访问string的元素。 字面值和string对象相加使用 + 运算符时，要确保 + 两侧的运算对象至少有一个是stirng string s = &quot;hello &quot; + &quot;, &quot;; // 错误 string s = &quot;hello &quot; + &quot;, &quot; + s; //错误 string s = &quot;hello &quot; + (&quot;, &quot; + s); // 正确 string s = s + &quot;hello &quot; + &quot;, &quot;; //正确 c++ 中字符串字面值并不是string 的对象]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型处理]]></title>
    <url>%2F2020%2F01%2F04%2F%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[类型别名两种方法：12345//第一种、typedef double money; //money 是double 的同义词typedef money rmb , *dollar // rmb是 double的同义词，dollar是double * 的同义词using money = double; //money 是double 的同义词 注意事项如果类型别名指代的是复合类型，那么把它用到声明语句中会有变化12typedef char *ch; //ch是 char *的同义词const ch c = 0; // 注意：这里c是 指向char的常量指针 而非 指向常量char 的指针 注意这里和平常的理解不一样：我刚开始以为const ch 就是 const char ，没想到对const ch 的理解并不是简单地把 ch 替换成 char 。 decltype 类型提示符有时我们想通过表达式的类型来判断要定义的变量的类型，但是又不想用该表达式的值来初始化变量，就可以用decltype。12345678int f(int a , int b)&#123; return a+b;&#125;decltype(f(10 , 10)) sum = 10; // sum 为int 类型int i = 10 , *p = &amp;i;decltype(*p) c = 10; // 注意：如果表达式的结果是解应用操作，那么将返回 引用类型，所以 c的类型是 int &amp; ，而非 int，所以c必须被初始化。decltype((i)) d = 10; //注意：decltype((variable))的结果是 引用，所以d的类型是int &amp;，所以 d 必须初始化。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const限定符]]></title>
    <url>%2F2020%2F01%2F04%2Fconst%E9%99%90%E5%AE%9A%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[指针和const允许让一个指向常量的指针指向一个非常量12345int i = 0;const int *p = &amp;i; //定义一个指向常量的指针cout&lt;&lt;*p&lt;&lt;endl; // 0i = 100;cout&lt;&lt;*p; // 100 const 指针一个指向常量的指针是指针可以变，但是指针指向对象的值不能通过指针改变；const 指针是指，指针本身是一个常量，即不能改变指针所指向的地址，但是指针指向对象的值可以改变。1234int i = 0;int *const p = &amp;i;*p = 100;cout&lt;&lt;i; // 100 顶层const用顶层const来表示指针本身是常量，用底层const来表示指针所指向的对象是常量。123456int i = 0;int *const p1 = &amp;i; //顶层constconst int ci = 42; const int *p2 = &amp;ci; //底层constconst int *const p3 = p2; //右const是顶层const，左const是底层constconst int &amp;r = ci; //用于声明引用的const 都是底层const constexpr和常量表达式常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式。12const int c = get_size(); // 不是常量表达式int i = 10; // 不是常量表达式一般，如果一个变量是一个常量表达式，那么把它声明成constexpr类型 constexpr指针的初始值必须是nullptr或者是0，或是储存于某个固定地址中的对象。 函数体内定义的变量一般来说不是储存在固定地址，因此不能用来初始化constexpr指针；定义在所有函数体外的对象的储存地址固定不变，可以初始化constexpr指针。 指针与constexpr区别：``` bashconst int p = nullptr; //指向 整形常量 的指针constexpr int q = nullptr; //指向整形的 常量指针constexpr const int *p1 = &amp;j //p1是 常量指针 ，指向 整形常量 j]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python常用函数]]></title>
    <url>%2F2019%2F12%2F18%2FPython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[np.flatnonzero()该函数返回矩阵的展平版本中非零元素的位置123import numpy as npa = np.arange(12).reshape(3 , 4)np.flatnonzero(a)结果如下： array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], dtype=int64) np.random.choice()numpy.random.choice(a, size=None, replace=True, p=None) 从a(只要是ndarray都可以，但必须是一维的)中随机抽取数字，并组成指定大小(size)的数组 replace:True表示可以取相同数字，False表示不可以取相同数字 数组p：与数组a相对应，表示取数组a中每个元素的概率，默认为选取每个元素的概率相同。 12a = np.random.choice(5 , 3) #相当于(0 , 5 , 3)a 结果如下： array([0, 0, 3]) np.sum()12345a = np.arange(24).reshape(4 , 2 , 3)b = np.sum(a , 0)c = np.sum(a , 1)d = np.sum(a , 2)print(b.shape , c.shape , d.shape) 结果如下： (2, 3) (4, 3) (4, 2) 如果第二个参数不填的话，默认将所有元素全部加起来。 第二个参数是几，就在第几个维度上求和，这在python其他函数中也是一样的情况。 np.argsort()返回数组中按一定顺序排列后的引索值12345678a = np.array([[3 , 1 , 4] , [4 , 9 , 0] , [1 , 2 ,9]])print(a)print()print(np.argsort(a , axis = 1)) #将每行排列print()print(np.argsort(a)) #默认将每行排列print()print(np.argsort(a , axis = 0)) #将每列排列结果如下：123456789101112131415[[3 1 4] [4 9 0] [1 2 9]][[1 0 2] [2 0 1] [0 1 2]][[1 0 2] [2 0 1] [0 1 2]][[2 0 1] [0 2 0] [1 1 2]]上面是按从小到大排列的若按从大到小排列：12a = np.array([4 , 9 , 0])np.argsort(-a)结果： array([1, 0, 2], dtype=int64) np.bincount(x , weights , minlength)返回数组中元素的出现重复次数12a = np.array([4 , 9 , 0 , 0 , 3 , 2])print(np.bincount(a))结果如下： [2 0 1 1 1 0 0 0 0 1] 这个函数首先输入的数组的值为int类型，而且数组必须是一维的，然后他会找出数组中的最大值(比如本例中9)，然后输出就是一个长度&gt;=max的一维数组，本例中，0出现2次，1，5，6，7，8均未出现，其中4，3，2，9均出现1次。 参数weigths 的形状是array_link(x)，作用是如果weights 被指定，那么x就会被加权，也就是说，如果值n发现在位置i，那么out[n] += weight[i]而不是out[n] += 1比如：1234w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6])# 我们可以看到x中最大的数为4，因此bin的数量为5，那么它的索引值为0-&gt;4x = np.array([2, 1, 3, 4, 4, 3])np.bincount(x, weights=w)结果如下： array([ 0. , 0.5, 0.3, -0.4, 1.7]) 其中3分别赋予了(0.2 + (-0.6))的权值，4为(1.0 + 0.7)的权值。 minlength 指定输出最小的长度如果数组中的最大值小于了minlength，那么少于的部分被补零。12a = np.array([0 , 2 , 3 , 2])print(np.bincount(a , minlength = 10))结果如下： [1 0 2 1 0 0 0 0 0 0] argmax()先看一维123import numpy as npa = np.array([3, 1, 2, 4, 6, 1])print(np.argmax(a))结果： 4 即返回的是最大值的位置 再看二维123456a = np.array([[1, 5, 5, 2], [9, 6, 2, 8], [3, 7, 9, 1]])print(np.argmax(a , axis = 0))print()print(np.argmax(a , axis = 1))结果：123[1 2 2 1][1 0 2] 其余更多维度的都是大同小异]]></content>
      <tags>
        <tag>待补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K-Nearest_Neighbors_Algorithm]]></title>
    <url>%2F2019%2F12%2F18%2FK-Nearest-Neighbors-Algorithm%2F</url>
    <content type="text"><![CDATA[KNNKNN是一种无监督机器学习算法，算法假定相似的事物彼此接近，其中，用‘距离’来表征事物的相似性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import mathimport numpy as npdef KNN(data , quary , k , distance_fn , choice_fn): neighbor_distance_and_index = [] for index, example in enumerate(data): distance = distance_fn(example[:-1] , quary) #将要预测的 quary 与 data 里的每一个值进行 #距离计算 neighbor_distance_and_index.append((distance , index)) sorted_neighbor_diatance_and_index = sorted(neighbor_distance_and_index) #将距离排序 k_nearest_distance_and_index = sorted_neighbor_diatance_and_index[:k] #取出前k个最相似的值 k_nearset_labels = [data[i][1] for distance , i in k_nearest_distance_and_index] return k_nearest_distance_and_index , choice_fn(k_nearset_labels)def mean(labels): #将最终结果取平均值 return sum(labels) / len(labels)def euclidean_distance(example , quary): #用欧式距离 sum_euclidean_distance = 0 for i in range(len(example)): sum_euclidean_distance += math.pow(example[i]- quary[i] , 2) #当(example[i]- quary[i]) 的输入不是单一值而是张量之间的运算时，不能用math #而用 #sum_euclidean_distance += np.sum((example[i]- quary[i]) ** 2 , dim = ) dim 是维度 return math.sqrt(sum_euclidean_distance) #return np.sqrt(sum_euclidean_distance)def main(): reg_data = [ [65.75, 112.99], [71.52, 136.49], [69.40, 153.03], [68.22, 142.34], [67.79, 144.30], [68.70, 123.30], [69.80, 141.49], [70.01, 136.46], [67.90, 112.37], [66.49, 127.45], ] reg_quary = [60] reg_k_nearest_neighbors, reg_prediction = KNN(reg_data , reg_quary , k = 2 , distance_fn = euclidean_distance , choice_fn = mean) print(reg_prediction)if __name__ == '__main__': main() 如果k=1，那么模型预测误差就很大，而增加k的值，由于进行多次投票，最终预测变得稳定]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>-Machine Learning Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线型表]]></title>
    <url>%2F2019%2F11%2F25%2F%E7%BA%BF%E5%9E%8B%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线型表的顺序表示和实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;iostream&gt;#include&lt;stdio.h&gt;#define LIST_INIT_SIZE 100#define List_Increament 10 //当容量不够时每次增加的容量大小using namespace std;typedef struct SqList&#123; int *data; int length; int listsize; //线型表的容量&#125;S;bool Init(SqList &amp;L)&#123; L.data = (int *)malloc(LIST_INIT_SIZE * sizeof(int)); if(!L.data) return false; L.length = 0; L.listsize = LIST_INIT_SIZE; return true;&#125;// 在第i+1的位置上插入ebool Insert(SqList &amp;L , int i , int e)&#123; if(i &lt; 0 || i &gt; L.length)&#123; return false; &#125; if(L.length &gt; L.listsize)&#123; int *newsize = (int *)realloc(L.data , (L.listsize + List_Increament) * sizeof(int)); if(!newsize) return false; L.data = newsize; L.listsize += List_Increament; &#125; int *q = &amp;(L.data[i]); for(int *p = &amp;(L.data[L.length - 1]) ; p &gt;= q ; --p)&#123; *(p+1) = *p; &#125; *q = e; L.length++; return true;&#125;// 在i+1 的位置上删除元素，放入e中bool Delete(SqList &amp;L , int i , int &amp;e)&#123; if(i &lt; 0 || i &gt;= L.length)&#123; return false; &#125; int *p = &amp;(L.data[i]); e = L.data[i]; for(int *q = &amp;(L.data[i]) ; q &lt; &amp;(L.data[L.length-1]) ; ++q)&#123; *q = *(q+1); &#125; --L.length; return true;&#125;//合并线型表L1 和 L2 ，放入 L3中, 假设L1和L2均为降序排列，得到的L3也要降序排列bool MergeList(SqList &amp;L1 , SqList &amp;L2 , SqList &amp;L3)&#123; int *p1 = L1.data; int *p2 = L2.data; L3.length = L1.length + L2.length; L3.listsize = L1.listsize + L2.listsize; L3.data = (int *)malloc(L3.listsize * sizeof(int)); int *p3 = L3.data; if(!L3.data) return false; while(p1 &lt;= (L1.data + L1.length - 1) &amp;&amp; p2 &lt;= (L2.data + L2.length - 1))&#123; if(*p1 &gt; *p2)&#123; *p3 = *p1; *p3++ , *p1++; &#125; else &#123; *p3 = *p2; *p3++ , *p2++; &#125; &#125; while(p1 &lt;= (L1.data + L1.length - 1))&#123; *p3 = *p1; *p3++ , *p1++; &#125; while(p2 &lt;= (L2.data + L2.length - 1))&#123; *p3 = *p2; *p3++ , *p2++; &#125; return true;&#125;int main()&#123; //合并 SqList L1 , L2 , L3; Init(L1); Init(L2); Init(L3); for(int i = 0 ; i&lt;5 ; ++i)&#123; int a; cin&gt;&gt;a; Insert(L1 , i , a); &#125; for(int i = 0 ; i&lt;5 ; ++i)&#123; int a; cin&gt;&gt;a; Insert(L2 , i , a); &#125; MergeList(L1 , L2 , L3); for(int i = 0 ; i&lt;L3.length ; ++i)&#123; cout&lt;&lt;L3.data[i]&lt;&lt;' '; &#125; //插入、删除 SqList s; Init(s); for(int i = 0 ; i&lt;10 ; ++i)&#123; int a; cin&gt;&gt;a; Insert(s , i , a); &#125; for(int i = 0 ; i&lt;10 ; ++i)&#123; cout&lt;&lt;s.data[i]&lt;&lt;' '; &#125; cout&lt;&lt;endl; Insert(s , 5 , 1000); for(int i = 0 ; i&lt;s.length ; ++i)&#123; cout&lt;&lt;s.data[i]&lt;&lt;' '; &#125; int e; Delete(s , 5 , e); Delete(s , 3 , e); cout&lt;&lt;endl; cout&lt;&lt;e&lt;&lt;endl; for(int i = 0 ; i&lt;s.length ; ++i)&#123; cout&lt;&lt;s.data[i]&lt;&lt;' '; &#125;&#125; 线型表的链式表示和实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;iostream&gt;#include&lt;stdio.h&gt;#define LIST_INIT_SIZE 100#define List_Increament 10using namespace std;typedef struct LNode &#123; int data; LNode *next;&#125;LNode , *LinkList;//建立一个有n个节点的链表void CreateList(LinkList &amp;L , int n)&#123; L = (LinkList)malloc(sizeof(LNode)); L-&gt;next = NULL; for(int i = 0 ; i&lt;n ; ++i)&#123; LinkList p = (LinkList)malloc(sizeof(LNode)); cin&gt;&gt;p-&gt;data; p-&gt;next = L-&gt;next; // 头插法 L-&gt;next = p; &#125;&#125;//在第i个位置之前插入 ebool Insert(LinkList &amp;L , int i , int e)&#123; LinkList p = L; for(int j = 0 ; j&lt;i-1 ; ++j)&#123; if(p == NULL) return false; p = p-&gt;next; &#125; LinkList q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = e; q-&gt;next = p-&gt;next; p-&gt;next = q; return true;&#125;//删除第i个节点bool Delete(LinkList &amp;L , int i , int &amp;e)&#123; LinkList p = L; for(int j = 0 ; j&lt;i-1 ; ++j)&#123; if(!p) return false; p = p-&gt;next; &#125; LinkList q = p-&gt;next; e = p-&gt;next-&gt;data; p-&gt;next = p-&gt;next-&gt;next; free(q); return true;&#125;void print(LinkList L)&#123; LinkList p = L-&gt;next; while(p)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;' '; p = p-&gt;next; &#125; cout&lt;&lt;endl;&#125;// L1和L2中均为降序排列，合并后的L3中的也为降序void MergeList(LinkList &amp;L1 , LinkList &amp;L2 , LinkList &amp;L3)&#123; LinkList p1 = L1-&gt;next , p2 = L2-&gt;next; LinkList p3 = L3 = L1; // 将L1的头结点作为L3的头结点 while(p1 &amp;&amp; p2)&#123; if(p1-&gt;data &gt; p2-&gt;data)&#123; p3-&gt;next = p1; p3 = p3-&gt;next; p1 = p1-&gt;next; &#125; else &#123; p3-&gt;next = p2; p3 = p3-&gt;next; p2 = p2-&gt;next; &#125; &#125; p3-&gt;next = p1 ? p1 : p2; free(L2);&#125;int main()&#123; LinkList L1 , L2 , L3; int n; cin&gt;&gt;n; CreateList(L1 , n); CreateList(L2 , n); print(L1); print(L2); MergeList(L1 , L2 , L3); print(L3);&#125; 单向循环链表1234567891011//没什么不一样的，就变了L-&gt;next = L; 而且其他函数的终止条件不可以是p-&gt;next == NULL，而是是否等于头指针void CreateList(LinkList &amp;L , int n)&#123; L = (LinkList)malloc(sizeof(LNode)); L-&gt;next = L; for(int i = 0 ; i&lt;n ; ++i)&#123; LinkList p = (LinkList)malloc(sizeof(LNode)); cin&gt;&gt;p-&gt;data; p-&gt;next = L-&gt;next; L-&gt;next = p; &#125;&#125; 循环双向链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;stdio.h&gt;#define LIST_INIT_SIZE 100#define List_Increament 10using namespace std;typedef struct DuLNode &#123; int data; DuLNode *prior; DuLNode *next;&#125;DuLNode , *DuLinkList;void CreateList(DuLinkList &amp;L , int n)&#123; L = (DuLinkList)malloc(sizeof(DuLNode)); L-&gt;next = L; L-&gt;prior = L; for(int i = 0 ; i&lt;n ; ++i)&#123; DuLinkList p = (DuLinkList)malloc(sizeof(DuLNode)); cin&gt;&gt;p-&gt;data; p-&gt;next = L-&gt;next; L-&gt;next-&gt;prior = p; p-&gt;prior = L; L-&gt;next = p; &#125;&#125;// 在i位置之前插入evoid Insert(DuLinkList &amp;L , int i , int e)&#123; DuLinkList q = L; DuLinkList p = (DuLinkList)malloc(sizeof(DuLNode)); p-&gt;data = e; for(int j = 0 ; j&lt;i - 1 ; ++j)&#123; q = q-&gt;next; &#125; p-&gt;next = q-&gt;next; q-&gt;next-&gt;prior = p; p-&gt;prior = q; q-&gt;next = p;&#125;// 删除i位置的结点void Delete(DuLinkList &amp;L , int i , int &amp;e)&#123; DuLinkList p = L; for(int j = 0 ; j&lt;i ; ++j)&#123; p = p-&gt;next; &#125; e = p-&gt;data; p-&gt;next-&gt;prior = p-&gt;prior; p-&gt;prior-&gt;next = p-&gt;next; free(p);&#125;void print(DuLinkList L)&#123; DuLinkList p = L-&gt;next; while(p != L)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;' '; p = p-&gt;next; &#125; cout&lt;&lt;endl; p = p-&gt;prior; while(p != L)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;' '; p = p-&gt;prior; &#125; cout&lt;&lt;endl;&#125;int main()&#123; DuLinkList L; int n; cin&gt;&gt;n; CreateList(L , n); print(L); int e; cin&gt;&gt;e; Insert(L , 3 , e); print(L); Delete(L , 2 , e); print(L); cout&lt;&lt;e;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>-线型表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的基本操作的实现]]></title>
    <url>%2F2019%2F10%2F28%2F%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[图的三种表示方法图的数组表示法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include&lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;#define MAX_NUM 20#define INFINITY INT_MAXtypedef int VRType;typedef char VertexType;typedef enum&#123;DG , DN , UDG , UDN&#125; GraphKind; //&#123;有向图，有向网，无向图，无向网&#125;typedef struct ArcCell&#123; VRType adj; // 无权图是0和1, 有权图是权值 //InfoType *info;&#125;ArcCell , AdjMatrix[MAX_NUM][MAX_NUM];typedef struct &#123; VertexType vexs[MAX_NUM]; //顶点名称 AdjMatrix arcs; //邻接矩阵 int vexnum , arcnum; //顶点数 和 弧数 //GraphKind kind; //图的类型&#125;MGraph;// 返回顶点在图中的位置 intint LocateVex(MGraph G , VertexType v)&#123; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; if(G.vexs[i] == v)&#123; return i; &#125; &#125;&#125;// 无向网 void CreateUDN(MGraph &amp;G)&#123; //scanf(&amp;G.kind); cout&lt;&lt;"构造无向网："&lt;&lt;endl; cout&lt;&lt;"输入图的顶点数和边数："&lt;&lt;endl; cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; cout&lt;&lt;"输入顶点名称："&lt;&lt;endl; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; cin&gt;&gt;G.vexs[i]; &#125; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; G.arcs[i][j].adj = INFINITY; &#125; &#125; cout&lt;&lt;"输入顶点及其权值："&lt;&lt;endl; for(int k = 0 ; k&lt;G.arcnum ; ++k)&#123; VertexType v1 , v2; int w; cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; int i = LocateVex(G , v1); int j = LocateVex(G , v2); G.arcs[i][j].adj = w; G.arcs[j][i].adj = G.arcs[i][j].adj; &#125;&#125;// 有向网 (其实就是无向图去掉了最后一个语句)void CreateDN(MGraph &amp;G)&#123; cout&lt;&lt;"构造有向网："&lt;&lt;endl; cout&lt;&lt;"输入图的顶点数和边数："&lt;&lt;endl; cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; cout&lt;&lt;"输入顶点名称："&lt;&lt;endl; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; cin&gt;&gt;G.vexs[i]; &#125; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; G.arcs[i][j].adj = INFINITY; &#125; &#125; cout&lt;&lt;"输入顶点及其权值："&lt;&lt;endl; for(int k = 0 ; k&lt;G.arcnum ; ++k)&#123; VertexType v1 , v2; int w; cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; int i = LocateVex(G , v1); int j = LocateVex(G , v2); G.arcs[i][j].adj = w; //G.arcs[j][i].adj = G.arcs[i][j].adj; &#125;&#125;// 图的打印void print(MGraph G)&#123; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; if(G.arcs[i][j].adj != INFINITY)&#123; cout&lt;&lt;'('&lt;&lt;G.vexs[i]&lt;&lt;','&lt;&lt;G.vexs[j]&lt;&lt;')'&lt;&lt;' '; &#125; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; if(G.arcs[i][j].adj == INFINITY)&#123; cout&lt;&lt;0&lt;&lt;' '; &#125; else cout&lt;&lt;G.arcs[i][j].adj&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125;&#125;void InsertVex(MGraph &amp;G , VertexType v)&#123; G.vexnum++; G.vexs[G.vexnum - 1] = v; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; G.arcs[i][G.vexnum - 1].adj = INFINITY; &#125; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; G.arcs[G.vexnum - 1][j].adj = INFINITY; &#125;&#125;void InsertArc(MGraph &amp;G , VertexType v , VertexType w)&#123; int i = LocateVex(G , v); int j = LocateVex(G , w); if(i == -1)&#123; G.vexnum++; G.vexs[G.vexnum - 1] = v; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; G.arcs[i][G.vexnum - 1].adj = INFINITY; &#125; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; G.arcs[G.vexnum - 1][j].adj = INFINITY; &#125; i = G.vexnum - 1; &#125; if(j == -1)&#123; G.vexnum++; G.vexs[G.vexnum - 1] = w; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; G.arcs[i][G.vexnum - 1].adj = INFINITY; &#125; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; G.arcs[G.vexnum - 1][j].adj = INFINITY; &#125; j = G.vexnum - 1; &#125; G.arcs[i][j].adj = 1; G.arcs[j][i].adj = 1; G.arcnum++;&#125;bool DeleteVex(MGraph &amp;G , VertexType v)&#123; int l = LocateVex(G , v); cout&lt;&lt;l&lt;&lt;endl; if(l == -1)&#123; cout&lt;&lt;"No such point!"&lt;&lt;endl; return false; &#125; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; if(G.arcs[i][l].adj != INFINITY)&#123; G.arcs[i][l].adj = INFINITY; G.arcnum--; &#125; &#125; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; if(G.arcs[l][j].adj != INFINITY)&#123; G.arcnum--; G.arcs[l][j].adj = INFINITY; &#125; &#125; for(int i = l+1 ; i&lt;G.vexnum ; ++i)&#123; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; G.arcs[i-1][j].adj = G.arcs[i][j].adj; &#125; &#125; for(int j = l+1 ; j&lt;G.vexnum ; ++j)&#123; for(int i = 0 ; i&lt;G.vexnum - 1 ; ++i)&#123; G.arcs[i][j-1].adj = G.arcs[i][j].adj; &#125; &#125; for(int i = l+1 ; i&lt;G.vexnum ; ++i)&#123; G.vexs[i-1] = G.vexs[i]; &#125; G.vexnum--; return true;&#125;bool DeleteArc(MGraph &amp;G , VertexType v , VertexType w)&#123; int i = LocateVex(G , v); int j = LocateVex(G , w); G.arcnum--; G.arcs[i][j].adj = INFINITY; G.arcs[j][i].adj = INFINITY;&#125;int main()&#123; MGraph G; CreateDN(G); print(G);&#125; 图的邻接表表示法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;#define MAX_NUM 20#define INFINITY INT_MAXtypedef char VertexType;//表结点typedef struct ArcNode &#123; int adjvex; //表示头结点的邻接点的序号 ArcNode *nextarc; //指向表示头结点的下一个邻接点 int weight; //无权图是0,1 有权图是权值 //InfoType *info;&#125;ArcNode;//头结点typedef struct VNode &#123; VertexType data; //表示头结点的data ArcNode *firstarc; //指向头结点的第一个邻接点&#125;VNode , AdjList[MAX_NUM];typedef struct&#123; AdjList vertices; //表结点的数组 int vexnum , arcnum; //顶点数和边数&#125;ALGraph;int LocateVex(ALGraph *G , VertexType v)&#123; for(int i = 0 ; i&lt;G-&gt;vexnum ; ++i)&#123; if(G-&gt;vertices[i].data == v)&#123; return i; &#125; &#125;&#125;void Create(ALGraph *G)&#123; cout&lt;&lt;"输入图的顶点数和边数："&lt;&lt;endl; cin&gt;&gt;G-&gt;vexnum&gt;&gt;G-&gt;arcnum; cout&lt;&lt;"输入顶点信息："&lt;&lt;endl; for(int i = 0 ; i&lt;G-&gt;vexnum ; ++i)&#123; cin&gt;&gt;G-&gt;vertices[i].data; G-&gt;vertices[i].firstarc = NULL; &#125; cout&lt;&lt;"输入(v1,v2,w)："&lt;&lt;endl; for(int k = 0 ; k&lt;G-&gt;arcnum ; ++k)&#123; VertexType v1 , v2; int w; cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; int i = LocateVex(G , v1); int j = LocateVex(G , v2); ArcNode *p = (ArcNode *)malloc(sizeof(ArcNode)); p-&gt;adjvex = j; p-&gt;nextarc = G-&gt;vertices[i].firstarc; G-&gt;vertices[i].firstarc = p; p-&gt;weight = w; //下面代码无向图有，有向图无 p = (ArcNode *)malloc(sizeof(ArcNode)); p-&gt;adjvex = i; p-&gt;nextarc = G-&gt;vertices[j].firstarc; G-&gt;vertices[j].firstarc = p; p-&gt;weight = w; &#125; //打印图 for(int i = 0 ; i&lt;G-&gt;vexnum ; ++i)&#123; ArcNode *p = G-&gt;vertices[i].firstarc; while(p)&#123; cout&lt;&lt;'('&lt;&lt;G-&gt;vertices[i].data&lt;&lt;','&lt;&lt;G-&gt;vertices[p-&gt;adjvex].data&lt;&lt;','&lt;&lt;p-&gt;weight&lt;&lt;')'&lt;&lt;' '; p = p-&gt;nextarc; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; ALGraph G; Create(&amp;G);&#125; 图的十字链表表示法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;#define MAX_NUM 20#define INFINITY INT_MAXtypedef char VertexType;//表结点typedef struct ArcBox&#123; int tailvex , headvex; //表示弧尾 和 弧头 的下标位置 ArcBox *hlink , *tlink; //hlink 指向头结点入度相同的表结点(即弧头相同), //tlink指向弧尾相同的表结点 //InfoType *info;&#125;ArcBox;typedef struct VexNode&#123; VertexType data; //头结点的数据信息 ArcBox *fristin , *fristout;// fristin 指向头结点的第一个入度的表结点， // fristout指向头结点的第一个出度的表结点&#125;VexNode;typedef struct &#123; VexNode xlist[MAX_NUM]; int vexnum , arcnum; //顶点数和边数&#125;OLGraph;int LocateVex(OLGraph G , VertexType v)&#123; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; if(G.xlist[i].data == v)&#123; return i; &#125; &#125;&#125;//构造有向图void CreateDG(OLGraph &amp;G)&#123; cout&lt;&lt;"输入图的顶点数和边数："&lt;&lt;endl; cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; cout&lt;&lt;"输入图的头结点的数据信息："&lt;&lt;endl; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; cin&gt;&gt;G.xlist[i].data; G.xlist[i].fristin = NULL; G.xlist[i].fristout = NULL; &#125; cout&lt;&lt;"输入(v1,v2)："&lt;&lt;endl; for(int k = 0 ; k&lt;G.arcnum ; ++k)&#123; VertexType v1 , v2; cin&gt;&gt;v1&gt;&gt;v2; int i = LocateVex(G , v1); int j = LocateVex(G , v2); ArcBox *p = (ArcBox *)malloc(sizeof(ArcBox)); p-&gt;tailvex = i; p-&gt;headvex = j; p-&gt;hlink = G.xlist[j].fristin; p-&gt;tlink = G.xlist[i].fristout; G.xlist[j].fristin = G.xlist[i].fristout = p; &#125; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; ArcBox *p =G.xlist[i].fristout; while(p)&#123; cout&lt;&lt;'('&lt;&lt;G.xlist[i].data&lt;&lt;"-&gt;"&lt;&lt;G.xlist[p-&gt;headvex].data&lt;&lt;')'&lt;&lt;' '; p = p-&gt;tlink; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;"---------------------------------------------"&lt;&lt;endl; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; ArcBox *p = G.xlist[i].fristin; while(p)&#123; cout&lt;&lt;'('&lt;&lt;G.xlist[i].data&lt;&lt;"&lt;-"&lt;&lt;G.xlist[p-&gt;tailvex].data&lt;&lt;')'&lt;&lt;' '; p = p-&gt;hlink; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; OLGraph G; CreateDG(G);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>待补充</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的实现]]></title>
    <url>%2F2019%2F09%2F29%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[二叉树的递归实现(链表)常规遍历方式实现了二叉树的生成以及三种遍历方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;#define OK true;#define ERROR false;typedef struct BiTNode&#123; char data; BiTNode *lchild , *rchild;&#125;BiTNode , *BiTree;//构造树bool CreatBiTree(BiTree &amp;T)&#123; char ch; cin&gt;&gt;ch; if(ch == '#') T = NULL; else&#123; T = (BiTree)malloc(sizeof(BiTNode)); if(!T) return ERROR; T-&gt;data = ch; // 生成根节点 CreatBiTree(T-&gt;lchild); //生成左子树 CreatBiTree(T-&gt;rchild); //生成右子树 &#125; return OK;&#125;//前序遍历void PreOrder(BiTree T)&#123; if(T)&#123; cout&lt;&lt;T-&gt;data&lt;&lt;' '; PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); &#125;&#125;//中序遍历void InOrder(BiTree T)&#123; if(T)&#123; InOrder(T-&gt;lchild); cout&lt;&lt;T-&gt;data&lt;&lt;' '; InOrder(T-&gt;rchild); &#125;&#125;//后序遍历void PostOrder(BiTree T)&#123; if(T)&#123; PostOrder(T-&gt;lchild); PostOrder(T-&gt;rchild); cout&lt;&lt;T-&gt;data&lt;&lt;' '; &#125;&#125;//层序遍历queue&lt;BiTree&gt; q;void level_order(BiTree t)&#123; q.push(t); while(!q.empty())&#123; if(t-&gt;lchild)&#123; q.push(t-&gt;lchild); &#125; if(t-&gt;rchild)&#123; q.push(t-&gt;rchild); &#125; cout&lt;&lt;q.front()-&gt;data&lt;&lt;' '; q.pop(); t = q.front(); &#125;&#125;int main()&#123; BiTree T; CreatBiTree(T); PreOrder(T); cout&lt;&lt;endl; InOrder(T); cout&lt;&lt;endl; PostOrder(T);&#125; 已知后序、中序遍历，求层序遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;typedef struct BiNode&#123; int data; BiNode *left , *right;&#125;BiNode , *BiTree;void order(vector&lt;int&gt; post_v , vector&lt;int&gt; in_v , BiTree &amp;tree)&#123; if(!in_v.size()) &#123; tree = NULL; return; &#125; vector&lt;int&gt;::iterator iter = find(in_v.begin() , in_v.end() , *(post_v.end() - 1)); int position = iter - in_v.begin(); tree = (BiTree)malloc(sizeof(BiNode)); tree-&gt;data = *iter; vector&lt;int&gt; v1(post_v.begin() , post_v.begin() + position); vector&lt;int&gt; v2(in_v.begin() , in_v.begin() + position); vector&lt;int&gt; v3(post_v.begin() + position , post_v.end() - 1); vector&lt;int&gt; v4(in_v.begin() + position + 1 , in_v.end()); order(v1 , v2 , tree-&gt;left); order(v3 , v4 , tree-&gt;right);&#125;queue&lt;BiTree&gt; q;void level_order(BiTree t)&#123; q.push(t); while(!q.empty())&#123; if(t-&gt;left)&#123; q.push(t-&gt;left); &#125; if(t-&gt;right)&#123; q.push(t-&gt;right); &#125; cout&lt;&lt;q.front()-&gt;data; q.pop(); if(!q.empty())&#123; cout&lt;&lt;' '; &#125; t = q.front(); &#125;&#125;int main()&#123; freopen("input.txt","r",stdin); //freopen("output.txt","w",stdout); int n; cin&gt;&gt;n; vector&lt;int&gt; post_v , in_v; for(int i = 0 ; i&lt;n ; ++i)&#123; int a; cin&gt;&gt;a; post_v.push_back(a); &#125; for(int i = 0 ; i&lt;n ; ++i)&#123; int a; cin&gt;&gt;a; in_v.push_back(a); &#125; BiTree tree; order(post_v , in_v , tree); level_order(tree);&#125; 二叉树的非递归算法(链表)实现了二叉树的三种遍历方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;#define OK true;#define ERROR false;typedef struct BiTNode&#123; char data; BiTNode *lchild , *rchild;&#125;BiTNode , *BiTree;typedef struct Stack&#123; BiTree data; Stack *Next;&#125;Stack , *StackList;typedef struct&#123; StackList base; StackList top;&#125;ListStack;bool InitStack(ListStack &amp;s)&#123; s.base = (StackList)malloc(sizeof(Stack)); if(!s.base) return ERROR; s.top = s.base; s.top-&gt;Next = NULL; return OK;&#125;bool push(ListStack &amp;s , BiTree T)&#123; StackList p = (StackList)malloc(sizeof(Stack)); if(!p) return ERROR; p-&gt;data = T; p-&gt;Next = s.top; s.top = p; return OK;&#125;bool pop(ListStack &amp;s)&#123; if(s.top == s.base) return ERROR; StackList p = s.top; s.top = p-&gt;Next; free(p); return OK;&#125;BiTree getTop(ListStack &amp;s)&#123; return s.top-&gt;data;&#125;bool isEmpty(ListStack &amp;s)&#123; if(s.base == s.top) return true; else return false;&#125;//构造树bool CreatBiTree(BiTree &amp;T)&#123; char ch; cin&gt;&gt;ch; if(ch == '#') T = NULL; else&#123; T = (BiTree)malloc(sizeof(BiTNode)); if(!T) return ERROR; T-&gt;data = ch; // 生成根节点 CreatBiTree(T-&gt;lchild); //生成左子树 CreatBiTree(T-&gt;rchild); //生成右子树 &#125; return OK;&#125;void PreOrder(BiTree T)&#123; ListStack s; InitStack(s); while(T || !isEmpty(s))&#123; while(T)&#123; cout&lt;&lt;T-&gt;data&lt;&lt;' '; push(s , T); T = T-&gt;lchild; &#125; if(!isEmpty(s))&#123; T = getTop(s); pop(s); T = T-&gt;rchild; &#125; &#125; cout&lt;&lt;endl;&#125;void InOrder(BiTree T)&#123; ListStack s; InitStack(s); while(T || !isEmpty(s))&#123; while(T)&#123; push(s , T); T = T-&gt;lchild; &#125; if(!isEmpty(s))&#123; T = getTop(s); pop(s); cout&lt;&lt;T-&gt;data&lt;&lt;' '; T = T-&gt;rchild; &#125; &#125; cout&lt;&lt;endl;&#125;void PostOrder(BiTree T)&#123; ListStack s; InitStack(s); int flag = 1; // 用来判断是否进入右子树 BiTree p; if(T)&#123; do&#123; while(T)&#123; push(s , T); T = T-&gt;lchild; &#125; flag = 1; p = NULL; while(!isEmpty(s) &amp;&amp; flag == 1)&#123; T = getTop(s); // 因为经过第一个while循环，T = NULL,所以要把他变回来 if(T-&gt;rchild == p)&#123; cout&lt;&lt;T-&gt;data&lt;&lt;' '; p = T; //用于判断此节点的右孩子是否已经被访问，或者是没有右孩子 pop(s); &#125; else &#123; T = T-&gt;rchild; flag = 0; &#125; &#125; &#125;while(!isEmpty(s)); &#125; cout&lt;&lt;endl;&#125;int main()&#123; BiTree T; CreatBiTree(T); PreOrder(T); InOrder(T); PostOrder(T);&#125; 线索二叉树中序遍历的实现线索二叉树的初始化与普通二叉树相比，多了一个指示域：LTag和RTag，如果值是Link，那么有左孩子或右孩子，如果是Thread，那么有前驱或后继。123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;#define OK true;#define ERROR false;typedef enum PointerTag&#123; // 声明PointTag为枚举类型 Link, Thread&#125;;typedef struct BiThrNode&#123; char data; BiThrNode *lchild , *rchild; PointerTag LTag , RTag;&#125;BiThrNode , *BiThrTree;bool CreatBiTree(BiThrTree &amp;T)&#123; char ch; cin&gt;&gt;ch; if(ch == '#') T = NULL; else&#123; T = (BiThrTree)malloc(sizeof(BiThrNode)); if(!T) return ERROR; T-&gt;data = ch; // 生成根节点 T-&gt;LTag = Link; T-&gt;RTag = Link; CreatBiTree(T-&gt;lchild); //生成左子树 CreatBiTree(T-&gt;rchild); //生成右子树 &#125; return OK;&#125; 遍历在线索树上遍历，只需找到要遍历的第一个节点，然后依次按照三种遍历方式的规定找后继就可以了。要遍历线索树，就要把普通的二叉树线索化，就是按照规定把空指针改为前驱或后继，所以三种遍历方式的线索化操作是不同的。 中序遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263BiThrTree pre;//中序遍历线索化void InThreading(BiThrTree p)&#123; if(p)&#123; InThreading(p-&gt;lchild); // 左子树进行线索化 //基本操作 if(!p-&gt;lchild) &#123; // 左子树为空 p-&gt;LTag = Thread; // 修改左指示为前驱 p-&gt;lchild = pre; // 修改左孩子为前驱 &#125; if(!pre-&gt;rchild)&#123; pre-&gt;RTag = Thread; pre-&gt;rchild = p; &#125; pre = p; InThreading(p-&gt;rchild); // 右子树线索化 &#125;&#125;bool InOrderThreading(BiThrTree &amp;Thrt , BiThrTree T)&#123; //中序遍历T, 将其线索化，Thrt指向头结点 Thrt = (BiThrTree)malloc(sizeof(BiThrNode)); if(!Thrt) return ERROR; Thrt-&gt;LTag = Link; //建立头结点 Thrt-&gt;RTag = Thread; Thrt-&gt;rchild = Thrt; if(!T) Thrt-&gt;lchild = Thrt; // 如果是空树 else &#123; Thrt-&gt;lchild = T; pre = Thrt; //pre 为p 的前驱 InThreading(T); // 线索化 pre-&gt;rchild = Thrt; pre-&gt;RTag = Thread; Thrt-&gt;rchild = pre; &#125; return OK;&#125;// 非递归void InOrderPrint(BiThrTree Thrt)&#123; BiThrTree p = Thrt-&gt;lchild; // Thrt 是头结点，没有值 while(p != Thrt)&#123; // 如果是空树或遍历完毕时， p== Thrt while(p-&gt;LTag == Link) p = p-&gt;lchild; // 先找到遍历每个子树的第一个节点 cout&lt;&lt;p-&gt;data; while(p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != Thrt)&#123; // 如果有后继，并且不是最后一个节点 p = p-&gt;rchild; // 指向他的后继 cout&lt;&lt;p-&gt;data; //输出后继 &#125; p = p-&gt;rchild; // 没有后继时，指向他的右孩子，然后继续执行到右子树的要遍历的第一个节点 &#125; cout&lt;&lt;endl;&#125;int main()&#123; BiThrTree T , Thrt; CreatBiTree(T); InOrderThreading(Thrt , T); InOrderPrint(Thrt);&#125; 前序遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566BiThrTree pre;void PreThreading(BiThrTree p)&#123; if(p)&#123; if(!p-&gt;lchild)&#123; p-&gt;lchild = pre; p-&gt;LTag = Thread; &#125; if(!pre-&gt;rchild)&#123; pre-&gt;rchild = p; pre-&gt;RTag = Thread; &#125; pre = p; if(p-&gt;LTag == Link)&#123; //这个判断条件必须加，不然会死循环 PreThreading(p-&gt;lchild); &#125; if(p-&gt;RTag == Link)&#123; PreThreading(p-&gt;rchild); &#125; &#125;&#125;// 与中序遍历相同bool PreOrderThreading(BiThrTree &amp;Thrt , BiThrTree T)&#123; //中序遍历T, 将其线索化，Thrt指向头结点 Thrt = (BiThrTree)malloc(sizeof(BiThrNode)); if(!Thrt) return ERROR; Thrt-&gt;LTag = Link; //建立头结点 Thrt-&gt;RTag = Thread; Thrt-&gt;rchild = Thrt; if(!T) Thrt-&gt;lchild = Thrt; // 如果是空树 else &#123; Thrt-&gt;lchild = T; pre = Thrt; //pre 为p 的前驱 PreThreading(T); // 线索化 pre-&gt;rchild = Thrt; pre-&gt;RTag = Thread; Thrt-&gt;rchild = pre; &#125; return OK;&#125;void PreOrderprint(BiThrTree T)&#123; BiThrTree p = T-&gt;lchild; while(p != T)&#123; cout&lt;&lt;p-&gt;data; if(p-&gt;LTag == Link)&#123; p = p-&gt;lchild; &#125; else &#123; p = p-&gt;rchild; &#125; &#125;&#125;int main()&#123; BiThrTree T , Thrt; CreatBiTree(T); PreOrderThreading(Thrt , T); PreOrderprint(Thrt);&#125; 后序遍历]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列的实现]]></title>
    <url>%2F2019%2F09%2F29%2F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[常规链队列的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;using namespace std;#define OK true;#define ERROR false;typedef struct QNode&#123; int data; QNode *Next;&#125;QNode , *QueuePtr;typedef struct&#123; QueuePtr Front; QueuePtr Rear;&#125;LinkQueue;bool Init(LinkQueue &amp;Q)&#123; Q.Front = Q.Rear = (QueuePtr)malloc(sizeof(QNode)); if(!Q.Front)&#123; return ERROR; &#125; Q.Front-&gt;Next = NULL; return OK;&#125;//插入bool Insert(LinkQueue &amp;Q , int e)&#123; QueuePtr p = (QueuePtr)malloc(sizeof(QNode)); if(!p)&#123; return ERROR; &#125; p-&gt;data = e; p-&gt;Next = NULL; Q.Rear-&gt;Next = p; Q.Rear = p; return OK;&#125;//删除bool Delete(LinkQueue &amp;Q , int &amp;e)&#123; if(Q.Front == Q.Rear) return ERROR; QueuePtr p = Q.Front-&gt;Next; e = p-&gt;data; Q.Front-&gt;Next = p-&gt;Next; if(Q.Rear == p) Q.Rear = Q.Front; //当队列中只有一个元素时 free(p); return OK;&#125;//遍历void print(LinkQueue Q)&#123; if(Q.Front == Q.Rear)&#123; cout&lt;&lt;"没有元素"&lt;&lt;endl; &#125; else &#123; Q.Front = Q.Front-&gt;Next; while(Q.Front)&#123; cout&lt;&lt;Q.Front-&gt;data&lt;&lt;' '; Q.Front = Q.Front-&gt;Next; &#125; &#125; cout&lt;&lt;endl;&#125;//销毁队列bool DestroyQueue(LinkQueue &amp;Q)&#123; while(Q.Front)&#123; Q.Rear = Q.Front-&gt;Next; free(Q.Front); Q.Front = Q.Rear; &#125; return OK;&#125;int main()&#123; LinkQueue Q; Init(Q); for(int i = 0 ; i&lt;5 ; ++i)&#123; int n; cin&gt;&gt;n; Insert(Q , n); &#125; print(Q); int e; Delete(Q , e); cout&lt;&lt;endl; cout&lt;&lt;e&lt;&lt;endl; print(Q); DestroyQueue(Q); print(Q);&#125; 循环队列的实现循环队列主要是针对队列的顺序存储结构，主要目的是避免顺序存储中的内存空间的浪费。 下面的这种方法少用一个储存空间。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;#define OK true;#define ERROR false;#define MAXSIZE 6typedef struct Queue&#123; int *base; int Front; int Rear;&#125;Queue;bool Init(Queue &amp;Q)&#123; Q.base = (int *)malloc(MAXSIZE * sizeof(int)); if(!Q.base) return ERROR; Q.Front = Q.Rear = 0; return OK;&#125;//队列长度int getLength(Queue &amp;Q)&#123; return (Q.Rear - Q.Front + MAXSIZE) % MAXSIZE;&#125;bool Insert(Queue &amp;Q , int e)&#123; if((Q.Rear + 1) % MAXSIZE == Q.Front) return ERROR; //队列满的标志 Q.base[Q.Rear] = e; Q.Rear = (Q.Rear + 1)%MAXSIZE; return OK;&#125;bool Delete(Queue &amp;Q , int &amp;e)&#123; if(Q.Front == Q.Rear) return ERROR; //队列空的标志 e = Q.base[Q.Front]; Q.Front = (Q.Front + 1)%MAXSIZE; return OK;&#125;void print(Queue Q)&#123; if(Q.Front == Q.Rear) cout&lt;&lt;"队列空"&lt;&lt;endl; else &#123; while((Q.Front + 1)%MAXSIZE != Q.Rear)&#123; cout&lt;&lt;Q.base[Q.Front]&lt;&lt;' '; Q.Front = Q.Front+1; &#125; cout&lt;&lt;Q.base[Q.Front]; &#125; cout&lt;&lt;endl;&#125;int main()&#123; Queue Q; Init(Q); for(int i = 0 ; i&lt;5 ; ++i)&#123; int n; cin&gt;&gt;n; bool a; a = Insert(Q , n); cout&lt;&lt;a&lt;&lt;' '; &#125; int e; cout&lt;&lt;endl; cout&lt;&lt;getLength(Q)&lt;&lt;endl; print(Q); //cout&lt;&lt;Q.Front&lt;&lt;' '&lt;&lt;Q.Rear&lt;&lt;endl; Delete(Q , e); cout&lt;&lt;e&lt;&lt;endl; print(Q); cout&lt;&lt;getLength(Q)&lt;&lt;endl; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于CenterNet的理解]]></title>
    <url>%2F2019%2F09%2F27%2FCenterNet%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Introduction在CenterNet中，作者找到了更简单、更有效的方法，作者用bbox的中心点来代替此物体，其他特征，比如物体大小，维度，姿态等等则从物体中心点位置的图像特征来直接回归，所以目标检测就变成了关键点的预测问题。一开始将图像输入到一个全卷积中，然后生成一个热图，热图中的峰值就对应于物体的中心点，每个峰值的图像特征就用于预测物体bbox的高和宽，训练用标准的密集监督学习，推理过程是一个单一的向前传播，没有NMS的后处理。 Related workCenterNet方法近似相当于锚点为基准的one-stage方法。 CenterNet仅仅根据位置来分配’anchor’，而不是根据框重叠，也就是说，CenterNet的’anchor’仅仅会出现在当前目标的位置处而不是在整个图上都分配，所以不用手动调阈值来看框是正类还是负类； 每个物体只有一个正框，所以不需要NMS来后处理，只需要在关键点热图上提取峰值； CenterNet输出的下采样因子是4，所以输出分辨率相比其他框架来说更大，这样就消除了对于多重锚点的需求； 疑问：多重锚点是什么意思？？（原文是‘This eliminates the need for multiple anchors’） Preliminary假设输入图像的维度为(3 , W , H)，那么目标就是生成一个热图，Y∈[0,1] ，其中Y的维度是(C , W/R , H/R)，C在目标检测中是类别，论文用coco数据集，所以C=80，论文中作者取R=4，表示下采样的步幅是4，那么为什么要生成这样一个热图呢，原来这个三维张量Y中的每一个值如果是1的话，那么代表这是检测的关键点，如果是0的话代表的是背景，所以Y的值要在0和1之间，表示概率，论文中用了几种不同的encoder-decoder networks来预测图像中的Y: Hourglass Network 带有转置卷积的ResNet 原始的DLA和作者改造后的DLA； 在训练过程中，CenterNet学习了CornerNet的方法，对于每个ground truth 的某一类C，我们需要把p(中心点)计算出来进行训练，计算方法为p = ((x1 + x2)/2 ，(y1 + y2)/2)，对于下采样后的坐标，我们设，其中R为下采样因子，并且向下取整，所以最终计算出来的中心点是对应低分辨率的中心点。有了中心点的坐标后，接下来的任务就是如何根据gt关键点的坐标来生成热图，作者用了一个高斯核来将计算好的关键点分布到如图中，其中 σp是一个对物体大小自适应的标准差。这样就生成了一个热图 疑问：px和py都是整数，那么x和px 在计算高斯核的时候是如何匹配的？？或者对于高斯核的理解一开始就是错的？？ 损失函数重点看一下损失函数： 中心点预测的损失函数 作者对于中心点位置和类别的预测是通过Focal-loss来进行逻辑回归的， α and β是超参数，论文中α=2，β=4，N是图像中关键点的个数，目的是将Focal-loss归一化。 疑问：N的数量是不多的，但是Lk是对所有的点来算损失函数的，那么为什么N可以将Focal-loss归一化？？ 目标中心的偏置损失 由于对于图像进行了R=4的下采样，但是中心点最终是要映射回原图的，这样会有精度损失，因此，对于每一个中心点，都额外采用一个局部偏移量，根据维度也可以看出，对于同一位置的所有类别，这个局部偏移量是共享的。注意上面的损失函数仅仅是对于关键点位置来算的，其他的点是要被忽略的。 疑问： 1. 中心点最终是如何映射到原图的？？是简单的乘4？？ 2. 为什么局部偏移量要对所有类进行共享？？是为了减少计算量？？ 3. 这个偏移量是在缩小后的图像上的偏移，但是在原图上的偏移和这个偏移应该是不一样的吧？？ 4. 回归的目的不就是为了减少偏移量吗？那为什么还要算偏移损失？？ 目标大小的损失 假设是Ck类的目标k的bbox，那么中心点的坐标就是pk = ，我们用Y^来预测所有的关键点，然后对每个目标k的size 进行回归，Sk = ，这是下采样后的长宽值，是预测值，由维度可知，这是所有的类别共享的size值。 疑问：为什么所有的类都在一个中心点出有相同的size？？ 总的损失函数为： 论文中 λsize = 0.1, λoff = 1。 最终每个坐标点产生C+4个数据，分别是类别、长宽和偏移量，这三个量是用一个单独的网络来预测出来的，并且所有的输出共享一个backbone网络。 推测阶段在预测阶段，首先对一张图像进行下采样，然后在下采样的特征图中对每个类预测中心点，然后就可以把输出图中每个类的热点单独提取出来，提取过程是什么呢，首先，可以检测当前热点的值是否比周围八个邻近的热点都大，然后提取出100个这样的点，方式是3x3的Maxpool，类似于NMS。最后，通过预测点算出来的Y^，代码中设置阈值为0.3，将这100个点中大于0.3的作为最终要的结果。这样，有了中心点的位置后就可以生产锚框了。即变成(x1 , y1 , x2 , y2)的锚框]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>待补充</tag>
        <tag>CenterNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Focal Loss的理解]]></title>
    <url>%2F2019%2F09%2F26%2FFocal-Loss%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[声明：这篇论文还未读，所以里面所有内容都是来自于各种网络大佬的理解，等自己读了论文后有待补充。 为什么要提出Focal-loss现在目标检测大概分为两种: one-stage和two-stage，one-stage虽然速度快，但是精度不如two-stage的，相反，two-stage虽然精度高，但是速度慢，后来Lin等人对于此问题的研究发现，one-stage的精度不高与训练时后景数据相比于前景数据少的多有很大原因，因此Lin等人通过对交叉熵损失函数进行修改，提了Focal-loss，即会特别关注某些Loss的意思。 论文分析了One-stage精度不高的原因 正负样本极度不均衡：anchor的生成是用类似于sliding-windows的方式，这会导致正负样本的比例接近1:1000，而且绝大多数负样本为“easy example”； 梯度优化过程中被easy example过度影响: 根据交叉熵损失函数，虽然easy example的Loss不高，但是数量多，所以在梯度优化时Loss函数会过度关注这些easy example，从而使得那些难以分类的类别得不到很好的训练。对于Focal-loss 的理解 首先回顾一下交叉熵损失函数：其中是经过激活函数的输出，在0-1之间，所以普通的交叉熵就是正样本的输出概率越大，那么Loss就越小，对于负样本，输出概率越小，Loss就越小。 再看加了gama后的Loss函数：在加入了gama后，就对难易样本的loss有了区分，对于正样本而言，如果输出为0.9，那么表明这个样本是容易训练的，所以Loss就变得比原来小，如果输出是0.5，表明难以训练，所以Loss就大，所以就使得Loss函数更加关注难训练的样本，所以减少了easy example的影响，论文实验发现gama=2是最优的。 Focal-loss的最终版本：α的加入实际上是使交叉熵加权，α一般设置为类别比例的倒数或者直接设为超参数(人为设定)，这样使得正样本(数量少)得到Loss的重视，从而减少负样本的影响。 为什么Focal loss没有用在two-stage上 two-stage会在生成区域建议阶段来使用NMS，使得候选框大量减少，在此过程中，减少了大量的背景框； 训练时用minibatch的采样策略，比如Faster-rcnn使用正负样本为1:3，这实际上起到了α 的作用。 感谢 https://www.sogou.com/link?url=hedJjaC291OoAuWay7Ycy8qCqnS5BeBJZpR6MQDH4jecmW7u2WhTZknbb2GMMgFg6KnxECbDvSOfABNiu1prjGiLSQm6y_cjIxl1zdOoaQG8NQzjFsXswHMpU5R1W7o9LJ3yweXqb0A4XXtlfpMI6PAjn7Fnn5gA https://www.cnblogs.com/king-lps/p/9497836.html]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Focal-Loss-OD</tag>
        <tag>待补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 简单教程]]></title>
    <url>%2F2019%2F09%2F08%2FMarkdown%2F</url>
    <content type="text"><![CDATA[区块元素 标题Markdown支持两种标题的语法 1.类Setext 形式利用底线的形式，利用=(表示最高阶题)，-（表示第二阶题）， 任何数量的 = 和 - 都可以有效果，例如：1234&gt; This is an H1&gt;=================&gt;This is an H2&gt;------------------2.类Atx形式则是利用#的数量从1到6来表示标题的阶，例如：123&gt;# This is H1&gt;## This is H2&gt;###### This is H6 区块引用先断好行，然后在每行前加&gt;，例如：1&gt;This is a blockquote 效果如下： This is a blockquote Markdown 也允许只在整个段落的第一行加 &gt; : 1&gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. 效果如下： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. 区块引用允许嵌套（引用内引用），根据层次不用加不同数量的&gt; ，例如： 1&gt;&gt;This is my House 效果如下： This is my House 引用区块也可以使用其他Markdown 语法，例如： 1234567&gt; ## This is H1&gt;&gt; 1. 这是第一行列表项&gt;&gt; 代码：&gt;&gt;（这里要有两个缩进）return shell_exec("echo $input | $markdown_script"); 效果如下： This is H11.这是第一行列表项 return shell_exec(&quot;echo $input | $markdown_script&quot;); 列表分为有序列表和无序列表 1.无序列表使用* + 或 - : 123* hhh+ jjj- kkk 效果如下： hhh jjj kkk 可以看出，三者等同 2.有序列表使用数字和一个英文句点： hhh jjj kkk 代码区块具体语法如下：12345这是一个普通段落： int a; int b; c = a + b; 分割线1234**** * *- - ----------------------------- 效果如下： - - -效果都是一样的 区段元素 链接支持两种形式的链接语法，行内式和参考式这里仅介绍行内式语法简单为：[]+()[] 中为链接文字，() 中为网址链接例如： 12This is [an example](http://example.com/ "Title") inline link.[This link](http://example.net/) has no title attribute. 效果如下：This is an example inline link.This link has no title attribute. 强调文字用 或 _ 包围会变斜，用* 或 __ 包围会变粗例如： 1234*会变斜*_会变斜_**会变粗**__会变粗__ 效果如下：会变斜_会变斜_会变粗会变粗 代码如果要标记一小段行内代码，可以用` 把他包起来： 1Use the `cout&lt;&lt;sddsff;` function. 效果如下： Use the cout&lt;&lt;sddsff; function. 图片简单语法如下：！+ [图片的替代文字] + (网址)例如： 1![pkq!!!](2019-09-08-Markdown/pkq.jpg) 效果如下: 到目前为止，Markdown还没有办法指定图片的高和宽，可以用\标签 自动链接将链接用&lt;&gt;包起来例如： 1&lt;http://example.com/&gt; 效果如下：http://example.com/ 感谢 感谢http://www.markdown.cn/#code-blocks]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
