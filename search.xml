<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树的实现]]></title>
    <url>%2F2019%2F09%2F29%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[二叉树的递归实现(链表)实现了二叉树的生成以及三种遍历方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;#define OK true;#define ERROR false;typedef struct BiTNode&#123; char data; BiTNode *lchild , *rchild;&#125;BiTNode , *BiTree;//构造树bool CreatBiTree(BiTree &amp;T)&#123; char ch; cin&gt;&gt;ch; if(ch == '#') T = NULL; else&#123; T = (BiTree)malloc(sizeof(BiTNode)); if(!T) return ERROR; T-&gt;data = ch; // 生成根节点 CreatBiTree(T-&gt;lchild); //生成左子树 CreatBiTree(T-&gt;rchild); //生成右子树 &#125; return OK;&#125;//前序遍历void PreOrder(BiTree T)&#123; if(T)&#123; cout&lt;&lt;T-&gt;data&lt;&lt;' '; PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); &#125;&#125;//中序遍历void InOrder(BiTree T)&#123; if(T)&#123; InOrder(T-&gt;lchild); cout&lt;&lt;T-&gt;data&lt;&lt;' '; InOrder(T-&gt;rchild); &#125;&#125;void PostOrder(BiTree T)&#123; if(T)&#123; PostOrder(T-&gt;lchild); PostOrder(T-&gt;rchild); cout&lt;&lt;T-&gt;data&lt;&lt;' '; &#125;&#125;int main()&#123; BiTree T; CreatBiTree(T); PreOrder(T); cout&lt;&lt;endl; InOrder(T); cout&lt;&lt;endl; PostOrder(T);&#125; 二叉树的非递归算法(链表)实现了二叉树的三种遍历方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;#define OK true;#define ERROR false;typedef struct BiTNode&#123; char data; BiTNode *lchild , *rchild;&#125;BiTNode , *BiTree;typedef struct Stack&#123; BiTree data; Stack *Next;&#125;Stack , *StackList;typedef struct&#123; StackList base; StackList top;&#125;ListStack;bool InitStack(ListStack &amp;s)&#123; s.base = (StackList)malloc(sizeof(Stack)); if(!s.base) return ERROR; s.top = s.base; s.top-&gt;Next = NULL; return OK;&#125;bool push(ListStack &amp;s , BiTree T)&#123; StackList p = (StackList)malloc(sizeof(Stack)); if(!p) return ERROR; p-&gt;data = T; p-&gt;Next = s.top; s.top = p; return OK;&#125;bool pop(ListStack &amp;s)&#123; if(s.top == s.base) return ERROR; StackList p = s.top; s.top = p-&gt;Next; free(p); return OK;&#125;BiTree getTop(ListStack &amp;s)&#123; return s.top-&gt;data;&#125;bool isEmpty(ListStack &amp;s)&#123; if(s.base == s.top) return true; else return false;&#125;//构造树bool CreatBiTree(BiTree &amp;T)&#123; char ch; cin&gt;&gt;ch; if(ch == '#') T = NULL; else&#123; T = (BiTree)malloc(sizeof(BiTNode)); if(!T) return ERROR; T-&gt;data = ch; // 生成根节点 CreatBiTree(T-&gt;lchild); //生成左子树 CreatBiTree(T-&gt;rchild); //生成右子树 &#125; return OK;&#125;void PreOrder(BiTree T)&#123; ListStack s; InitStack(s); while(T || !isEmpty(s))&#123; while(T)&#123; cout&lt;&lt;T-&gt;data&lt;&lt;' '; push(s , T); T = T-&gt;lchild; &#125; if(!isEmpty(s))&#123; T = getTop(s); pop(s); T = T-&gt;rchild; &#125; &#125; cout&lt;&lt;endl;&#125;void InOrder(BiTree T)&#123; ListStack s; InitStack(s); while(T || !isEmpty(s))&#123; while(T)&#123; push(s , T); T = T-&gt;lchild; &#125; if(!isEmpty(s))&#123; T = getTop(s); pop(s); cout&lt;&lt;T-&gt;data&lt;&lt;' '; T = T-&gt;rchild; &#125; &#125; cout&lt;&lt;endl;&#125;void PostOrder(BiTree T)&#123; ListStack s; InitStack(s); int flag = 1; // 用来判断是否进入右子树 BiTree p; if(T)&#123; do&#123; while(T)&#123; push(s , T); T = T-&gt;lchild; &#125; flag = 1; p = NULL; while(!isEmpty(s) &amp;&amp; flag == 1)&#123; T = getTop(s); // 因为经过第一个while循环，T = NULL,所以要把他变回来 if(T-&gt;rchild == p)&#123; cout&lt;&lt;T-&gt;data&lt;&lt;' '; p = T; //用于判断此节点的右孩子是否已经被访问，或者是没有右孩子 pop(s); &#125; else &#123; T = T-&gt;rchild; flag = 0; &#125; &#125; &#125;while(!isEmpty(s)); &#125; cout&lt;&lt;endl;&#125;int main()&#123; BiTree T; CreatBiTree(T); PreOrder(T); InOrder(T); PostOrder(T);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列的实现]]></title>
    <url>%2F2019%2F09%2F29%2F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[常规链队列的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;using namespace std;#define OK true;#define ERROR false;typedef struct QNode&#123; int data; QNode *Next;&#125;QNode , *QueuePtr;typedef struct&#123; QueuePtr Front; QueuePtr Rear;&#125;LinkQueue;bool Init(LinkQueue &amp;Q)&#123; Q.Front = Q.Rear = (QueuePtr)malloc(sizeof(QNode)); if(!Q.Front)&#123; return ERROR; &#125; Q.Front-&gt;Next = NULL; return OK;&#125;//插入bool Insert(LinkQueue &amp;Q , int e)&#123; QueuePtr p = (QueuePtr)malloc(sizeof(QNode)); if(!p)&#123; return ERROR; &#125; p-&gt;data = e; p-&gt;Next = NULL; Q.Rear-&gt;Next = p; Q.Rear = p; return OK;&#125;//删除bool Delete(LinkQueue &amp;Q , int &amp;e)&#123; if(Q.Front == Q.Rear) return ERROR; QueuePtr p = Q.Front-&gt;Next; e = p-&gt;data; Q.Front-&gt;Next = p-&gt;Next; if(Q.Rear == p) Q.Rear = Q.Front; //当队列中只有一个元素时 free(p); return OK;&#125;//遍历void print(LinkQueue Q)&#123; if(Q.Front == Q.Rear)&#123; cout&lt;&lt;"没有元素"&lt;&lt;endl; &#125; else &#123; Q.Front = Q.Front-&gt;Next; while(Q.Front)&#123; cout&lt;&lt;Q.Front-&gt;data&lt;&lt;' '; Q.Front = Q.Front-&gt;Next; &#125; &#125; cout&lt;&lt;endl;&#125;//销毁队列bool DestroyQueue(LinkQueue &amp;Q)&#123; while(Q.Front)&#123; Q.Rear = Q.Front-&gt;Next; free(Q.Front); Q.Front = Q.Rear; &#125; return OK;&#125;int main()&#123; LinkQueue Q; Init(Q); for(int i = 0 ; i&lt;5 ; ++i)&#123; int n; cin&gt;&gt;n; Insert(Q , n); &#125; print(Q); int e; Delete(Q , e); cout&lt;&lt;endl; cout&lt;&lt;e&lt;&lt;endl; print(Q); DestroyQueue(Q); print(Q);&#125; 循环队列的实现循环队列主要是针对队列的顺序存储结构，主要目的是避免顺序存储中的内存空间的浪费。 下面的这种方法少用一个储存空间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;#define OK true;#define ERROR false;#define MAXSIZE 6typedef struct Queue&#123; int *base; int Front; int Rear;&#125;Queue;bool Init(Queue &amp;Q)&#123; Q.base = (int *)malloc(MAXSIZE * sizeof(int)); if(!Q.base) return ERROR; Q.Front = Q.Rear = 0; return OK;&#125;//队列长度int getLength(Queue &amp;Q)&#123; return (Q.Rear - Q.Front + MAXSIZE) % MAXSIZE;&#125;bool Insert(Queue &amp;Q , int e)&#123; if((Q.Rear + 1) % MAXSIZE == Q.Front) return ERROR; //队列满的标志 Q.base[Q.Rear] = e; Q.Rear = (Q.Rear + 1)%MAXSIZE; return OK;&#125;bool Delete(Queue &amp;Q , int &amp;e)&#123; if(Q.Front == Q.Rear) return ERROR; //队列空的标志 e = Q.base[Q.Front]; Q.Front = (Q.Front + 1)%MAXSIZE; return OK;&#125;void print(Queue Q)&#123; if(Q.Front == Q.Rear) cout&lt;&lt;"队列空"&lt;&lt;endl; else &#123; while((Q.Front + 1)%MAXSIZE != Q.Rear)&#123; cout&lt;&lt;Q.base[Q.Front]&lt;&lt;' '; Q.Front = Q.Front+1; &#125; cout&lt;&lt;Q.base[Q.Front]; &#125; cout&lt;&lt;endl;&#125;int main()&#123; Queue Q; Init(Q); for(int i = 0 ; i&lt;5 ; ++i)&#123; int n; cin&gt;&gt;n; bool a; a = Insert(Q , n); cout&lt;&lt;a&lt;&lt;' '; &#125; int e; cout&lt;&lt;endl; cout&lt;&lt;getLength(Q)&lt;&lt;endl; print(Q); //cout&lt;&lt;Q.Front&lt;&lt;' '&lt;&lt;Q.Rear&lt;&lt;endl; Delete(Q , e); cout&lt;&lt;e&lt;&lt;endl; print(Q); cout&lt;&lt;getLength(Q)&lt;&lt;endl; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于CenterNet的理解]]></title>
    <url>%2F2019%2F09%2F27%2FCenterNet%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Introduction在CenterNet中，作者找到了更简单、更有效的方法，作者用bbox的中心点来代替此物体，其他特征，比如物体大小，维度，姿态等等则从物体中心点位置的图像特征来直接回归，所以目标检测就变成了关键点的预测问题。一开始将图像输入到一个全卷积中，然后生成一个热图，热图中的峰值就对应于物体的中心点，每个峰值的图像特征就用于预测物体bbox的高和宽，训练用标准的密集监督学习，推理过程是一个单一的向前传播，没有NMS的后处理。 Related workCenterNet方法近似相当于锚点为基准的one-stage方法。 CenterNet仅仅根据位置来分配’anchor’，而不是根据框重叠，也就是说，CenterNet的’anchor’仅仅会出现在当前目标的位置处而不是在整个图上都分配，所以不用手动调阈值来看框是正类还是负类； 每个物体只有一个正框，所以不需要NMS来后处理，只需要在关键点热图上提取峰值； CenterNet输出的下采样因子是4，所以输出分辨率相比其他框架来说更大，这样就消除了对于多重锚点的需求； 疑问：多重锚点是什么意思？？（原文是‘This eliminates the need for multiple anchors’） Preliminary假设输入图像的维度为(3 , W , H)，那么目标就是生成一个热图，Y∈[0,1] ，其中Y的维度是(C , W/R , H/R)，C在目标检测中是类别，论文用coco数据集，所以C=80，论文中作者取R=4，表示下采样的步幅是4，那么为什么要生成这样一个热图呢，原来这个三维张量Y中的每一个值如果是1的话，那么代表这是检测的关键点，如果是0的话代表的是背景，所以Y的值要在0和1之间，表示概率，论文中用了几种不同的encoder-decoder networks来预测图像中的Y: Hourglass Network 带有转置卷积的ResNet 原始的DLA和作者改造后的DLA； 在训练过程中，CenterNet学习了CornerNet的方法，对于每个ground truth 的某一类C，我们需要把p(中心点)计算出来进行训练，计算方法为p = ((x1 + x2)/2 ，(y1 + y2)/2)，对于下采样后的坐标，我们设，其中R为下采样因子，并且向下取整，所以最终计算出来的中心点是对应低分辨率的中心点。有了中心点的坐标后，接下来的任务就是如何根据gt关键点的坐标来生成热图，作者用了一个高斯核来将计算好的关键点分布到如图中，其中 σp是一个对物体大小自适应的标准差。这样就生成了一个热图 疑问：px和py都是整数，那么x和px 在计算高斯核的时候是如何匹配的？？或者对于高斯核的理解一开始就是错的？？ 损失函数重点看一下损失函数： 中心点预测的损失函数 作者对于中心点位置和类别的预测是通过Focal-loss来进行逻辑回归的， α and β是超参数，论文中α=2，β=4，N是图像中关键点的个数，目的是将Focal-loss归一化。 疑问：N的数量是不多的，但是Lk是对所有的点来算损失函数的，那么为什么N可以将Focal-loss归一化？？ 目标中心的偏置损失 由于对于图像进行了R=4的下采样，但是中心点最终是要映射回原图的，这样会有精度损失，因此，对于每一个中心点，都额外采用一个局部偏移量，根据维度也可以看出，对于同一位置的所有类别，这个局部偏移量是共享的。注意上面的损失函数仅仅是对于关键点位置来算的，其他的点是要被忽略的。 疑问： 1. 中心点最终是如何映射到原图的？？是简单的乘4？？ 2. 为什么局部偏移量要对所有类进行共享？？是为了减少计算量？？ 3. 这个偏移量是在缩小后的图像上的偏移，但是在原图上的偏移和这个偏移应该是不一样的吧？？ 4. 回归的目的不就是为了减少偏移量吗？那为什么还要算偏移损失？？ 目标大小的损失 假设是Ck类的目标k的bbox，那么中心点的坐标就是pk = ，我们用Y^来预测所有的关键点，然后对每个目标k的size 进行回归，Sk = ，这是下采样后的长宽值，是预测值，由维度可知，这是所有的类别共享的size值。 疑问：为什么所有的类都在一个中心点出有相同的size？？ 总的损失函数为： 论文中 λsize = 0.1, λoff = 1。 最终每个坐标点产生C+4个数据，分别是类别、长宽和偏移量，这三个量是用一个单独的网络来预测出来的，并且所有的输出共享一个backbone网络。 推测阶段在预测阶段，首先对一张图像进行下采样，然后在下采样的特征图中预测中心点，然后就可以把输出图中的热点单独提取出来，提取过程是什么呢，首先，可以检测当前热点的值是否比周围八个邻近的热点单独地提取出来，然后提取出100个这样的点，这样，有了中心点的位置后就可以生产锚框了。即变成(x1 , y1 , x2 , y2)的锚框]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>待补充</tag>
        <tag>CenterNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Focal Loss的理解]]></title>
    <url>%2F2019%2F09%2F26%2FFocal-Loss%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[声明：这篇论文还未读，所以里面所有内容都是来自于各种网络大佬的理解，等自己读了论文后有待补充。 为什么要提出Focal-loss现在目标检测大概分为两种: one-stage和two-stage，one-stage虽然速度快，但是精度不如two-stage的，相反，two-stage虽然精度高，但是速度慢，后来Lin等人对于此问题的研究发现，one-stage的精度不高与训练时后景数据相比于前景数据少的多有很大原因，因此Lin等人通过对交叉熵损失函数进行修改，提了Focal-loss，即会特别关注某些Loss的意思。 论文分析了One-stage精度不高的原因 正负样本极度不均衡：anchor的生成是用类似于sliding-windows的方式，这会导致正负样本的比例接近1:1000，而且绝大多数负样本为“easy example”； 梯度优化过程中被easy example过度影响: 根据交叉熵损失函数，虽然easy example的Loss不高，但是数量多，所以在梯度优化时Loss函数会过度关注这些easy example，从而使得那些难以分类的类别得不到很好的训练。 对于Focal-loss 的理解 首先回顾一下交叉熵损失函数：其中是经过激活函数的输出，在0-1之间，所以普通的交叉熵就是正样本的输出概率越大，那么Loss就越小，对于负样本，输出概率越小，Loss就越小。 再看加了gama后的Loss函数：在加入了gama后，就对难易样本的loss有了区分，对于正样本而言，如果输出为0.9，那么表明这个样本是容易训练的，所以Loss就变得比原来小，如果输出是0.5，表明难以训练，所以Loss就大，所以就使得Loss函数更加关注难训练的样本，所以减少了easy example的影响，论文实验发现gama=2是最优的。 Focal-loss的最终版本：α的加入实际上是使交叉熵加权，α一般设置为类别比例的倒数或者直接设为超参数(人为设定)，这样使得正样本(数量少)得到Loss的重视，从而减少负样本的影响。 为什么Focal loss没有用在two-stage上 two-stage会在生成区域建议阶段来使用NMS，使得候选框大量减少，在此过程中，减少了大量的背景框； 训练时用minibatch的采样策略，比如Faster-rcnn使用正负样本为1:3，这实际上起到了α 的作用。 感谢 https://www.sogou.com/link?url=hedJjaC291OoAuWay7Ycy8qCqnS5BeBJZpR6MQDH4jecmW7u2WhTZknbb2GMMgFg6KnxECbDvSOfABNiu1prjGiLSQm6y_cjIxl1zdOoaQG8NQzjFsXswHMpU5R1W7o9LJ3yweXqb0A4XXtlfpMI6PAjn7Fnn5gA https://www.cnblogs.com/king-lps/p/9497836.html]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Focal-Loss-OD</tag>
        <tag>待补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 简单教程]]></title>
    <url>%2F2019%2F09%2F08%2FMarkdown%2F</url>
    <content type="text"><![CDATA[区块元素 标题Markdown支持两种标题的语法 1.类Setext 形式利用底线的形式，利用=(表示最高阶题)，-（表示第二阶题）， 任何数量的 = 和 - 都可以有效果，例如： 1234&gt; This is an H1&gt;=================&gt;This is an H2&gt;------------------ 2.类Atx形式则是利用#的数量从1到6来表示标题的阶，例如： 123&gt;# This is H1&gt;## This is H2&gt;###### This is H6 区块引用先断好行，然后在每行前加&gt;，例如： 1&gt;This is a blockquote 效果如下： This is a blockquote Markdown 也允许只在整个段落的第一行加 &gt; : 1&gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. 效果如下： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. 区块引用允许嵌套（引用内引用），根据层次不用加不同数量的&gt; ，例如： 1&gt;&gt;This is my House 效果如下： This is my House 引用区块也可以使用其他Markdown 语法，例如： 1234567&gt; ## This is H1&gt;&gt; 1. 这是第一行列表项&gt;&gt; 代码：&gt;&gt;（这里要有两个缩进）return shell_exec("echo $input | $markdown_script"); 效果如下： ##This is H11.这是第一行列表项 return shell_exec(&quot;echo $input | $markdown_script&quot;); 列表分为有序列表和无序列表 1.无序列表使用* + 或 - : 123* hhh+ jjj- kkk 效果如下： hhh jjj kkk 可以看出，三者等同 2.有序列表使用数字和一个英文句点： hhh jjj kkk 代码区块具体语法如下： 12345这是一个普通段落： int a; int b; c = a + b; 分割线1234**** * *- - ----------------------------- 效果如下： 效果都是一样的 区段元素 链接支持两种形式的链接语法，行内式和参考式这里仅介绍行内式语法简单为：[]+()[] 中为链接文字，() 中为网址链接例如： 12This is [an example](http://example.com/ "Title") inline link.[This link](http://example.net/) has no title attribute. 效果如下：This is an example inline link.This link has no title attribute. 强调文字用 * 或 _ 包围会变斜，用** 或 __ 包围会变粗例如： 1234*会变斜*_会变斜_**会变粗**__会变粗__ 效果如下：会变斜会变斜会变粗会变粗 代码如果要标记一小段行内代码，可以用` 把他包起来： 1Use the `cout&lt;&lt;sddsff;` function. 效果如下： Use the cout&lt;&lt;sddsff; function. 图片简单语法如下：！+ [图片的替代文字] + (网址)例如： 1![pkq!!!](2019-09-08-Markdown/pkq.jpg) 效果如下: 到目前为止，Markdown还没有办法指定图片的高和宽，可以用&lt;img&gt;标签 自动链接将链接用&lt;&gt;包起来例如： 1&lt;http://example.com/&gt; 效果如下：http://example.com/ 感谢 感谢http://www.markdown.cn/#code-blocks]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
