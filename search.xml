<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2020%2F01%2F18%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[显式初始化数组元素当显式地初始化数组元素时，如果提供的维度比初始值数量大，那么剩下的元素会被初始化为默认值。 1234567891011121314int a[10] = &#123;1 , 2 , 3&#125;; //默认值为0char a2[10] = "lzc"; //默认值为'\0'string a3[10] = &#123;"lzc" , "hello" , "world"&#125;; // 默认值为""for(auto i : a2)&#123; cout&lt;&lt;(i == '\0');&#125;cout&lt;&lt;endl;for(auto i : a)&#123; cout&lt;&lt;i;&#125;cout&lt;&lt;endl;for(auto i : a3)&#123; cout&lt;&lt;(i == "");&#125; 当显式地用字面值初始化字符数组时，要注意： 123456char a[] = "lzc"; //结尾有'\0'char a1[] = &#123;'l' , 'z' , 'c'&#125;; //结尾没有'\0'char a2[] = &#123;'l' , 'z' , 'c' , '\0'&#125;;char a3[3] = "lzc"; // 错误的，最小是4才能容得下cout&lt;&lt;(a[3] == '\0')&lt;&lt;endl;cout&lt;&lt;(a1[3] == '\0')&lt;&lt;endl; //结果虽然是0，但是a1[3]时不存在的 复杂数组的声明12345int *p[10]; //p是容量为10的数组，里面的元素为整形指针(可以从右向左理解)int &amp;p2[10]; //错误，没有引用的数组int (*p3)[10]; //可以从内向外理解，首先，p3是一个指针，它指向大小为10的数组，数组中的元素为intint (&amp;p4)[10]; //同理，p4是一个引用，引用的对象是大小为10的数组，数组中的元素为intint *(&amp;p5)[10]; //p5是一个引用，引用的对象是大小为10的数组，数组中的元素是整形指针 访问数组元素使用下标访问当使用下标时，通常将其定义 为size_t类型，size_t是一个无符号类型。 使用begin和end1234int a[] = &#123;1 , 2 , 3 , 4 , 5&#125;;for(auto i = begin(a) ; i != end(a) ; ++i)&#123; cout&lt;&lt;*i;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string一些小知识]]></title>
    <url>%2F2020%2F01%2F07%2Fstring%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[string::size_type 类型string::size_type是无符号整形，所以有时候与int混用会出现问题。 例如s.size() &lt; n，如果n是一个int类型，那么一旦n小于0，那么这个几乎都等于true，因为表达式中既有带符号类型又有无符号类型，带符号类型会自动转化为无符号类型，所以n如果是负数，那么就相当于n的绝对值对无符号类型表示数值总数取模后的余数。 所以一个表达式用有了size()函数(vector等很多size()函数也是无符号类型)就不要用int了！！！ 当要用string的下标时，可以采用：for(decltype(s.size()) i = 0 ; i != s.size() ; ++i)来访问string的元素。 字面值和string对象相加使用 + 运算符时，要确保 + 两侧的运算对象至少有一个是stirng string s = "hello " + ", "; // 错误 string s = "hello " + ", " + s; //错误 string s = "hello " + (", " + s); // 正确 string s = s + "hello " + ", "; //正确 c++ 中字符串字面值并不是string 的对象]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型处理]]></title>
    <url>%2F2020%2F01%2F04%2F%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[类型别名两种方法： 12345//第一种、typedef double money; //money 是double 的同义词typedef money rmb , *dollar // rmb是 double的同义词，dollar是double * 的同义词using money = double; //money 是double 的同义词 注意事项如果类型别名指代的是复合类型，那么把它用到声明语句中会有变化 1234567891011121314151617typedef char *ch; //ch是 char *的同义词const ch c = 0; // 注意：这里c是 指向char的常量指针 而非 指向常量char 的指针``` **注意**这里和平常的理解不一样：我刚开始以为const ch 就是 const char *，没想到对const ch 的理解并不是简单地把 ch 替换成 char *。# decltype 类型提示符有时我们想通过表达式的类型来判断要定义的变量的类型，但是又**不想用该表达式的值**来初始化变量，就可以用decltype。``` bashint f(int a , int b)&#123; return a+b;&#125;decltype(f(10 , 10)) sum = 10; // sum 为int 类型int i = 10 , *p = &amp;i;decltype(*p) c = 10; // 注意：如果表达式的结果是解应用操作，那么将返回 引用类型，所以 c的类型是 int &amp; ，而非 int，所以c必须被初始化。decltype((i)) d = 10; //注意：decltype((variable))的结果是 引用，所以d的类型是int &amp;，所以 d 必须初始化。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python常用函数]]></title>
    <url>%2F2019%2F12%2F18%2FPython%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[np.flatnonzero()该函数返回矩阵的展平版本中非零元素的位置 123import numpy as npa = np.arange(12).reshape(3 , 4)np.flatnonzero(a) 结果如下： array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], dtype=int64) np.random.choice()numpy.random.choice(a, size=None, replace=True, p=None) 从a(只要是ndarray都可以，但必须是一维的)中随机抽取数字，并组成指定大小(size)的数组 replace:True表示可以取相同数字，False表示不可以取相同数字 数组p：与数组a相对应，表示取数组a中每个元素的概率，默认为选取每个元素的概率相同。 12a = np.random.choice(5 , 3) #相当于(0 , 5 , 3)a 结果如下： array([0, 0, 3]) np.sum()12345a = np.arange(24).reshape(4 , 2 , 3)b = np.sum(a , 0)c = np.sum(a , 1)d = np.sum(a , 2)print(b.shape , c.shape , d.shape) 结果如下： (2, 3) (4, 3) (4, 2) 如果第二个参数不填的话，默认将所有元素全部加起来。 第二个参数是几，就在第几个维度上求和，这在python其他函数中也是一样的情况。 np.argsort()返回数组中按一定顺序排列后的引索值 12345678a = np.array([[3 , 1 , 4] , [4 , 9 , 0] , [1 , 2 ,9]])print(a)print()print(np.argsort(a , axis = 1)) #将每行排列print()print(np.argsort(a)) #默认将每行排列print()print(np.argsort(a , axis = 0)) #将每列排列 结果如下： 123456789101112131415[[3 1 4] [4 9 0] [1 2 9]][[1 0 2] [2 0 1] [0 1 2]][[1 0 2] [2 0 1] [0 1 2]][[2 0 1] [0 2 0] [1 1 2]] 上面是按从小到大排列的若按从大到小排列： 12a = np.array([4 , 9 , 0])np.argsort(-a) 结果： array([1, 0, 2], dtype=int64) np.bincount(x , weights , minlength)返回数组中元素的出现重复次数 12a = np.array([4 , 9 , 0 , 0 , 3 , 2])print(np.bincount(a)) 结果如下： [2 0 1 1 1 0 0 0 0 1] 这个函数首先输入的数组的值为int类型，而且数组必须是一维的，然后他会找出数组中的最大值(比如本例中9)，然后输出就是一个长度&gt;=max的一维数组，本例中，0出现2次，1，5，6，7，8均未出现，其中4，3，2，9均出现1次。 参数weigths 的形状是array_link(x)，作用是如果weights 被指定，那么x就会被加权，也就是说，如果值n发现在位置i，那么out[n] += weight[i]而不是out[n] += 1比如： 1234w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6])# 我们可以看到x中最大的数为4，因此bin的数量为5，那么它的索引值为0-&gt;4x = np.array([2, 1, 3, 4, 4, 3])np.bincount(x, weights=w) 结果如下： array([ 0. , 0.5, 0.3, -0.4, 1.7]) 其中3分别赋予了(0.2 + (-0.6))的权值，4为(1.0 + 0.7)的权值。 minlength 指定输出最小的长度如果数组中的最大值小于了minlength，那么少于的部分被补零。 12a = np.array([0 , 2 , 3 , 2])print(np.bincount(a , minlength = 10)) 结果如下： [1 0 2 1 0 0 0 0 0 0] argmax()先看一维 123import numpy as npa = np.array([3, 1, 2, 4, 6, 1])print(np.argmax(a)) 结果： 4 即返回的是最大值的位置 再看二维 123456a = np.array([[1, 5, 5, 2], [9, 6, 2, 8], [3, 7, 9, 1]])print(np.argmax(a , axis = 0))print()print(np.argmax(a , axis = 1)) 结果： 123[1 2 2 1][1 0 2] 其余更多维度的都是大同小异]]></content>
      <tags>
        <tag>-待补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K-Nearest_Neighbors_Algorithm]]></title>
    <url>%2F2019%2F12%2F18%2FK-Nearest-Neighbors-Algorithm%2F</url>
    <content type="text"><![CDATA[KNNKNN是一种无监督机器学习算法，算法假定相似的事物彼此接近，其中，用‘距离’来表征事物的相似性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import mathimport numpy as npdef KNN(data , quary , k , distance_fn , choice_fn): neighbor_distance_and_index = [] for index, example in enumerate(data): distance = distance_fn(example[:-1] , quary) #将要预测的 quary 与 data 里的每一个值进行 #距离计算 neighbor_distance_and_index.append((distance , index)) sorted_neighbor_diatance_and_index = sorted(neighbor_distance_and_index) #将距离排序 k_nearest_distance_and_index = sorted_neighbor_diatance_and_index[:k] #取出前k个最相似的值 k_nearset_labels = [data[i][1] for distance , i in k_nearest_distance_and_index] return k_nearest_distance_and_index , choice_fn(k_nearset_labels)def mean(labels): #将最终结果取平均值 return sum(labels) / len(labels)def euclidean_distance(example , quary): #用欧式距离 sum_euclidean_distance = 0 for i in range(len(example)): sum_euclidean_distance += math.pow(example[i]- quary[i] , 2) #当(example[i]- quary[i]) 的输入不是单一值而是张量之间的运算时，不能用math #而用 #sum_euclidean_distance += np.sum((example[i]- quary[i]) ** 2 , dim = ) dim 是维度 return math.sqrt(sum_euclidean_distance) #return np.sqrt(sum_euclidean_distance)def main(): reg_data = [ [65.75, 112.99], [71.52, 136.49], [69.40, 153.03], [68.22, 142.34], [67.79, 144.30], [68.70, 123.30], [69.80, 141.49], [70.01, 136.46], [67.90, 112.37], [66.49, 127.45], ] reg_quary = [60] reg_k_nearest_neighbors, reg_prediction = KNN(reg_data , reg_quary , k = 2 , distance_fn = euclidean_distance , choice_fn = mean) print(reg_prediction)if __name__ == '__main__': main() 如果k=1，那么模型预测误差就很大，而增加k的值，由于进行多次投票，最终预测变得稳定]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>-Machine Learning Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线型表]]></title>
    <url>%2F2019%2F11%2F25%2F%E7%BA%BF%E5%9E%8B%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线型表的顺序表示和实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;iostream&gt;#include&lt;stdio.h&gt;#define LIST_INIT_SIZE 100#define List_Increament 10 //当容量不够时每次增加的容量大小using namespace std;typedef struct SqList&#123; int *data; int length; int listsize; //线型表的容量&#125;S;bool Init(SqList &amp;L)&#123; L.data = (int *)malloc(LIST_INIT_SIZE * sizeof(int)); if(!L.data) return false; L.length = 0; L.listsize = LIST_INIT_SIZE; return true;&#125;// 在第i+1的位置上插入ebool Insert(SqList &amp;L , int i , int e)&#123; if(i &lt; 0 || i &gt; L.length)&#123; return false; &#125; if(L.length &gt; L.listsize)&#123; int *newsize = (int *)realloc(L.data , (L.listsize + List_Increament) * sizeof(int)); if(!newsize) return false; L.data = newsize; L.listsize += List_Increament; &#125; int *q = &amp;(L.data[i]); for(int *p = &amp;(L.data[L.length - 1]) ; p &gt;= q ; --p)&#123; *(p+1) = *p; &#125; *q = e; L.length++; return true;&#125;// 在i+1 的位置上删除元素，放入e中bool Delete(SqList &amp;L , int i , int &amp;e)&#123; if(i &lt; 0 || i &gt;= L.length)&#123; return false; &#125; int *p = &amp;(L.data[i]); e = L.data[i]; for(int *q = &amp;(L.data[i]) ; q &lt; &amp;(L.data[L.length-1]) ; ++q)&#123; *q = *(q+1); &#125; --L.length; return true;&#125;//合并线型表L1 和 L2 ，放入 L3中, 假设L1和L2均为降序排列，得到的L3也要降序排列bool MergeList(SqList &amp;L1 , SqList &amp;L2 , SqList &amp;L3)&#123; int *p1 = L1.data; int *p2 = L2.data; L3.length = L1.length + L2.length; L3.listsize = L1.listsize + L2.listsize; L3.data = (int *)malloc(L3.listsize * sizeof(int)); int *p3 = L3.data; if(!L3.data) return false; while(p1 &lt;= (L1.data + L1.length - 1) &amp;&amp; p2 &lt;= (L2.data + L2.length - 1))&#123; if(*p1 &gt; *p2)&#123; *p3 = *p1; *p3++ , *p1++; &#125; else &#123; *p3 = *p2; *p3++ , *p2++; &#125; &#125; while(p1 &lt;= (L1.data + L1.length - 1))&#123; *p3 = *p1; *p3++ , *p1++; &#125; while(p2 &lt;= (L2.data + L2.length - 1))&#123; *p3 = *p2; *p3++ , *p2++; &#125; return true;&#125;int main()&#123; //合并 SqList L1 , L2 , L3; Init(L1); Init(L2); Init(L3); for(int i = 0 ; i&lt;5 ; ++i)&#123; int a; cin&gt;&gt;a; Insert(L1 , i , a); &#125; for(int i = 0 ; i&lt;5 ; ++i)&#123; int a; cin&gt;&gt;a; Insert(L2 , i , a); &#125; MergeList(L1 , L2 , L3); for(int i = 0 ; i&lt;L3.length ; ++i)&#123; cout&lt;&lt;L3.data[i]&lt;&lt;' '; &#125; //插入、删除 SqList s; Init(s); for(int i = 0 ; i&lt;10 ; ++i)&#123; int a; cin&gt;&gt;a; Insert(s , i , a); &#125; for(int i = 0 ; i&lt;10 ; ++i)&#123; cout&lt;&lt;s.data[i]&lt;&lt;' '; &#125; cout&lt;&lt;endl; Insert(s , 5 , 1000); for(int i = 0 ; i&lt;s.length ; ++i)&#123; cout&lt;&lt;s.data[i]&lt;&lt;' '; &#125; int e; Delete(s , 5 , e); Delete(s , 3 , e); cout&lt;&lt;endl; cout&lt;&lt;e&lt;&lt;endl; for(int i = 0 ; i&lt;s.length ; ++i)&#123; cout&lt;&lt;s.data[i]&lt;&lt;' '; &#125;&#125; 线型表的链式表示和实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;iostream&gt;#include&lt;stdio.h&gt;#define LIST_INIT_SIZE 100#define List_Increament 10using namespace std;typedef struct LNode &#123; int data; LNode *next;&#125;LNode , *LinkList;//建立一个有n个节点的链表void CreateList(LinkList &amp;L , int n)&#123; L = (LinkList)malloc(sizeof(LNode)); L-&gt;next = NULL; for(int i = 0 ; i&lt;n ; ++i)&#123; LinkList p = (LinkList)malloc(sizeof(LNode)); cin&gt;&gt;p-&gt;data; p-&gt;next = L-&gt;next; // 头插法 L-&gt;next = p; &#125;&#125;//在第i个位置之前插入 ebool Insert(LinkList &amp;L , int i , int e)&#123; LinkList p = L; for(int j = 0 ; j&lt;i-1 ; ++j)&#123; if(p == NULL) return false; p = p-&gt;next; &#125; LinkList q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = e; q-&gt;next = p-&gt;next; p-&gt;next = q; return true;&#125;//删除第i个节点bool Delete(LinkList &amp;L , int i , int &amp;e)&#123; LinkList p = L; for(int j = 0 ; j&lt;i-1 ; ++j)&#123; if(!p) return false; p = p-&gt;next; &#125; LinkList q = p-&gt;next; e = p-&gt;next-&gt;data; p-&gt;next = p-&gt;next-&gt;next; free(q); return true;&#125;void print(LinkList L)&#123; LinkList p = L-&gt;next; while(p)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;' '; p = p-&gt;next; &#125; cout&lt;&lt;endl;&#125;// L1和L2中均为降序排列，合并后的L3中的也为降序void MergeList(LinkList &amp;L1 , LinkList &amp;L2 , LinkList &amp;L3)&#123; LinkList p1 = L1-&gt;next , p2 = L2-&gt;next; LinkList p3 = L3 = L1; // 将L1的头结点作为L3的头结点 while(p1 &amp;&amp; p2)&#123; if(p1-&gt;data &gt; p2-&gt;data)&#123; p3-&gt;next = p1; p3 = p3-&gt;next; p1 = p1-&gt;next; &#125; else &#123; p3-&gt;next = p2; p3 = p3-&gt;next; p2 = p2-&gt;next; &#125; &#125; p3-&gt;next = p1 ? p1 : p2; free(L2);&#125;int main()&#123; LinkList L1 , L2 , L3; int n; cin&gt;&gt;n; CreateList(L1 , n); CreateList(L2 , n); print(L1); print(L2); MergeList(L1 , L2 , L3); print(L3);&#125; 单向循环链表1234567891011//没什么不一样的，就变了L-&gt;next = L; 而且其他函数的终止条件不可以是p-&gt;next == NULL，而是是否等于头指针void CreateList(LinkList &amp;L , int n)&#123; L = (LinkList)malloc(sizeof(LNode)); L-&gt;next = L; for(int i = 0 ; i&lt;n ; ++i)&#123; LinkList p = (LinkList)malloc(sizeof(LNode)); cin&gt;&gt;p-&gt;data; p-&gt;next = L-&gt;next; L-&gt;next = p; &#125;&#125; 循环双向链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;stdio.h&gt;#define LIST_INIT_SIZE 100#define List_Increament 10using namespace std;typedef struct DuLNode &#123; int data; DuLNode *prior; DuLNode *next;&#125;DuLNode , *DuLinkList;void CreateList(DuLinkList &amp;L , int n)&#123; L = (DuLinkList)malloc(sizeof(DuLNode)); L-&gt;next = L; L-&gt;prior = L; for(int i = 0 ; i&lt;n ; ++i)&#123; DuLinkList p = (DuLinkList)malloc(sizeof(DuLNode)); cin&gt;&gt;p-&gt;data; p-&gt;next = L-&gt;next; L-&gt;next-&gt;prior = p; p-&gt;prior = L; L-&gt;next = p; &#125;&#125;// 在i位置之前插入evoid Insert(DuLinkList &amp;L , int i , int e)&#123; DuLinkList q = L; DuLinkList p = (DuLinkList)malloc(sizeof(DuLNode)); p-&gt;data = e; for(int j = 0 ; j&lt;i - 1 ; ++j)&#123; q = q-&gt;next; &#125; p-&gt;next = q-&gt;next; q-&gt;next-&gt;prior = p; p-&gt;prior = q; q-&gt;next = p;&#125;// 删除i位置的结点void Delete(DuLinkList &amp;L , int i , int &amp;e)&#123; DuLinkList p = L; for(int j = 0 ; j&lt;i ; ++j)&#123; p = p-&gt;next; &#125; e = p-&gt;data; p-&gt;next-&gt;prior = p-&gt;prior; p-&gt;prior-&gt;next = p-&gt;next; free(p);&#125;void print(DuLinkList L)&#123; DuLinkList p = L-&gt;next; while(p != L)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;' '; p = p-&gt;next; &#125; cout&lt;&lt;endl; p = p-&gt;prior; while(p != L)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;' '; p = p-&gt;prior; &#125; cout&lt;&lt;endl;&#125;int main()&#123; DuLinkList L; int n; cin&gt;&gt;n; CreateList(L , n); print(L); int e; cin&gt;&gt;e; Insert(L , 3 , e); print(L); Delete(L , 2 , e); print(L); cout&lt;&lt;e;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>-线型表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的基本操作的实现]]></title>
    <url>%2F2019%2F10%2F28%2F%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[图的三种表示方法图的数组表示法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include&lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;#define MAX_NUM 20#define INFINITY INT_MAXtypedef int VRType;typedef char VertexType;typedef enum&#123;DG , DN , UDG , UDN&#125; GraphKind; //&#123;有向图，有向网，无向图，无向网&#125;typedef struct ArcCell&#123; VRType adj; // 无权图是0和1, 有权图是权值 //InfoType *info;&#125;ArcCell , AdjMatrix[MAX_NUM][MAX_NUM];typedef struct &#123; VertexType vexs[MAX_NUM]; //顶点名称 AdjMatrix arcs; //邻接矩阵 int vexnum , arcnum; //顶点数 和 弧数 //GraphKind kind; //图的类型&#125;MGraph;// 返回顶点在图中的位置 intint LocateVex(MGraph G , VertexType v)&#123; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; if(G.vexs[i] == v)&#123; return i; &#125; &#125;&#125;// 无向网 void CreateUDN(MGraph &amp;G)&#123; //scanf(&amp;G.kind); cout&lt;&lt;"构造无向网："&lt;&lt;endl; cout&lt;&lt;"输入图的顶点数和边数："&lt;&lt;endl; cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; cout&lt;&lt;"输入顶点名称："&lt;&lt;endl; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; cin&gt;&gt;G.vexs[i]; &#125; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; G.arcs[i][j].adj = INFINITY; &#125; &#125; cout&lt;&lt;"输入顶点及其权值："&lt;&lt;endl; for(int k = 0 ; k&lt;G.arcnum ; ++k)&#123; VertexType v1 , v2; int w; cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; int i = LocateVex(G , v1); int j = LocateVex(G , v2); G.arcs[i][j].adj = w; G.arcs[j][i].adj = G.arcs[i][j].adj; &#125;&#125;// 有向网 (其实就是无向图去掉了最后一个语句)void CreateDN(MGraph &amp;G)&#123; cout&lt;&lt;"构造有向网："&lt;&lt;endl; cout&lt;&lt;"输入图的顶点数和边数："&lt;&lt;endl; cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; cout&lt;&lt;"输入顶点名称："&lt;&lt;endl; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; cin&gt;&gt;G.vexs[i]; &#125; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; G.arcs[i][j].adj = INFINITY; &#125; &#125; cout&lt;&lt;"输入顶点及其权值："&lt;&lt;endl; for(int k = 0 ; k&lt;G.arcnum ; ++k)&#123; VertexType v1 , v2; int w; cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; int i = LocateVex(G , v1); int j = LocateVex(G , v2); G.arcs[i][j].adj = w; //G.arcs[j][i].adj = G.arcs[i][j].adj; &#125;&#125;// 图的打印void print(MGraph G)&#123; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; if(G.arcs[i][j].adj != INFINITY)&#123; cout&lt;&lt;'('&lt;&lt;G.vexs[i]&lt;&lt;','&lt;&lt;G.vexs[j]&lt;&lt;')'&lt;&lt;' '; &#125; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; if(G.arcs[i][j].adj == INFINITY)&#123; cout&lt;&lt;0&lt;&lt;' '; &#125; else cout&lt;&lt;G.arcs[i][j].adj&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125;&#125;void InsertVex(MGraph &amp;G , VertexType v)&#123; G.vexnum++; G.vexs[G.vexnum - 1] = v; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; G.arcs[i][G.vexnum - 1].adj = INFINITY; &#125; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; G.arcs[G.vexnum - 1][j].adj = INFINITY; &#125;&#125;void InsertArc(MGraph &amp;G , VertexType v , VertexType w)&#123; int i = LocateVex(G , v); int j = LocateVex(G , w); if(i == -1)&#123; G.vexnum++; G.vexs[G.vexnum - 1] = v; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; G.arcs[i][G.vexnum - 1].adj = INFINITY; &#125; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; G.arcs[G.vexnum - 1][j].adj = INFINITY; &#125; i = G.vexnum - 1; &#125; if(j == -1)&#123; G.vexnum++; G.vexs[G.vexnum - 1] = w; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; G.arcs[i][G.vexnum - 1].adj = INFINITY; &#125; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; G.arcs[G.vexnum - 1][j].adj = INFINITY; &#125; j = G.vexnum - 1; &#125; G.arcs[i][j].adj = 1; G.arcs[j][i].adj = 1; G.arcnum++;&#125;bool DeleteVex(MGraph &amp;G , VertexType v)&#123; int l = LocateVex(G , v); cout&lt;&lt;l&lt;&lt;endl; if(l == -1)&#123; cout&lt;&lt;"No such point!"&lt;&lt;endl; return false; &#125; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; if(G.arcs[i][l].adj != INFINITY)&#123; G.arcs[i][l].adj = INFINITY; G.arcnum--; &#125; &#125; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; if(G.arcs[l][j].adj != INFINITY)&#123; G.arcnum--; G.arcs[l][j].adj = INFINITY; &#125; &#125; for(int i = l+1 ; i&lt;G.vexnum ; ++i)&#123; for(int j = 0 ; j&lt;G.vexnum ; ++j)&#123; G.arcs[i-1][j].adj = G.arcs[i][j].adj; &#125; &#125; for(int j = l+1 ; j&lt;G.vexnum ; ++j)&#123; for(int i = 0 ; i&lt;G.vexnum - 1 ; ++i)&#123; G.arcs[i][j-1].adj = G.arcs[i][j].adj; &#125; &#125; for(int i = l+1 ; i&lt;G.vexnum ; ++i)&#123; G.vexs[i-1] = G.vexs[i]; &#125; G.vexnum--; return true;&#125;bool DeleteArc(MGraph &amp;G , VertexType v , VertexType w)&#123; int i = LocateVex(G , v); int j = LocateVex(G , w); G.arcnum--; G.arcs[i][j].adj = INFINITY; G.arcs[j][i].adj = INFINITY;&#125;int main()&#123; MGraph G; CreateDN(G); print(G);&#125; 图的邻接表表示法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;#define MAX_NUM 20#define INFINITY INT_MAXtypedef char VertexType;//表结点typedef struct ArcNode &#123; int adjvex; //表示头结点的邻接点的序号 ArcNode *nextarc; //指向表示头结点的下一个邻接点 int weight; //无权图是0,1 有权图是权值 //InfoType *info;&#125;ArcNode;//头结点typedef struct VNode &#123; VertexType data; //表示头结点的data ArcNode *firstarc; //指向头结点的第一个邻接点&#125;VNode , AdjList[MAX_NUM];typedef struct&#123; AdjList vertices; //表结点的数组 int vexnum , arcnum; //顶点数和边数&#125;ALGraph;int LocateVex(ALGraph *G , VertexType v)&#123; for(int i = 0 ; i&lt;G-&gt;vexnum ; ++i)&#123; if(G-&gt;vertices[i].data == v)&#123; return i; &#125; &#125;&#125;void Create(ALGraph *G)&#123; cout&lt;&lt;"输入图的顶点数和边数："&lt;&lt;endl; cin&gt;&gt;G-&gt;vexnum&gt;&gt;G-&gt;arcnum; cout&lt;&lt;"输入顶点信息："&lt;&lt;endl; for(int i = 0 ; i&lt;G-&gt;vexnum ; ++i)&#123; cin&gt;&gt;G-&gt;vertices[i].data; G-&gt;vertices[i].firstarc = NULL; &#125; cout&lt;&lt;"输入(v1,v2,w)："&lt;&lt;endl; for(int k = 0 ; k&lt;G-&gt;arcnum ; ++k)&#123; VertexType v1 , v2; int w; cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; int i = LocateVex(G , v1); int j = LocateVex(G , v2); ArcNode *p = (ArcNode *)malloc(sizeof(ArcNode)); p-&gt;adjvex = j; p-&gt;nextarc = G-&gt;vertices[i].firstarc; G-&gt;vertices[i].firstarc = p; p-&gt;weight = w; //下面代码无向图有，有向图无 p = (ArcNode *)malloc(sizeof(ArcNode)); p-&gt;adjvex = i; p-&gt;nextarc = G-&gt;vertices[j].firstarc; G-&gt;vertices[j].firstarc = p; p-&gt;weight = w; &#125; //打印图 for(int i = 0 ; i&lt;G-&gt;vexnum ; ++i)&#123; ArcNode *p = G-&gt;vertices[i].firstarc; while(p)&#123; cout&lt;&lt;'('&lt;&lt;G-&gt;vertices[i].data&lt;&lt;','&lt;&lt;G-&gt;vertices[p-&gt;adjvex].data&lt;&lt;','&lt;&lt;p-&gt;weight&lt;&lt;')'&lt;&lt;' '; p = p-&gt;nextarc; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; ALGraph G; Create(&amp;G);&#125; 图的十字链表表示法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;#define MAX_NUM 20#define INFINITY INT_MAXtypedef char VertexType;//表结点typedef struct ArcBox&#123; int tailvex , headvex; //表示弧尾 和 弧头 的下标位置 ArcBox *hlink , *tlink; //hlink 指向头结点入度相同的表结点(即弧头相同), //tlink指向弧尾相同的表结点 //InfoType *info;&#125;ArcBox;typedef struct VexNode&#123; VertexType data; //头结点的数据信息 ArcBox *fristin , *fristout;// fristin 指向头结点的第一个入度的表结点， // fristout指向头结点的第一个出度的表结点&#125;VexNode;typedef struct &#123; VexNode xlist[MAX_NUM]; int vexnum , arcnum; //顶点数和边数&#125;OLGraph;int LocateVex(OLGraph G , VertexType v)&#123; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; if(G.xlist[i].data == v)&#123; return i; &#125; &#125;&#125;//构造有向图void CreateDG(OLGraph &amp;G)&#123; cout&lt;&lt;"输入图的顶点数和边数："&lt;&lt;endl; cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum; cout&lt;&lt;"输入图的头结点的数据信息："&lt;&lt;endl; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; cin&gt;&gt;G.xlist[i].data; G.xlist[i].fristin = NULL; G.xlist[i].fristout = NULL; &#125; cout&lt;&lt;"输入(v1,v2)："&lt;&lt;endl; for(int k = 0 ; k&lt;G.arcnum ; ++k)&#123; VertexType v1 , v2; cin&gt;&gt;v1&gt;&gt;v2; int i = LocateVex(G , v1); int j = LocateVex(G , v2); ArcBox *p = (ArcBox *)malloc(sizeof(ArcBox)); p-&gt;tailvex = i; p-&gt;headvex = j; p-&gt;hlink = G.xlist[j].fristin; p-&gt;tlink = G.xlist[i].fristout; G.xlist[j].fristin = G.xlist[i].fristout = p; &#125; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; ArcBox *p =G.xlist[i].fristout; while(p)&#123; cout&lt;&lt;'('&lt;&lt;G.xlist[i].data&lt;&lt;"-&gt;"&lt;&lt;G.xlist[p-&gt;headvex].data&lt;&lt;')'&lt;&lt;' '; p = p-&gt;tlink; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;"---------------------------------------------"&lt;&lt;endl; for(int i = 0 ; i&lt;G.vexnum ; ++i)&#123; ArcBox *p = G.xlist[i].fristin; while(p)&#123; cout&lt;&lt;'('&lt;&lt;G.xlist[i].data&lt;&lt;"&lt;-"&lt;&lt;G.xlist[p-&gt;tailvex].data&lt;&lt;')'&lt;&lt;' '; p = p-&gt;hlink; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; OLGraph G; CreateDG(G);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>待补充</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的实现]]></title>
    <url>%2F2019%2F09%2F29%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[二叉树的递归实现(链表)实现了二叉树的生成以及三种遍历方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;#define OK true;#define ERROR false;typedef struct BiTNode&#123; char data; BiTNode *lchild , *rchild;&#125;BiTNode , *BiTree;//构造树bool CreatBiTree(BiTree &amp;T)&#123; char ch; cin&gt;&gt;ch; if(ch == '#') T = NULL; else&#123; T = (BiTree)malloc(sizeof(BiTNode)); if(!T) return ERROR; T-&gt;data = ch; // 生成根节点 CreatBiTree(T-&gt;lchild); //生成左子树 CreatBiTree(T-&gt;rchild); //生成右子树 &#125; return OK;&#125;//前序遍历void PreOrder(BiTree T)&#123; if(T)&#123; cout&lt;&lt;T-&gt;data&lt;&lt;' '; PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); &#125;&#125;//中序遍历void InOrder(BiTree T)&#123; if(T)&#123; InOrder(T-&gt;lchild); cout&lt;&lt;T-&gt;data&lt;&lt;' '; InOrder(T-&gt;rchild); &#125;&#125;void PostOrder(BiTree T)&#123; if(T)&#123; PostOrder(T-&gt;lchild); PostOrder(T-&gt;rchild); cout&lt;&lt;T-&gt;data&lt;&lt;' '; &#125;&#125;int main()&#123; BiTree T; CreatBiTree(T); PreOrder(T); cout&lt;&lt;endl; InOrder(T); cout&lt;&lt;endl; PostOrder(T);&#125; 二叉树的非递归算法(链表)实现了二叉树的三种遍历方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;#define OK true;#define ERROR false;typedef struct BiTNode&#123; char data; BiTNode *lchild , *rchild;&#125;BiTNode , *BiTree;typedef struct Stack&#123; BiTree data; Stack *Next;&#125;Stack , *StackList;typedef struct&#123; StackList base; StackList top;&#125;ListStack;bool InitStack(ListStack &amp;s)&#123; s.base = (StackList)malloc(sizeof(Stack)); if(!s.base) return ERROR; s.top = s.base; s.top-&gt;Next = NULL; return OK;&#125;bool push(ListStack &amp;s , BiTree T)&#123; StackList p = (StackList)malloc(sizeof(Stack)); if(!p) return ERROR; p-&gt;data = T; p-&gt;Next = s.top; s.top = p; return OK;&#125;bool pop(ListStack &amp;s)&#123; if(s.top == s.base) return ERROR; StackList p = s.top; s.top = p-&gt;Next; free(p); return OK;&#125;BiTree getTop(ListStack &amp;s)&#123; return s.top-&gt;data;&#125;bool isEmpty(ListStack &amp;s)&#123; if(s.base == s.top) return true; else return false;&#125;//构造树bool CreatBiTree(BiTree &amp;T)&#123; char ch; cin&gt;&gt;ch; if(ch == '#') T = NULL; else&#123; T = (BiTree)malloc(sizeof(BiTNode)); if(!T) return ERROR; T-&gt;data = ch; // 生成根节点 CreatBiTree(T-&gt;lchild); //生成左子树 CreatBiTree(T-&gt;rchild); //生成右子树 &#125; return OK;&#125;void PreOrder(BiTree T)&#123; ListStack s; InitStack(s); while(T || !isEmpty(s))&#123; while(T)&#123; cout&lt;&lt;T-&gt;data&lt;&lt;' '; push(s , T); T = T-&gt;lchild; &#125; if(!isEmpty(s))&#123; T = getTop(s); pop(s); T = T-&gt;rchild; &#125; &#125; cout&lt;&lt;endl;&#125;void InOrder(BiTree T)&#123; ListStack s; InitStack(s); while(T || !isEmpty(s))&#123; while(T)&#123; push(s , T); T = T-&gt;lchild; &#125; if(!isEmpty(s))&#123; T = getTop(s); pop(s); cout&lt;&lt;T-&gt;data&lt;&lt;' '; T = T-&gt;rchild; &#125; &#125; cout&lt;&lt;endl;&#125;void PostOrder(BiTree T)&#123; ListStack s; InitStack(s); int flag = 1; // 用来判断是否进入右子树 BiTree p; if(T)&#123; do&#123; while(T)&#123; push(s , T); T = T-&gt;lchild; &#125; flag = 1; p = NULL; while(!isEmpty(s) &amp;&amp; flag == 1)&#123; T = getTop(s); // 因为经过第一个while循环，T = NULL,所以要把他变回来 if(T-&gt;rchild == p)&#123; cout&lt;&lt;T-&gt;data&lt;&lt;' '; p = T; //用于判断此节点的右孩子是否已经被访问，或者是没有右孩子 pop(s); &#125; else &#123; T = T-&gt;rchild; flag = 0; &#125; &#125; &#125;while(!isEmpty(s)); &#125; cout&lt;&lt;endl;&#125;int main()&#123; BiTree T; CreatBiTree(T); PreOrder(T); InOrder(T); PostOrder(T);&#125; 线索二叉树中序遍历的实现线索二叉树的初始化与普通二叉树相比，多了一个指示域：LTag和RTag，如果值是Link，那么有左孩子或右孩子，如果是Thread，那么有前驱或后继。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;#define OK true;#define ERROR false;typedef enum PointerTag&#123; // 声明PointTag为枚举类型 Link, Thread&#125;;typedef struct BiThrNode&#123; char data; BiThrNode *lchild , *rchild; PointerTag LTag , RTag;&#125;BiThrNode , *BiThrTree;bool CreatBiTree(BiThrTree &amp;T)&#123; char ch; cin&gt;&gt;ch; if(ch == '#') T = NULL; else&#123; T = (BiThrTree)malloc(sizeof(BiThrNode)); if(!T) return ERROR; T-&gt;data = ch; // 生成根节点 T-&gt;LTag = Link; T-&gt;RTag = Link; CreatBiTree(T-&gt;lchild); //生成左子树 CreatBiTree(T-&gt;rchild); //生成右子树 &#125; return OK;&#125; 遍历在线索树上遍历，只需找到要遍历的第一个节点，然后依次按照三种遍历方式的规定找后继就可以了。要遍历线索树，就要把普通的二叉树线索化，就是按照规定把空指针改为前驱或后继，所以三种遍历方式的线索化操作是不同的。 中序遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263BiThrTree pre;//中序遍历线索化void InThreading(BiThrTree p)&#123; if(p)&#123; InThreading(p-&gt;lchild); // 左子树进行线索化 //基本操作 if(!p-&gt;lchild) &#123; // 左子树为空 p-&gt;LTag = Thread; // 修改左指示为前驱 p-&gt;lchild = pre; // 修改左孩子为前驱 &#125; if(!pre-&gt;rchild)&#123; pre-&gt;RTag = Thread; pre-&gt;rchild = p; &#125; pre = p; InThreading(p-&gt;rchild); // 右子树线索化 &#125;&#125;bool InOrderThreading(BiThrTree &amp;Thrt , BiThrTree T)&#123; //中序遍历T, 将其线索化，Thrt指向头结点 Thrt = (BiThrTree)malloc(sizeof(BiThrNode)); if(!Thrt) return ERROR; Thrt-&gt;LTag = Link; //建立头结点 Thrt-&gt;RTag = Thread; Thrt-&gt;rchild = Thrt; if(!T) Thrt-&gt;lchild = Thrt; // 如果是空树 else &#123; Thrt-&gt;lchild = T; pre = Thrt; //pre 为p 的前驱 InThreading(T); // 线索化 pre-&gt;rchild = Thrt; pre-&gt;RTag = Thread; Thrt-&gt;rchild = pre; &#125; return OK;&#125;// 非递归void InOrderPrint(BiThrTree Thrt)&#123; BiThrTree p = Thrt-&gt;lchild; // Thrt 是头结点，没有值 while(p != Thrt)&#123; // 如果是空树或遍历完毕时， p== Thrt while(p-&gt;LTag == Link) p = p-&gt;lchild; // 先找到遍历每个子树的第一个节点 cout&lt;&lt;p-&gt;data; while(p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != Thrt)&#123; // 如果有后继，并且不是最后一个节点 p = p-&gt;rchild; // 指向他的后继 cout&lt;&lt;p-&gt;data; //输出后继 &#125; p = p-&gt;rchild; // 没有后继时，指向他的右孩子，然后继续执行到右子树的要遍历的第一个节点 &#125; cout&lt;&lt;endl;&#125;int main()&#123; BiThrTree T , Thrt; CreatBiTree(T); InOrderThreading(Thrt , T); InOrderPrint(Thrt);&#125; 前序遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566BiThrTree pre;void PreThreading(BiThrTree p)&#123; if(p)&#123; if(!p-&gt;lchild)&#123; p-&gt;lchild = pre; p-&gt;LTag = Thread; &#125; if(!pre-&gt;rchild)&#123; pre-&gt;rchild = p; pre-&gt;RTag = Thread; &#125; pre = p; if(p-&gt;LTag == Link)&#123; //这个判断条件必须加，不然会死循环 PreThreading(p-&gt;lchild); &#125; if(p-&gt;RTag == Link)&#123; PreThreading(p-&gt;rchild); &#125; &#125;&#125;// 与中序遍历相同bool PreOrderThreading(BiThrTree &amp;Thrt , BiThrTree T)&#123; //中序遍历T, 将其线索化，Thrt指向头结点 Thrt = (BiThrTree)malloc(sizeof(BiThrNode)); if(!Thrt) return ERROR; Thrt-&gt;LTag = Link; //建立头结点 Thrt-&gt;RTag = Thread; Thrt-&gt;rchild = Thrt; if(!T) Thrt-&gt;lchild = Thrt; // 如果是空树 else &#123; Thrt-&gt;lchild = T; pre = Thrt; //pre 为p 的前驱 PreThreading(T); // 线索化 pre-&gt;rchild = Thrt; pre-&gt;RTag = Thread; Thrt-&gt;rchild = pre; &#125; return OK;&#125;void PreOrderprint(BiThrTree T)&#123; BiThrTree p = T-&gt;lchild; while(p != T)&#123; cout&lt;&lt;p-&gt;data; if(p-&gt;LTag == Link)&#123; p = p-&gt;lchild; &#125; else &#123; p = p-&gt;rchild; &#125; &#125;&#125;int main()&#123; BiThrTree T , Thrt; CreatBiTree(T); PreOrderThreading(Thrt , T); PreOrderprint(Thrt);&#125; 后序遍历]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列的实现]]></title>
    <url>%2F2019%2F09%2F29%2F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[常规链队列的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;using namespace std;#define OK true;#define ERROR false;typedef struct QNode&#123; int data; QNode *Next;&#125;QNode , *QueuePtr;typedef struct&#123; QueuePtr Front; QueuePtr Rear;&#125;LinkQueue;bool Init(LinkQueue &amp;Q)&#123; Q.Front = Q.Rear = (QueuePtr)malloc(sizeof(QNode)); if(!Q.Front)&#123; return ERROR; &#125; Q.Front-&gt;Next = NULL; return OK;&#125;//插入bool Insert(LinkQueue &amp;Q , int e)&#123; QueuePtr p = (QueuePtr)malloc(sizeof(QNode)); if(!p)&#123; return ERROR; &#125; p-&gt;data = e; p-&gt;Next = NULL; Q.Rear-&gt;Next = p; Q.Rear = p; return OK;&#125;//删除bool Delete(LinkQueue &amp;Q , int &amp;e)&#123; if(Q.Front == Q.Rear) return ERROR; QueuePtr p = Q.Front-&gt;Next; e = p-&gt;data; Q.Front-&gt;Next = p-&gt;Next; if(Q.Rear == p) Q.Rear = Q.Front; //当队列中只有一个元素时 free(p); return OK;&#125;//遍历void print(LinkQueue Q)&#123; if(Q.Front == Q.Rear)&#123; cout&lt;&lt;"没有元素"&lt;&lt;endl; &#125; else &#123; Q.Front = Q.Front-&gt;Next; while(Q.Front)&#123; cout&lt;&lt;Q.Front-&gt;data&lt;&lt;' '; Q.Front = Q.Front-&gt;Next; &#125; &#125; cout&lt;&lt;endl;&#125;//销毁队列bool DestroyQueue(LinkQueue &amp;Q)&#123; while(Q.Front)&#123; Q.Rear = Q.Front-&gt;Next; free(Q.Front); Q.Front = Q.Rear; &#125; return OK;&#125;int main()&#123; LinkQueue Q; Init(Q); for(int i = 0 ; i&lt;5 ; ++i)&#123; int n; cin&gt;&gt;n; Insert(Q , n); &#125; print(Q); int e; Delete(Q , e); cout&lt;&lt;endl; cout&lt;&lt;e&lt;&lt;endl; print(Q); DestroyQueue(Q); print(Q);&#125; 循环队列的实现循环队列主要是针对队列的顺序存储结构，主要目的是避免顺序存储中的内存空间的浪费。 下面的这种方法少用一个储存空间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;#define OK true;#define ERROR false;#define MAXSIZE 6typedef struct Queue&#123; int *base; int Front; int Rear;&#125;Queue;bool Init(Queue &amp;Q)&#123; Q.base = (int *)malloc(MAXSIZE * sizeof(int)); if(!Q.base) return ERROR; Q.Front = Q.Rear = 0; return OK;&#125;//队列长度int getLength(Queue &amp;Q)&#123; return (Q.Rear - Q.Front + MAXSIZE) % MAXSIZE;&#125;bool Insert(Queue &amp;Q , int e)&#123; if((Q.Rear + 1) % MAXSIZE == Q.Front) return ERROR; //队列满的标志 Q.base[Q.Rear] = e; Q.Rear = (Q.Rear + 1)%MAXSIZE; return OK;&#125;bool Delete(Queue &amp;Q , int &amp;e)&#123; if(Q.Front == Q.Rear) return ERROR; //队列空的标志 e = Q.base[Q.Front]; Q.Front = (Q.Front + 1)%MAXSIZE; return OK;&#125;void print(Queue Q)&#123; if(Q.Front == Q.Rear) cout&lt;&lt;"队列空"&lt;&lt;endl; else &#123; while((Q.Front + 1)%MAXSIZE != Q.Rear)&#123; cout&lt;&lt;Q.base[Q.Front]&lt;&lt;' '; Q.Front = Q.Front+1; &#125; cout&lt;&lt;Q.base[Q.Front]; &#125; cout&lt;&lt;endl;&#125;int main()&#123; Queue Q; Init(Q); for(int i = 0 ; i&lt;5 ; ++i)&#123; int n; cin&gt;&gt;n; bool a; a = Insert(Q , n); cout&lt;&lt;a&lt;&lt;' '; &#125; int e; cout&lt;&lt;endl; cout&lt;&lt;getLength(Q)&lt;&lt;endl; print(Q); //cout&lt;&lt;Q.Front&lt;&lt;' '&lt;&lt;Q.Rear&lt;&lt;endl; Delete(Q , e); cout&lt;&lt;e&lt;&lt;endl; print(Q); cout&lt;&lt;getLength(Q)&lt;&lt;endl; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于CenterNet的理解]]></title>
    <url>%2F2019%2F09%2F27%2FCenterNet%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Introduction在CenterNet中，作者找到了更简单、更有效的方法，作者用bbox的中心点来代替此物体，其他特征，比如物体大小，维度，姿态等等则从物体中心点位置的图像特征来直接回归，所以目标检测就变成了关键点的预测问题。一开始将图像输入到一个全卷积中，然后生成一个热图，热图中的峰值就对应于物体的中心点，每个峰值的图像特征就用于预测物体bbox的高和宽，训练用标准的密集监督学习，推理过程是一个单一的向前传播，没有NMS的后处理。 Related workCenterNet方法近似相当于锚点为基准的one-stage方法。 CenterNet仅仅根据位置来分配’anchor’，而不是根据框重叠，也就是说，CenterNet的’anchor’仅仅会出现在当前目标的位置处而不是在整个图上都分配，所以不用手动调阈值来看框是正类还是负类； 每个物体只有一个正框，所以不需要NMS来后处理，只需要在关键点热图上提取峰值； CenterNet输出的下采样因子是4，所以输出分辨率相比其他框架来说更大，这样就消除了对于多重锚点的需求； 疑问：多重锚点是什么意思？？（原文是‘This eliminates the need for multiple anchors’） Preliminary假设输入图像的维度为(3 , W , H)，那么目标就是生成一个热图，Y∈[0,1] ，其中Y的维度是(C , W/R , H/R)，C在目标检测中是类别，论文用coco数据集，所以C=80，论文中作者取R=4，表示下采样的步幅是4，那么为什么要生成这样一个热图呢，原来这个三维张量Y中的每一个值如果是1的话，那么代表这是检测的关键点，如果是0的话代表的是背景，所以Y的值要在0和1之间，表示概率，论文中用了几种不同的encoder-decoder networks来预测图像中的Y: Hourglass Network 带有转置卷积的ResNet 原始的DLA和作者改造后的DLA； 在训练过程中，CenterNet学习了CornerNet的方法，对于每个ground truth 的某一类C，我们需要把p(中心点)计算出来进行训练，计算方法为p = ((x1 + x2)/2 ，(y1 + y2)/2)，对于下采样后的坐标，我们设，其中R为下采样因子，并且向下取整，所以最终计算出来的中心点是对应低分辨率的中心点。有了中心点的坐标后，接下来的任务就是如何根据gt关键点的坐标来生成热图，作者用了一个高斯核来将计算好的关键点分布到如图中，其中 σp是一个对物体大小自适应的标准差。这样就生成了一个热图 疑问：px和py都是整数，那么x和px 在计算高斯核的时候是如何匹配的？？或者对于高斯核的理解一开始就是错的？？ 损失函数重点看一下损失函数： 中心点预测的损失函数 作者对于中心点位置和类别的预测是通过Focal-loss来进行逻辑回归的， α and β是超参数，论文中α=2，β=4，N是图像中关键点的个数，目的是将Focal-loss归一化。 疑问：N的数量是不多的，但是Lk是对所有的点来算损失函数的，那么为什么N可以将Focal-loss归一化？？ 目标中心的偏置损失 由于对于图像进行了R=4的下采样，但是中心点最终是要映射回原图的，这样会有精度损失，因此，对于每一个中心点，都额外采用一个局部偏移量，根据维度也可以看出，对于同一位置的所有类别，这个局部偏移量是共享的。注意上面的损失函数仅仅是对于关键点位置来算的，其他的点是要被忽略的。 疑问： 1. 中心点最终是如何映射到原图的？？是简单的乘4？？ 2. 为什么局部偏移量要对所有类进行共享？？是为了减少计算量？？ 3. 这个偏移量是在缩小后的图像上的偏移，但是在原图上的偏移和这个偏移应该是不一样的吧？？ 4. 回归的目的不就是为了减少偏移量吗？那为什么还要算偏移损失？？ 目标大小的损失 假设是Ck类的目标k的bbox，那么中心点的坐标就是pk = ，我们用Y^来预测所有的关键点，然后对每个目标k的size 进行回归，Sk = ，这是下采样后的长宽值，是预测值，由维度可知，这是所有的类别共享的size值。 疑问：为什么所有的类都在一个中心点出有相同的size？？ 总的损失函数为： 论文中 λsize = 0.1, λoff = 1。 最终每个坐标点产生C+4个数据，分别是类别、长宽和偏移量，这三个量是用一个单独的网络来预测出来的，并且所有的输出共享一个backbone网络。 推测阶段在预测阶段，首先对一张图像进行下采样，然后在下采样的特征图中对每个类预测中心点，然后就可以把输出图中每个类的热点单独提取出来，提取过程是什么呢，首先，可以检测当前热点的值是否比周围八个邻近的热点都大，然后提取出100个这样的点，方式是3x3的Maxpool，类似于NMS。最后，通过预测点算出来的Y^，代码中设置阈值为0.3，将这100个点中大于0.3的作为最终要的结果。这样，有了中心点的位置后就可以生产锚框了。即变成(x1 , y1 , x2 , y2)的锚框]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>待补充</tag>
        <tag>CenterNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Focal Loss的理解]]></title>
    <url>%2F2019%2F09%2F26%2FFocal-Loss%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[声明：这篇论文还未读，所以里面所有内容都是来自于各种网络大佬的理解，等自己读了论文后有待补充。 为什么要提出Focal-loss现在目标检测大概分为两种: one-stage和two-stage，one-stage虽然速度快，但是精度不如two-stage的，相反，two-stage虽然精度高，但是速度慢，后来Lin等人对于此问题的研究发现，one-stage的精度不高与训练时后景数据相比于前景数据少的多有很大原因，因此Lin等人通过对交叉熵损失函数进行修改，提了Focal-loss，即会特别关注某些Loss的意思。 论文分析了One-stage精度不高的原因 正负样本极度不均衡：anchor的生成是用类似于sliding-windows的方式，这会导致正负样本的比例接近1:1000，而且绝大多数负样本为“easy example”； 梯度优化过程中被easy example过度影响: 根据交叉熵损失函数，虽然easy example的Loss不高，但是数量多，所以在梯度优化时Loss函数会过度关注这些easy example，从而使得那些难以分类的类别得不到很好的训练。 对于Focal-loss 的理解 首先回顾一下交叉熵损失函数：其中是经过激活函数的输出，在0-1之间，所以普通的交叉熵就是正样本的输出概率越大，那么Loss就越小，对于负样本，输出概率越小，Loss就越小。 再看加了gama后的Loss函数：在加入了gama后，就对难易样本的loss有了区分，对于正样本而言，如果输出为0.9，那么表明这个样本是容易训练的，所以Loss就变得比原来小，如果输出是0.5，表明难以训练，所以Loss就大，所以就使得Loss函数更加关注难训练的样本，所以减少了easy example的影响，论文实验发现gama=2是最优的。 Focal-loss的最终版本：α的加入实际上是使交叉熵加权，α一般设置为类别比例的倒数或者直接设为超参数(人为设定)，这样使得正样本(数量少)得到Loss的重视，从而减少负样本的影响。 为什么Focal loss没有用在two-stage上 two-stage会在生成区域建议阶段来使用NMS，使得候选框大量减少，在此过程中，减少了大量的背景框； 训练时用minibatch的采样策略，比如Faster-rcnn使用正负样本为1:3，这实际上起到了α 的作用。 感谢 https://www.sogou.com/link?url=hedJjaC291OoAuWay7Ycy8qCqnS5BeBJZpR6MQDH4jecmW7u2WhTZknbb2GMMgFg6KnxECbDvSOfABNiu1prjGiLSQm6y_cjIxl1zdOoaQG8NQzjFsXswHMpU5R1W7o9LJ3yweXqb0A4XXtlfpMI6PAjn7Fnn5gA https://www.cnblogs.com/king-lps/p/9497836.html]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Focal-Loss-OD</tag>
        <tag>待补充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 简单教程]]></title>
    <url>%2F2019%2F09%2F08%2FMarkdown%2F</url>
    <content type="text"><![CDATA[区块元素 标题Markdown支持两种标题的语法 1.类Setext 形式利用底线的形式，利用=(表示最高阶题)，-（表示第二阶题）， 任何数量的 = 和 - 都可以有效果，例如： 1234&gt; This is an H1&gt;=================&gt;This is an H2&gt;------------------ 2.类Atx形式则是利用#的数量从1到6来表示标题的阶，例如： 123&gt;# This is H1&gt;## This is H2&gt;###### This is H6 区块引用先断好行，然后在每行前加&gt;，例如： 1&gt;This is a blockquote 效果如下： This is a blockquote Markdown 也允许只在整个段落的第一行加 &gt; : 1&gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. 效果如下： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. 区块引用允许嵌套（引用内引用），根据层次不用加不同数量的&gt; ，例如： 1&gt;&gt;This is my House 效果如下： This is my House 引用区块也可以使用其他Markdown 语法，例如： 1234567&gt; ## This is H1&gt;&gt; 1. 这是第一行列表项&gt;&gt; 代码：&gt;&gt;（这里要有两个缩进）return shell_exec("echo $input | $markdown_script"); 效果如下： ##This is H11.这是第一行列表项 return shell_exec(&quot;echo $input | $markdown_script&quot;); 列表分为有序列表和无序列表 1.无序列表使用* + 或 - : 123* hhh+ jjj- kkk 效果如下： hhh jjj kkk 可以看出，三者等同 2.有序列表使用数字和一个英文句点： hhh jjj kkk 代码区块具体语法如下： 12345这是一个普通段落： int a; int b; c = a + b; 分割线1234**** * *- - ----------------------------- 效果如下： 效果都是一样的 区段元素 链接支持两种形式的链接语法，行内式和参考式这里仅介绍行内式语法简单为：[]+()[] 中为链接文字，() 中为网址链接例如： 12This is [an example](http://example.com/ "Title") inline link.[This link](http://example.net/) has no title attribute. 效果如下：This is an example inline link.This link has no title attribute. 强调文字用 * 或 _ 包围会变斜，用** 或 __ 包围会变粗例如： 1234*会变斜*_会变斜_**会变粗**__会变粗__ 效果如下：会变斜会变斜会变粗会变粗 代码如果要标记一小段行内代码，可以用` 把他包起来： 1Use the `cout&lt;&lt;sddsff;` function. 效果如下： Use the cout&lt;&lt;sddsff; function. 图片简单语法如下：！+ [图片的替代文字] + (网址)例如： 1![pkq!!!](2019-09-08-Markdown/pkq.jpg) 效果如下: 到目前为止，Markdown还没有办法指定图片的高和宽，可以用&lt;img&gt;标签 自动链接将链接用&lt;&gt;包起来例如： 1&lt;http://example.com/&gt; 效果如下：http://example.com/ 感谢 感谢http://www.markdown.cn/#code-blocks]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
